<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Svg</title>
      <link href="/94liucc/2023/02/03/Svg/"/>
      <url>/94liucc/2023/02/03/Svg/</url>
      
        <content type="html"><![CDATA[<h1 id="Svg"><a href="#Svg" class="headerlink" title="Svg"></a>Svg</h1><h2 id="pattern"><a href="#pattern" class="headerlink" title="pattern"></a>pattern</h2><h3 id="一个图案填充标签，可以在-pattern-中定义好图案，然后通过-id-引用来对某个图形进行填充"><a href="#一个图案填充标签，可以在-pattern-中定义好图案，然后通过-id-引用来对某个图形进行填充" class="headerlink" title="一个图案填充标签，可以在 pattern 中定义好图案，然后通过 id 引用来对某个图形进行填充"></a>一个图案填充标签，可以在 pattern 中定义好图案，然后通过 id 引用来对某个图形进行填充</h3><h3 id="使用-rect-来填充这个-pattern"><a href="#使用-rect-来填充这个-pattern" class="headerlink" title="使用 rect 来填充这个 pattern"></a>使用 rect 来填充这个 pattern</h3><h2 id="defs"><a href="#defs" class="headerlink" title="defs"></a>defs</h2><h3 id="定义一些可供重用的元素，组等"><a href="#定义一些可供重用的元素，组等" class="headerlink" title="定义一些可供重用的元素，组等"></a>定义一些可供重用的元素，组等</h3><h2 id="use"><a href="#use" class="headerlink" title="use"></a>use</h2><h3 id="用来使用-被定义的元素"><a href="#用来使用-被定义的元素" class="headerlink" title="用来使用 被定义的元素"></a>用来使用 被定义的元素</h3><h2 id="symbol"><a href="#symbol" class="headerlink" title="symbol"></a>symbol</h2><h3 id="定义一组可重用的元素"><a href="#定义一组可重用的元素" class="headerlink" title="定义一组可重用的元素"></a>定义一组可重用的元素</h3><h3 id="可以定义自己的视窗"><a href="#可以定义自己的视窗" class="headerlink" title="可以定义自己的视窗"></a>可以定义自己的视窗</h3><h2 id="textPath"><a href="#textPath" class="headerlink" title="textPath"></a>textPath</h2><h3 id="可以根据传入的-path-值来放置-text-文字"><a href="#可以根据传入的-path-值来放置-text-文字" class="headerlink" title="可以根据传入的 path 值来放置 text 文字"></a>可以根据传入的 path 值来放置 text 文字</h3>]]></content>
      
      
      <categories>
          
          <category> abc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 123 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>渲染优化</title>
      <link href="/94liucc/2022/03/28/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96/"/>
      <url>/94liucc/2022/03/28/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="浏览器渲染过程"><a href="#浏览器渲染过程" class="headerlink" title="浏览器渲染过程"></a>浏览器渲染过程</h2><ul><li><p>解析 HTML 生成 DOM tree</p></li><li><p>解析 CSS 生成 CSSOM Tree</p></li><li><p>JS 通过 DOM API 和 CSSOM API 来操作 DOM tree 和 CSS tree，浏览器将 DOM Tree 和 CSSOM Tree 合成 Render Tree</p></li></ul><h3 id="布局-layout"><a href="#布局-layout" class="headerlink" title="布局 layout"></a>布局 layout</h3><ul><li>根据生成的 RenderTree 计算每个节点的位置，大小，样式等等</li></ul><h3 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h3><ul><li>根据每个节点的位置信息，得到每个节点的绝对像素</li></ul><h3 id="展示"><a href="#展示" class="headerlink" title="展示"></a>展示</h3><ul><li>将像素信息发布到 GPU，展示到页面上</li></ul><h2 id="页面渲染技术架构"><a href="#页面渲染技术架构" class="headerlink" title="页面渲染技术架构"></a>页面渲染技术架构</h2><h3 id="服务端渲染"><a href="#服务端渲染" class="headerlink" title="服务端渲染"></a>服务端渲染</h3><ul><li><p>后端同步渲染 JSP</p><ul><li>先实现业务逻辑和数据，再输出 HTML</li><li>需求变更上线周期比较长</li></ul></li></ul><h3 id="客户端渲染"><a href="#客户端渲染" class="headerlink" title="客户端渲染"></a>客户端渲染</h3><ul><li><p>页面静态化</p><ul><li><p>生成静态 HTML 页面</p><ul><li>包含请求的数据</li></ul></li><li><p>提高页面访问速度，降低服务器负担</p></li><li><p>服务器存储占用问题</p></li><li><p>链接更新有问题</p></li><li><p>实现</p><ul><li>已有的动态内容生成静态页面</li></ul></li></ul></li><li><p>前后端分离</p></li><li><p>单页面应用</p><ul><li>SPA</li><li>首次加载时间较多</li></ul></li><li><p>BigPipe</p><ul><li>PHP?</li></ul></li><li><p>同构直出</p><ul><li>一套代码既可以在服务端运行也可以在客户端运行</li><li>降低首屏渲染时间</li><li>前端人员负责 前端和后端的开发</li></ul></li><li><p>PWA</p><ul><li>service worker</li><li>渐进式网络应用</li></ul></li></ul><h2 id="页面加载"><a href="#页面加载" class="headerlink" title="页面加载"></a>页面加载</h2><h3 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h3><ul><li>延迟加载</li><li>减少当前屏无效资源的加载</li><li>lazy-data</li></ul><h3 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h3><ul><li>preload,prefetch,preconnect</li></ul><h3 id="预渲染"><a href="#预渲染" class="headerlink" title="预渲染"></a>预渲染</h3><ul><li>prerender</li></ul><h3 id="按需加载"><a href="#按需加载" class="headerlink" title="按需加载"></a>按需加载</h3><ul><li>Router</li></ul>]]></content>
      
      
      <categories>
          
          <category> 性能优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>静态资源优化</title>
      <link href="/94liucc/2022/03/25/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E4%BC%98%E5%8C%96/"/>
      <url>/94liucc/2022/03/25/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="图片优化"><a href="#图片优化" class="headerlink" title="图片优化"></a>图片优化</h2><h3 id="图片分类"><a href="#图片分类" class="headerlink" title="图片分类"></a>图片分类</h3><ul><li><p>jpeg</p><ul><li>不支持透明度</li></ul></li><li><p>png</p><ul><li><p>无损压缩</p><ul><li>索引，灰度，Alpha 通道</li></ul></li><li><p>文件比 JPEG 大</p></li><li><p>支持 24 位和 8 位</p></li></ul></li><li><p>GIF</p><ul><li>适合动画或图标</li></ul></li><li><p>Webp</p><ul><li>体积小 质量高</li></ul></li></ul><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ul><li><p>不同网络环境下 加载不同尺寸的图片</p><ul><li>通过参数控制请求的图片大小</li></ul></li><li><p>逐步加载图片</p><ul><li><p>图片加载成功之前 占位符</p></li><li><p>LQIP</p><ul><li>首先加载低质量的图片</li><li>npm install lqip</li></ul></li><li><p>SQIP</p><ul><li>基于 SVG 的低质量图片</li><li>npm install sqip</li></ul></li></ul></li><li><p>Web Font 代替图片</p></li><li><p>Data URL 代替</p></li></ul><h3 id="图片服务器自动优化"><a href="#图片服务器自动优化" class="headerlink" title="图片服务器自动优化"></a>图片服务器自动优化</h3><h2 id="HTML-优化"><a href="#HTML-优化" class="headerlink" title="HTML 优化"></a>HTML 优化</h2><h3 id="文件放到合适位置"><a href="#文件放到合适位置" class="headerlink" title="文件放到合适位置"></a>文件放到合适位置</h3><ul><li><p>CSS 文件链接放到头部</p><ul><li>CSS 加载不会阻塞 DOM tree 解析，但是会阻塞 DOM tree 渲染，减少浏览器重排文档次数</li></ul></li><li><p>JS 引用放到底部</p><ul><li>JS 加载，解析执行阻塞渲染</li></ul></li></ul><h2 id="CSS-优化"><a href="#CSS-优化" class="headerlink" title="CSS 优化"></a>CSS 优化</h2><h3 id="提升-CSS-文件加载性能"><a href="#提升-CSS-文件加载性能" class="headerlink" title="提升 CSS 文件加载性能"></a>提升 CSS 文件加载性能</h3><ul><li>尽量使用外链 CSS</li><li>尽量避免使用 @import</li></ul><h3 id="合理使用-WebFont"><a href="#合理使用-WebFont" class="headerlink" title="合理使用 WebFont"></a>合理使用 WebFont</h3><h2 id="JS-优化"><a href="#JS-优化" class="headerlink" title="JS 优化"></a>JS 优化</h2><h3 id="事件节流"><a href="#事件节流" class="headerlink" title="事件节流"></a>事件节流</h3><h3 id="动画优化"><a href="#动画优化" class="headerlink" title="动画优化"></a>动画优化</h3><ul><li><p>CSS 动画</p></li><li><p>Canvas 动画</p></li><li><p>尽量使用 requestAnimationFrame</p><ul><li>可以在正确的时机运行</li></ul></li></ul><h3 id="缓存优化"><a href="#缓存优化" class="headerlink" title="缓存优化"></a>缓存优化</h3><ul><li><p>Cookie</p><ul><li>用户信息等</li><li>cookie 数据始终在同源的 http 请求中携带</li><li>cookie 数据不能超过 4k</li><li>cookie 只在设置的 cookie 过期时间之前一直有效</li><li>cookie 也是在所有同源窗口中都是共享的</li></ul></li><li><p>sessionStorage</p><ul><li>本地存储的键值对</li><li>仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持</li><li>sessionStorage 不在不同的浏览器窗口中共享，即使是同一个页面</li></ul></li><li><p>indexedDB</p><ul><li>索引数据库</li></ul></li><li><p>localStorage</p><ul><li>缓存静态文件内容</li><li>浏览在页面的具体位置</li><li>始终有效，窗口或浏览器关闭也一直保存</li><li>localStorage 在所有同源窗口中都是共享的</li></ul></li></ul><!-- ## 减少浏览器回流和重绘## 减少 DOM 操作## 静态文件压缩和打包 -->]]></content>
      
      
      <categories>
          
          <category> 性能优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>应用层</title>
      <link href="/94liucc/2022/02/10/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/%E5%BA%94%E7%94%A8%E5%B1%82/"/>
      <url>/94liucc/2022/02/10/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/%E5%BA%94%E7%94%A8%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p><strong>基于 TCP</strong></p><h3 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h3><ul><li><p>请求行</p><ul><li><p>get</p><ul><li>查</li></ul></li><li><p>post</p><ul><li>增</li><li>创建一个资源</li></ul></li><li><p>put</p><ul><li>改</li></ul></li><li><p>delet</p><ul><li>删</li></ul></li></ul></li><li><p>首部字段</p><ul><li><p>key value 形式</p></li><li><p>content-type 等</p></li><li><p>Cache-control</p><ul><li>控制缓存</li></ul></li><li><p>if-Modified-Since</p><ul><li>判断服务器的资源是否更新</li></ul></li></ul></li></ul><h3 id="HTTP2-0"><a href="#HTTP2-0" class="headerlink" title="HTTP2.0"></a>HTTP2.0</h3><ul><li>对 http 头进行一定的压缩</li><li>分帧</li><li>多路复用等</li></ul><p><strong>QUIC 协议通过基于 UDP 自定义的类似 TCP 的连接、重试、多路复用、流量控制技术，进一步提升性能。</strong></p><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><ul><li>加密和解密的密钥相同</li><li>交互多的场景下多用对称加密</li></ul><h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><ul><li>机密和解密的密钥不同</li><li>客户端给服务器发送的时候，用服务器的公钥加密。而服务器给客户端发送消息的时候，使用客户端的公钥</li></ul><h3 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h3><ul><li>公钥和私钥主要用于传输对称加密的秘钥</li><li>双方大数据量的通信都是通过对称加密进行的</li></ul><h2 id="流媒体协议"><a href="#流媒体协议" class="headerlink" title="流媒体协议"></a>流媒体协议</h2><ul><li><p>视频压缩</p></li><li><p>视频编码</p><ul><li>H.264/MPEG-4 AVC</li><li>编码成二进制  格式</li></ul></li></ul><h2 id="DNS-协议"><a href="#DNS-协议" class="headerlink" title="DNS 协议"></a>DNS 协议</h2><ul><li><p>解析流程</p><ul><li>本地 DNS—根域名服务器—-顶级域名服务器—-权威域名服务器—-本地 DNS</li></ul></li><li><p>负载均衡</p><ul><li>域名解析的时候返回不同的 IP 地址，实现负载均衡</li></ul></li></ul><h2 id="HTTPDNS"><a href="#HTTPDNS" class="headerlink" title="HTTPDNS"></a>HTTPDNS</h2><ul><li><p>传统的 DNS 有很多问题，例如解析慢、更新不及时。因为缓存、转发、NAT 问题导致客户端误会自己所在的位置和运营商，从而影响流量的调度。</p></li><li><p>HTTPDNS 通过客户端 SDK 和服务端，通过 HTTP 直接调用解析 DNS 的方式，绕过了传统 DNS 的这些缺点，实现了智能的调度。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 通信协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> 协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通信协议</title>
      <link href="/94liucc/2022/01/29/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/"/>
      <url>/94liucc/2022/01/29/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><ul><li>DNS</li><li>HTTP、HTTPS</li></ul><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><ul><li>UDP</li><li>TCP</li></ul><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><ul><li>IP 协议</li></ul><h3 id="MAC-层"><a href="#MAC-层" class="headerlink" title="MAC 层"></a>MAC 层</h3><ul><li>网关</li><li>MAC 地址</li></ul><h3 id="DHCP-动态主机配置协议"><a href="#DHCP-动态主机配置协议" class="headerlink" title="DHCP 动态主机配置协议"></a>DHCP 动态主机配置协议</h3><ul><li>子网中动态配置 IP 地址</li></ul><h3 id="PXE-预启动执行环境"><a href="#PXE-预启动执行环境" class="headerlink" title="PXE 预启动执行环境"></a>PXE 预启动执行环境</h3>]]></content>
      
      
      <categories>
          
          <category> 通信协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> 协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>传输层</title>
      <link href="/94liucc/2022/01/27/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
      <url>/94liucc/2022/01/27/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/%E4%BC%A0%E8%BE%93%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h2 id="TCP-和-UDP-区别"><a href="#TCP-和-UDP-区别" class="headerlink" title="TCP 和 UDP 区别"></a>TCP 和 UDP 区别</h2><ul><li><p>TCP 面向连接，UDP 无连接</p></li><li><p>TCP 提供可靠交付，按顺序到达</p><ul><li>UDP 不保证不丢失</li></ul></li><li><p>TCP 面向字节流</p><ul><li>UDP 是基于 IP 包的，一个一个发，一个一个收</li></ul></li><li><p>TCP 有拥塞控制，意识到丢包或者网络不好了，会调整自己的行为</p></li></ul><h2 id="UDP-协议"><a href="#UDP-协议" class="headerlink" title="UDP 协议"></a>UDP 协议</h2><h3 id="包含"><a href="#包含" class="headerlink" title="包含"></a>包含</h3><ul><li>源端口，目标端口</li><li>UDP 长度 校验和</li></ul><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>沟通简单</li><li>安全性差</li><li>没有拥塞控制</li><li>可广播</li></ul><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><ul><li><p>对网络情况不敏感的场景</p><ul><li>内网</li></ul></li><li><p>可以广播的场景</p></li><li><p>具体</p><ul><li>QUIC 协议 网页或者 APP 访问</li><li>直播的视频传输协议</li><li>实时对战游戏</li><li>物联网</li></ul></li></ul><h2 id="TCP-协议"><a href="#TCP-协议" class="headerlink" title="TCP 协议"></a>TCP 协议</h2><h3 id="包含-1"><a href="#包含-1" class="headerlink" title="包含"></a>包含</h3><ul><li><p>源端口，目标端口</p></li><li><p>序号，确认序号</p></li><li><p>状态位</p></li><li><p>窗口大小</p><ul><li>做流量控制</li><li>拥塞控制</li></ul></li></ul><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><ul><li>请求—应答—-应答的应答</li></ul><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><ul><li>A—B</li><li>B—-A</li><li>B—A</li><li>A—B</li></ul><h3 id="TCP-状态机"><a href="#TCP-状态机" class="headerlink" title="TCP 状态机"></a>TCP 状态机</h3><h3 id="超时重试机制"><a href="#超时重试机制" class="headerlink" title="超时重试机制"></a>超时重试机制</h3><ul><li><p>超时间隔加倍</p><ul><li>每当遇到一次超时重传的时候，就会将下一次超时时间间隔设为先前值的两倍</li><li>两次超时，说明网络环境差</li></ul></li></ul><h3 id="流量控制问题"><a href="#流量控制问题" class="headerlink" title="流量控制问题"></a>流量控制问题</h3><h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><ul><li>TCP BBR 算法</li></ul><h2 id="Socket-套接字"><a href="#Socket-套接字" class="headerlink" title="Socket 套接字"></a>Socket 套接字</h2><ul><li>就是在应用层和传输层之间的一个抽象层，它把 TCP/IP 层复杂的操作抽象为几个简单的接口供应用层调用已实现进程在网络中通信</li></ul>]]></content>
      
      
      <categories>
          
          <category> 通信协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> 协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可视化</title>
      <link href="/94liucc/2021/12/08/%E5%89%8D%E7%AB%AF%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
      <url>/94liucc/2021/12/08/%E5%89%8D%E7%AB%AF%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%8F%AF%E8%A7%86%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="视觉"><a href="#视觉" class="headerlink" title="视觉"></a>视觉</h2><ul><li><p>理论基础</p></li><li><p>图形库和工具</p></li></ul><h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><ul><li><p>数据分析</p></li><li><p>数据处理</p></li><li><p>可视化设计</p></li></ul><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><ul><li><p>Canvas SVG webGL 性能优化</p></li><li><p>性能基准和性能检测的一般方法</p></li><li><p>海量数据处理新能优化</p></li></ul><h2 id="可视化工具"><a href="#可视化工具" class="headerlink" title="可视化工具"></a>可视化工具</h2><h3 id="图表库"><a href="#图表库" class="headerlink" title="图表库"></a>图表库</h3><ul><li>ECharts</li><li>chartlist</li><li>chart.js</li></ul><h4 id="地理库"><a href="#地理库" class="headerlink" title="地理库"></a>地理库</h4><ul><li>Mapbox</li><li>Leaflet</li><li>Deck.gl</li><li>CesiumJS</li></ul><h4 id="渲染库"><a href="#渲染库" class="headerlink" title="渲染库"></a>渲染库</h4><ul><li>ThreeJs</li></ul><h4 id="数据驱动框架"><a href="#数据驱动框架" class="headerlink" title="数据驱动框架"></a>数据驱动框架</h4><ul><li>D3.js</li><li>更专注于处理数据的组织形式</li></ul><h2 id="可视化实现"><a href="#可视化实现" class="headerlink" title="可视化实现"></a>可视化实现</h2><ol><li><p>HTML+CSS</p></li><li><p>SVG</p></li><li><p>Canvas2D</p></li><li><p>WebGL</p></li></ol><ul><li>GPU 能力</li><li>3D</li></ul><h2 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h2><ol><li><p>获取 context(‘2d’)</p></li><li><p>API</p></li></ol><ul><li><p>绘图状态</p></li><li><p>绘制命令</p><ul><li><p>context.translate</p><ul><li>画布平移转换</li></ul></li><li><p>context.save</p><ul><li>暂存状态</li></ul></li><li><p>context.restore</p><ul><li>恢复状态</li></ul></li></ul></li></ul><ol start="3"><li>过程</li></ol><ul><li>应当先处理数据，将数据内容与绘图指令建立映射关系，遍历数据，通过映射关系将数据内容的参数传给绘图指令</li></ul><h2 id="SVG"><a href="#SVG" class="headerlink" title="SVG"></a>SVG</h2><ol><li>创建 svg 元素</li></ol><ul><li>document.createElementNS()</li></ul><ol start="2"><li>更改元素属性</li></ol><ul><li>element.setAttribute()</li></ul><ol start="3"><li>优点</li></ol><ul><li>可以让图形的用户交互非常简单</li></ul><h2 id="WebGL"><a href="#WebGL" class="headerlink" title="WebGL"></a>WebGL</h2><ol><li><p>使用 WebGL 绘图，必须要和内存，GPU 打交道，控制图形输出的每一个细节</p></li><li><p>图形系统</p></li></ol><ul><li><p>光栅</p><ul><li>构成图像的像素阵列</li></ul></li><li><p>帧缓存</p><ul><li>像素信息被存放于帧缓存中</li></ul></li></ul><ol start="3"><li>绘制过程</li></ol><ul><li><p>创建 WebGL 上下文</p><ul><li>canvas.getContext(‘webgl’)</li></ul></li><li><p>创建 WebGL 程序</p><ul><li><p>GLSL 编程语言</p></li><li><p>两个着色器</p><ul><li><p>顶点着色器</p><ul><li>处理顶点的 GPU 代码，改变顶点的信息</li><li>计算出需要着色的像素点</li></ul></li><li><p>片元着色器</p><ul><li><p>处理光栅化后的像素信息</p></li><li><p>片元着色器对像素点着色的过程是并行的</p><ul><li>无论有多少个像素点，片元着色器都可以同时处理</li></ul></li></ul></li></ul></li></ul></li><li><p>将数据存入缓冲区</p><ul><li><p>首先定义顶点</p><ul><li>Float32Array 类型化数据</li></ul></li><li><p>将定义好的数据写入 WebGL 的缓冲区</p><ul><li>createBuffer</li><li>bindBuffer</li><li>bufferData</li></ul></li></ul></li><li><p>将缓冲区数据读取到 GPU</p></li><li><p>GPU 执行 WebGL 程序，输出结果</p><ul><li><p>gl.drawArrays()</p></li><li><p>gl_FragColor</p><ul><li>改变当前像素点颜色</li></ul></li></ul></li></ul><ol start="4"><li>顶点和图元</li></ol><ul><li><p>顶点</p><ul><li>几何图形的顶点</li></ul></li><li><p>图元</p><ul><li>WebGL 可直接处理的图形单元</li><li>由绘图模式决定</li><li>点，线，三角形等</li></ul></li></ul><ol start="5"><li><p>无论图形中有多少个像素点，着色器程序在 GPU 中会被同时执行多少次</p></li><li><p>顶点着色器</p></li></ol><ul><li><p>作用</p><ul><li><p>通过 gl_position 设置顶点</p></li><li><p>通过定义 varying 变量，向片元着色器传递数据</p><ul><li>通过给顶点映射不同的颜色，实现片元着色器渐变</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据可视化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据可视化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重学前端</title>
      <link href="/94liucc/2021/06/17/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF/"/>
      <url>/94liucc/2021/06/17/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h2><h3 id="运行时"><a href="#运行时" class="headerlink" title="运行时"></a>运行时</h3><ul><li><p>数据结构</p><ul><li><p>类型</p><ul><li>对象</li></ul></li><li><p>实例</p><ul><li>应用和机制</li></ul></li></ul></li><li><p>执行过程</p><ul><li>事件循环</li><li>微任务的执行</li><li>函数的执行</li><li>语句级的执行</li></ul></li></ul><h3 id="文法"><a href="#文法" class="headerlink" title="文法"></a>文法</h3><ul><li>词法</li><li>语法</li></ul><h3 id="语义"><a href="#语义" class="headerlink" title="语义"></a>语义</h3><h2 id="HTML-和-CSS"><a href="#HTML-和-CSS" class="headerlink" title="HTML 和 CSS"></a>HTML 和 CSS</h2><h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><ul><li><p>元素</p><ul><li>文档元信息</li><li>语义相关内容</li><li>链接</li><li>替换型元素</li><li>表单</li><li>表格</li><li>总集</li></ul></li><li><p>语言</p><ul><li>实体</li><li>命名空间</li></ul></li><li><p>补充标准</p></li></ul><h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><ul><li><p>语言</p><ul><li>@rule</li><li>选择器</li><li>单位</li></ul></li><li><p>功能</p><ul><li><p>布局</p><ul><li>正常流</li><li>弹性布局</li></ul></li><li><p>绘制</p><ul><li>颜色和形状</li><li>文字相关</li></ul></li><li><p>交互</p><ul><li>动画</li><li>其他  交互</li></ul></li></ul></li></ul><h2 id="浏览器的实现原理和-API"><a href="#浏览器的实现原理和-API" class="headerlink" title="浏览器的实现原理和 API"></a>浏览器的实现原理和 API</h2><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><ul><li>解析</li><li>构建 DOM 树</li><li>计算 CSS</li><li> 渲染 合成 绘制</li></ul><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><ul><li>DOM</li><li>CSSOM</li><li>事件</li><li>API 总集合</li></ul><h2 id="前端工程实践"><a href="#前端工程实践" class="headerlink" title="前端工程实践"></a>前端工程实践</h2><ul><li><p>性能</p></li><li><p>工具链</p></li><li><p>持续集成</p></li><li><p>搭建系统</p></li><li><p>架构和基础库</p></li></ul><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><ol><li>页面加载性能</li></ol><ul><li><p>与用户留存有关</p></li><li><p>指标：秒开率</p><ul><li>一秒之内打开的用户占用户总量的百分比</li></ul></li></ul><ol start="2"><li><p>动画与操作性能</p></li><li><p>内存 电量消耗</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 重学前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器</title>
      <link href="/94liucc/2021/06/17/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
      <url>/94liucc/2021/06/17/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF/%E6%B5%8F%E8%A7%88%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="构建过程"><a href="#构建过程" class="headerlink" title="构建过程"></a>构建过程</h2><ul><li><p>首先使用 HTTP 协议或者 HTTPS 协议，向服务器请求页面</p></li><li><p>请求回来的 HTML 代码经过解析，构建成 DOM 树</p></li><li><p>计算 DOM 树上的 CSS 属性</p></li><li><p>根据 CSS 属性对元素进行渲染，得到内存中的位图</p></li><li><p>可选步骤是对位图进行合并，极大提高后续绘制的速度</p></li><li><p>合成之后 绘制到界面上</p></li><li><p>注意</p><ul><li>不需要等到上一步骤完全结束，就开始处理上一步的输出</li></ul></li></ul><h2 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h2><h3 id="request"><a href="#request" class="headerlink" title="request"></a>request</h3><ul><li><p>request line</p><ul><li><p>method</p><ul><li><p>GET</p><ul><li>POST</li></ul></li><li><p>HEAD</p><ul><li>只返回请求头</li></ul></li><li><p>CONNECT</p><ul><li>多用于 HTTPS 和 WebSocket</li></ul></li><li><p>PUT</p><ul><li>DELETE</li></ul></li></ul></li><li><p>path</p></li><li><p>version</p></li></ul></li><li><p>head</p></li><li><p>body</p></li></ul><h3 id="response"><a href="#response" class="headerlink" title="response"></a>response</h3><ul><li><p>response line</p><ul><li><p>version</p></li><li><p>status code</p><ul><li><p>3**</p><ul><li><p>表示请求的目标有变化</p></li><li><p>301</p><ul><li>当前资源永久性转移</li></ul></li><li><p>302</p><ul><li>资源临时性转移</li></ul></li><li><p>304</p><ul><li>客户端本地的缓存版本，而且服务端  没有更新</li></ul></li></ul></li></ul></li><li><p>status text</p></li></ul></li><li><p>head</p></li><li><p>body</p></li></ul><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><ul><li><p>使用加密通道来传输 HTTP 的内容</p></li><li><p>首先与服务端建立一条 TLS 加密通道</p></li></ul><h2 id="HTTP2"><a href="#HTTP2" class="headerlink" title="HTTP2"></a>HTTP2</h2><ol><li>支持服务端推送</li></ol><ul><li>在客户端发送第一个请求到服务端时，提前把一部分内容推送给客户端，放入缓存当中</li></ul><ol start="2"><li>支持 TCP 连接复用</li></ol><ul><li>使用同一个 TCP 连接来传输多个 HTTP 请求，避免三次握手开销</li></ul><h2 id="DOM-树的构建过程"><a href="#DOM-树的构建过程" class="headerlink" title="DOM 树的构建过程"></a>DOM 树的构建过程</h2><h2 id="渲染-合成-绘制"><a href="#渲染-合成-绘制" class="headerlink" title="渲染 合成 绘制"></a>渲染 合成 绘制</h2>]]></content>
      
      
      <categories>
          
          <category> 重学前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS</title>
      <link href="/94liucc/2021/06/16/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF/JS/"/>
      <url>/94liucc/2021/06/16/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF/JS/</url>
      
        <content type="html"><![CDATA[<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><ol><li><p>Undefined,Null,Boolean,String,Number,Symbol,Object</p></li><li><p>undefined 和 null</p></li></ol><ul><li><p>undefined</p><ul><li>表示未定义</li><li>一个变量，而非关键字</li></ul></li><li><p>null</p><ul><li>表示定义了但没赋值</li><li>关键字</li></ul></li></ul><ol start="3"><li>Number</li></ol><ul><li><p>浮点数的类型，无法使用==来比较</p><ul><li>console.log( 0.1 + 0.2 == 0.3); //false</li><li>可以检查最小精度来判断是否相等</li></ul></li></ul><ol start="4"><li>类型转换</li></ol><ul><li><p>StringToNumber</p><ul><li><p>parseInt()</p></li><li><p>parseFloat()</p></li><li><p>Number(‘1234’)</p><ul><li><p>不会忽略非数字字符</p><ul><li>返回 NaN</li></ul></li></ul></li></ul></li></ul><ol start="5"><li>装箱转换</li></ol><ul><li><p>将基本类型转换为对应的对象</p><ul><li>new Number()</li></ul></li><li><p>装箱机制会频繁产生临时对象</p></li><li><p>应该尽量避免对基本类型做装箱转换</p></li></ul><ol start="6"><li>拆箱转换</li></ol><ul><li><p>把对象变为基本类型，再从基本类型转换为对应的 String 或者 Number</p></li><li><p>ToPrimitive 函数</p></li><li><p>会尝试调用 valueOf 和 toString 来获得拆箱后的基本类型</p><ul><li>如果 valueOf 和 toString 都不存在，或者没有返回基本类型，则会产生类型错误 TypeError。</li></ul></li></ul><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><ol><li>JS 对象的特征</li></ol><ul><li>唯一标识性</li><li>对象有状态</li><li>具有行为</li></ul><p><strong>在 JavaScript 中，将状态和行为统一抽象为 属性</strong></p><ol start="2"><li>JS 对象的两类属性</li></ol><ul><li><p>数据属性</p><ul><li><p>value</p></li><li><p>writable</p><ul><li>决定是否被赋值</li></ul></li><li><p>enumerable</p><ul><li>决定  是否枚举该属性</li></ul></li><li><p>configurable</p><ul><li>决定该属性是否被删除或改变特征值</li></ul></li><li><p>Object.getOwnPropertyDescripter 来查看属性  特征值</p></li><li><p>可以使用 Object.defineProperty 来改变特征值</p></li></ul></li><li><p>访问器属性</p><ul><li>getter</li><li>setter</li><li>enumerable</li><li>configurable</li><li>访问器属性跟数据属性不同，每次访问属性都会执行 getter 或者 setter 函数</li></ul></li></ul><ol start="3"><li>函数对象和构造器对象</li></ol><ul><li><p>函数对象</p><ul><li>具有 call 私有字段</li></ul></li><li><p>构造器对象</p><ul><li>具有 construct 的对象</li></ul></li></ul><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p><strong>“基于原型”的编程看起来更为提倡程序员去关注一系列对象实例的行为，而后才去关心如何将这些对象，划分到最近的使用方式相似的原型对象，而不是将它们分成类</strong></p><h3 id="访问操作原型的方法"><a href="#访问操作原型的方法" class="headerlink" title="访问操作原型的方法"></a>访问操作原型的方法</h3><ul><li><p>Object.create</p><ul><li>根据指定原型创建对象</li></ul></li><li><p>Object.getPrototypeOf</p><ul><li>获得一个对象的原型</li></ul></li><li><p>Object.setPrototypeOf</p><ul><li>设置一个对象的原型</li></ul></li></ul><h2 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h2><h3 id="宏任务"><a href="#宏任务" class="headerlink" title="宏任务"></a>宏任务</h3><ul><li>宿主发起的</li></ul><h3 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h3><ul><li>JS 引擎发起的任务</li><li>微任务始终优先宏任务</li></ul><h3 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h3><ul><li>运行时基础是 Promise</li><li>async 函数必定返回 Promise</li></ul><h3 id="generator-iterator-并非异步代码"><a href="#generator-iterator-并非异步代码" class="headerlink" title="generator/iterator 并非异步代码"></a>generator/iterator 并非异步代码</h3><ul><li>只是在缺少 async/await 的时候，模拟 async/await</li></ul><h2 id="函数执行过程"><a href="#函数执行过程" class="headerlink" title="函数执行过程"></a>函数执行过程</h2><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><ul><li>闭包其实只是一个绑定了执行环境的函数</li><li>与普通函数的区别是 自带了执行环境</li></ul><h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><ul><li><p>var 的声明与赋值</p><ul><li>作用域是 函数</li></ul></li><li><p>let</p><ul><li>块级作用域</li></ul></li><li><p>Realm</p><ul><li>9.0 的标准</li><li>包含一组完整的内置对象，而且是复制关系</li><li>通过 iframe 等方式创建多 window 环境</li></ul></li><li><p>立即执行 的 函数表达式</p><ul><li>通过创建一个函数，并且立即执行，来构造一个新的域，从而控制 var 的范围</li></ul></li><li><p>with 关键字</p><ul><li>相当于构造了一个独立的执行环境</li><li>能够创建一个和外部环境同一个名字的变量</li></ul></li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h3><ul><li><p>执行上下文</p></li><li><p>普通函数的 this</p><ul><li>this 返回的并非函数本身，而是 当前函数的引用</li><li>调用函数的引用，决定了函数执行时的 this 值</li></ul></li><li><p>箭头函数的 this</p><ul><li>不论用什么引用来调用它，都不影响它的 this 值</li></ul></li><li><p>this 的模式</p><ul><li><p>thisMode 私有属性</p></li><li><p>lexical</p><ul><li>表示从上下文中找 this，这对应了箭头函数</li></ul></li><li><p>global</p><ul><li>当 this 为 undefined 时，取全局对象，对应了普通函数</li></ul></li><li><p>strict</p><ul><li>当严格模式时使用，this 严格按照调用时传入的值，可能为 null 或者 undefined</li></ul></li></ul></li></ul><h3 id="Bind-方法"><a href="#Bind-方法" class="headerlink" title="Bind 方法"></a>Bind 方法</h3><ul><li><p>允许我们在函数或者方法被调用时绑定 this 到指定对象上</p></li><li><p>明确指定方法中的 this 指向,并返回这个函数，方便后续调用</p></li><li><p>实现函数借用</p><ul><li><p>将一个对象上的函数 赋值 到另一个 对象上</p><ul><li>其中 另一个对象上 有 this 的引用</li></ul></li><li><p>借用函数的最佳实践应该是 使用 Apply 或者 Call 方法</p></li></ul></li><li><p>允许我们柯里化一个函数</p></li></ul><h3 id="Apply-和-Call-方法"><a href="#Apply-和-Call-方法" class="headerlink" title="Apply 和 Call 方法"></a>Apply 和 Call 方法</h3><ul><li><p>设置目标函数 this 的指向</p><ul><li><p>call</p><ul><li>第一个参数明确 this 指向，第二个参数传递给 目标函数</li></ul></li><li><p>apply 和 call 的用法几乎相同, 唯一的差别在于当函数需要传递多个变量时, apply 可以接受一个数组作为参数输入, call 则是接受一系列的单独变量</p></li></ul></li><li><p>使用 apply 或者 call 实现函数借用</p></li><li><p>立即调用这个函数而不是延迟调用</p></li><li><p>箭头函数下 apply 和 call 失效</p></li></ul><h3 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h3><ul><li>只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数</li><li>实例</li><li>lodash.curry(function)</li><li>柯里化 是一种转换，将 f(a,b,c) 转换为可以被以 f(a)(b)(c) 的形式进行调用。JavaScript 实现通常都保持该函数可以被正常调用，并且如果参数数量不足，则返回偏函数</li></ul><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p><strong>引用数据类型的拷贝</strong></p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li><p>Json.stringfy()</p><ul><li>数据量大的时候性能问题</li><li>遇到循环引用的对象会出错</li><li>一些类型无法拷贝</li></ul></li><li><p>Object.assign()</p><ul><li>只是在对象属性为基本数据类型时 深拷贝，对于引用数据类型 是浅拷贝</li></ul></li><li><p>递归的方式</p><ul><li>手写</li><li>循环引用的时候 栈溢出</li></ul></li><li><p>添加 map 做缓存的递归方法</p><ul><li>手写</li></ul></li></ul><h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><h3 id="var"><a href="#var" class="headerlink" title="var"></a>var</h3><ul><li>作用于脚本，模块和函数体</li></ul><h3 id="const-和-let"><a href="#const-和-let" class="headerlink" title="const 和 let"></a>const 和 let</h3><ul><li>如果当前作用域内有声明，就无法访问到外部的变量</li><li>如果当前作用域内有同名的变量，则无法访问外部同名的变量，</li></ul><h3 id="自执行函数"><a href="#自执行函数" class="headerlink" title="自执行函数"></a>自执行函数</h3><ul><li>构造新的作用域</li></ul><h3 id="function"><a href="#function" class="headerlink" title="function"></a>function</h3><ul><li><p>预处理在作用域中加入了变量，并且赋值</p></li><li><p>在作用域外，只增加了变量，没有赋值</p><ul><li>赋值行为发生在了执行阶段</li></ul></li><li><p>作用于脚本、模块和函数体级别</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 重学前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML</title>
      <link href="/94liucc/2021/06/14/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF/HTML/"/>
      <url>/94liucc/2021/06/14/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF/HTML/</url>
      
        <content type="html"><![CDATA[<h2 id="语义类标签"><a href="#语义类标签" class="headerlink" title="语义类标签"></a>语义类标签</h2><h3 id="作为自然语言延伸的标签"><a href="#作为自然语言延伸的标签" class="headerlink" title="作为自然语言延伸的标签"></a>作为自然语言延伸的标签</h3><ul><li><p><code>&lt;em /&gt;</code></p></li><li><p>作为自然语言和纯文本的补充，用来表达一定的结构或者消除歧义</p></li></ul><h3 id="作为标题摘要的语义类标签"><a href="#作为标题摘要的语义类标签" class="headerlink" title="作为标题摘要的语义类标签"></a>作为标题摘要的语义类标签</h3><ul><li><p>有些时候，我们会有副标题，为了避免副标题产生额外的一个层级</p></li><li><hgroup><ul><li>避免副标题产生额外的层级</li></ul></hgroup></li></ul><h3 id="作为整体结构的语义类标签"><a href="#作为整体结构的语义类标签" class="headerlink" title="作为整体结构的语义类标签"></a>作为整体结构的语义类标签</h3><ul><li><p><code>&lt;header/&gt;</code></p><ul><li>通常出现在前部，表示导航或者介绍性的内容</li></ul></li><li><p><code>&lt;footer/&gt;</code></p></li><li><p><code>&lt;body/&gt;</code></p></li><li><p><code>&lt;nav/&gt;</code></p><ul><li>导航标签</li></ul></li><li><p><code>&lt;aside/&gt;</code></p><ul><li><p>表示跟文章主体不那么相关的部分，它可能包含导航、广告等工具性质的内容</p></li><li><p>例如 侧边栏</p><ul><li>侧边栏是 aside，aside 不一定是侧边栏</li></ul></li></ul></li></ul><h2 id="元信息类标签"><a href="#元信息类标签" class="headerlink" title="元信息类标签"></a>元信息类标签</h2><h3 id="head"><a href="#head" class="headerlink" title="head"></a>head</h3><ul><li>内容必须包含一个 title，并且最多只能包含一个 base</li></ul><h3 id="title"><a href="#title" class="headerlink" title="title"></a>title</h3><h3 id="base"><a href="#base" class="headerlink" title="base"></a>base</h3><ul><li>给页面所有的 URL 相对地址提供一个基础</li><li>它改变全局的链接地址，它是一个非常危险的标签，容易造成跟 JavaScript 的配合问题</li><li>建议你使用 JavaScript 来代替 base 标签</li></ul><h3 id="meta"><a href="#meta" class="headerlink" title="meta"></a>meta</h3><ul><li><p>通用的元信息表示标签</p></li><li><p>由 name 和 content 两个属性定义</p></li><li><p>name 为 charset</p><ul><li>描述了 HTML 文档自身的编码形式</li></ul></li><li><p>name 为 http-equiv</p><ul><li><p>表示执行一个命令</p></li><li><p>content-type</p><ul><li>相当于添加了 content-type 这个 http 头，并且指定了 http 编码方式</li></ul></li><li><p>content-language</p><ul><li>指定内容的语言</li></ul></li><li><p>default-style</p><ul><li>指定默认样式表</li></ul></li><li><p>refresh</p><ul><li>刷新</li></ul></li></ul></li><li><p>name 为 viewport</p><ul><li>name 为 viewport , content 为用逗号分隔的键值对</li><li>移动端适配</li></ul></li></ul><h2 id="链接类标签"><a href="#链接类标签" class="headerlink" title="链接类标签"></a>链接类标签</h2><h3 id="link"><a href="#link" class="headerlink" title="link"></a>link</h3><ul><li><p>超链接类的 link 标签</p><ul><li>被动型链接，在用户不操作时，不会主动下载</li><li>rel 属性不同 作用不同</li></ul></li><li><p>存在于 head 里</p></li><li><p>仅仅是元信息，不会显示在网页中</p></li><li><p>外部资源类标签</p><ul><li>会被主动下载</li></ul></li></ul><h3 id="a"><a href="#a" class="headerlink" title="a"></a>a</h3><ul><li>不会主动下载</li><li>解决了页面中插入文字型和整张图片超链接的需要</li></ul><h3 id="area-标签"><a href="#area-标签" class="headerlink" title="area 标签"></a>area 标签</h3><ul><li>区域型连接</li><li>必须跟 img 和 map 标签配合使用</li></ul><h2 id="DOM-API"><a href="#DOM-API" class="headerlink" title="DOM API"></a>DOM API</h2><h3 id="Element"><a href="#Element" class="headerlink" title="Element"></a>Element</h3><ul><li>HTML Element</li><li>SVG Element</li></ul><h3 id="Document"><a href="#Document" class="headerlink" title="Document"></a>Document</h3><h3 id="CharacterData"><a href="#CharacterData" class="headerlink" title="CharacterData"></a>CharacterData</h3><ul><li>Text</li><li>Comment</li><li>ProcessingInstruction</li></ul><h3 id="DocumentFragment"><a href="#DocumentFragment" class="headerlink" title="DocumentFragment"></a>DocumentFragment</h3><ul><li>文档片段</li><li>常常被用来高性能的批量添加节点</li></ul><h3 id="DocumentType"><a href="#DocumentType" class="headerlink" title="DocumentType"></a>DocumentType</h3><ul><li>文档类型</li></ul><h2 id="attribute-和-property-区别"><a href="#attribute-和-property-区别" class="headerlink" title="attribute 和 property 区别"></a>attribute 和 property 区别</h2><ol><li><p>attribute 是 HTML 标签上的特性，它的值只能够是字符串</p></li><li><p>property 是指对象的属性，HTML 的节点可以看做一个对象</p></li><li><p>attribute - &gt;property</p></li></ol><ul><li>数据单向同步</li></ul>]]></content>
      
      
      <categories>
          
          <category> 重学前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS</title>
      <link href="/94liucc/2021/06/12/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF/CSS/"/>
      <url>/94liucc/2021/06/12/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF/CSS/</url>
      
        <content type="html"><![CDATA[<h2 id="规则"><a href="#规则" class="headerlink" title="@规则"></a>@规则</h2><h2 id="普通规则"><a href="#普通规则" class="headerlink" title="普通规则"></a>普通规则</h2><ol><li><p>选择器</p></li><li><p>声明区</p></li></ol><ul><li><p>属性</p></li><li><p>值</p><ul><li><p>双中线开头的属性被当做变量</p></li><li><p>值的函数</p><ul><li><p>calc()</p><ul><li>基本的表达式计算</li></ul></li><li><p>min()</p><ul><li>max()</li></ul></li><li><p>clamp()</p></li><li><p>toggle()</p><ul><li>在规则选中多于一个元素时生效，它会在几个值之间来回切换</li></ul></li><li><p>attr()</p><ul><li>允许 CSS 接受属性值的控制</li></ul></li></ul></li></ul></li></ul><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><ol><li><p>优先规则</p></li><li><p>伪元素</p></li></ol><ul><li><p>::first-line</p><ul><li>第一行的元素属性</li></ul></li><li><p>::first-letter</p></li><li><p>::before</p><ul><li>表示在元素之前插入一个虚拟元素</li></ul></li><li><p>::after</p><ul><li>表示在元素之后插入一个虚拟元素</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 重学前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WebApi</title>
      <link href="/94liucc/2021/06/01/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/WebApi/"/>
      <url>/94liucc/2021/06/01/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/WebApi/</url>
      
        <content type="html"><![CDATA[<h2 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a>setTimeout</h2><ol><li><p>在 Chrome 中除了正常使用的消息队列之外，还有另外一个消息队列，这个队列中维护了需要延迟执行的任务列表，包括了定时器和 Chromium 内部一些需要延迟执行的任务</p></li><li><p>延迟队列的执行时机</p></li></ol><ul><li>当处理完消息队列中的一个任务之后，执行 ProcessDelayTask 函数。ProcessDelayTask 函数会根据发起时间和延迟时间计算出到期的任务，然后依次执行这些到期的任务</li></ul><ol start="3"><li><p>循环嵌套 timeout 的情况 最小调用间隔 4ms</p></li><li><p>未激活的页面，setTimeout 执行最小间隔 1000ms</p></li><li><p>setTimout 中的 this 将指向全局</p></li></ol><ul><li><p>严格模式下为 undefined</p></li><li><p>解决方案</p><ul><li>使用 bind(this)</li><li>放在匿名函数中执行</li></ul></li></ul><h2 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</h2><h3 id="异步回调"><a href="#异步回调" class="headerlink" title="异步回调"></a>异步回调</h3><ul><li>由浏览器的其他进程或者线程去执行，然后再将执行结果利用 IPC 的方式通知渲染进程，之后渲染进程再将对应的消息添加到消息队列中</li></ul><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li>跨域问题</li><li>混合内容问题</li></ul><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><h3 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h3><ul><li>消灭嵌套调用</li><li>合并多个任务的错误处理</li><li>本质 解决回调地狱</li></ul><h3 id="手写代码"><a href="#手写代码" class="headerlink" title="手写代码"></a>手写代码</h3><h3 id="Promise-和-微任务"><a href="#Promise-和-微任务" class="headerlink" title="Promise 和 微任务"></a>Promise 和 微任务</h3><ul><li>由于采用了回调函数延迟绑定</li><li>所以在执行 resolve 函数的时候，回调函数还没有绑定，那么只能推迟回调函数的执行</li><li>Promise 之所以要使用微任务是由 Promise 回调函数延迟绑定技术导致的</li></ul><h2 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h2><h3 id="生成器函数"><a href="#生成器函数" class="headerlink" title="生成器函数"></a>生成器函数</h3><ul><li>生成器函数是一个带星号函数，而且是可以暂停执行和恢复执行的</li><li>在生成器函数内部执行一段代码，如果遇到 yield 关键字，那么 JavaScript 引擎将返回关键字后面的内容给外部，并暂停该函数的执行。<br>外部函数可以通过 next 方法恢复函数的执行。</li></ul><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><ul><li><p>可以把协程看成是跑在线程上的任务</p><ul><li>一个线程上可以存在多个协程，但是在线程上同时只能执行一个协程，比如当前执行的是 A 协程，要启动 B 协程，那么 A 协程就需要将主线程的控制权交给 B 协程，这就体现在 A 协程暂停执行，B 协程恢复执行</li></ul></li><li><p>注意</p><ul><li><p>协程和父协程之间交互执行，不是并发</p><ul><li>是通过 yield 和 gen.next 来配合完成的</li></ul></li><li><p>当在 gen 协程中调用了 yield 方法时，JavaScript 引擎会保存 gen 协程当前的调用栈信息，并恢复父协程的调用栈信息</p></li></ul></li></ul><h3 id="async-await-技术背后的秘密就是-Promise-和生成器应用"><a href="#async-await-技术背后的秘密就是-Promise-和生成器应用" class="headerlink" title="async/await 技术背后的秘密就是 Promise 和生成器应用"></a>async/await 技术背后的秘密就是 Promise 和生成器应用</h3><h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><ul><li>通过异步执行</li><li>并返回 Promise</li></ul><h3 id="await"><a href="#await" class="headerlink" title="await"></a>await</h3><ul><li><p>执行过程</p><ul><li>默认创建一个 Promise 对象</li><li>暂停当前协程的执行，将主线程的控制权转交给父协程执行</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 浏览器工作原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> Api </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP</title>
      <link href="/94liucc/2021/05/30/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/HTTP/"/>
      <url>/94liucc/2021/05/30/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/HTTP/</url>
      
        <content type="html"><![CDATA[<h2 id="HTTP-版本"><a href="#HTTP-版本" class="headerlink" title="HTTP 版本"></a>HTTP 版本</h2><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><ul><li><p>基于 TCP 协议，三次握手</p></li><li><p>get 请求文件</p></li><li><p>请求头</p><ul><li><p>文件类型</p></li><li><p>期望压缩方式</p></li><li><p>期望文件编码</p></li><li><p>期望页面语言</p></li><li><p>客户端基础信息</p><ul><li>用户代理字段</li></ul></li></ul></li><li><p>响应头</p><ul><li>压缩类型，文件编码</li></ul></li><li><p>响应头</p></li><li><p>四次挥手断开连接</p></li></ul><h3 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP 1.1"></a>HTTP 1.1</h3><ul><li><p>增加了持久连接的方法</p><ul><li>一个 TCP 连接可以传输多个 HTTP 请求，只要浏览器或者服务器没有明确断开连接，TCP 会一直保持</li><li>对于同一个域名，默认允许同时建立 6 个 TCP 的持久连接</li></ul></li><li><p>带宽利用率不理想</p><ul><li><p>原因</p><ul><li><p>TCP 的慢启动</p><ul><li>刚开始 TCP 协议会采用一个非常慢的速度去发送数据，然后慢慢加快发送数据的速度，直到发送数据的速度达到一个理想状态，我们把这个过程称为慢启动</li></ul></li><li><p>同时开启多个 TCP 连接</p></li><li><p>队头阻塞问题</p><ul><li>公用一个 TCP 管道时，在一个管道中同一时刻只能处理一个请求，当前请求没有结束之前，其他请求处于阻塞状态</li></ul></li></ul></li></ul></li></ul><h3 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h3><ul><li><p>一个域名只使用一个 TCP 长连接</p></li><li><p>解决队头阻塞问题</p><ul><li><p>多路复用机制</p><ul><li>可以将请求分成一帧一帧的数据去传输</li><li>当收到一个优先级高的请求时，服务器可以暂停之前的请求来优先处理关键资源的请求</li></ul></li><li><p>通过引入 二进制分帧层 实现了多路复用技术</p><ul><li>浏览器请求数据通过二进制分帧层处理后，转换为一个个带有 ID 的帧，发送给服务器</li><li>服务器接收所有帧之后，合并为一条信息，发送回二进制分帧层</li><li>二进制分帧层接收数据之后，合并成完整的响应体</li></ul></li><li><p>如果在 TCP 传输过程中，由于单个数据包的丢失从而造成阻塞</p><ul><li>如果是 HTTP1.1,其他的 5 个连接依然可以继续传输数据</li><li>随着丢包率的增加，HTTP2 的传输效率会越来越差，传输效率可能比 HTTP1.1 要差</li></ul></li></ul></li><li><p>其他特性</p><ul><li><p>设置请求的优先级</p></li><li><p>服务器推送</p><ul><li>比如服务器会在收到 HTML 请求后，推送附带的 JS CSS 文件</li></ul></li><li><p>头部压缩</p><ul><li>请求头压缩</li></ul></li></ul></li></ul><h2 id="安全策略"><a href="#安全策略" class="headerlink" title="安全策略"></a>安全策略</h2><h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><ul><li><p>同源策略</p><ul><li><p>协议，域名，端口，三者相等</p></li><li><p>DOM 层面</p><ul><li>同源策略限制来自不同源的 JS 脚本对当前 DOM 对象读写</li></ul></li><li><p>数据层面</p></li><li><p>网络层面</p></li></ul></li><li><p>CSP</p><ul><li>为了解决 XSS 攻击，浏览器引入了内容安全策略</li><li>核心思想是 让服务器决定浏览器能够加载哪些资源，让服务器决定浏览器是否能够执行内联 JS 代码</li></ul></li><li><p>CORS</p><ul><li><p>跨域资源共享</p></li><li><p>跨文档消息机制</p><ul><li>window.postMessage</li></ul></li></ul></li></ul><h3 id="XSS-跨站脚本攻击"><a href="#XSS-跨站脚本攻击" class="headerlink" title="XSS 跨站脚本攻击"></a>XSS 跨站脚本攻击</h3><ul><li><p>方式</p><ul><li><p>存储型</p><ul><li>将恶意代码存储到存在漏洞的服务器</li></ul></li><li><p>反射型</p><ul><li>恶意 JavaScript 脚本属于用户发送给网站请求中的一部分，随后网站又把恶意 JavaScript 脚本返回给用户</li></ul></li><li><p>基于 DOM 的 XSS 攻击</p><ul><li>在 Web 资源传输过程中修改 Web 页面的数据</li></ul></li></ul></li><li><p>处理策略</p><ul><li><p>对输入的脚本进行过滤</p></li><li><p>对输入的脚本转码</p></li><li><p>充分利用 CSP</p><ul><li>限制加载其他域下的资源文件</li><li>禁止向第三方域提交数据</li></ul></li><li><p>使用 HttpOnly 来保护 Cookie 数据</p><ul><li>防止 Cookie 数据被 JS 读取出来</li></ul></li></ul></li></ul><h3 id="CSRF-攻击"><a href="#CSRF-攻击" class="headerlink" title="CSRF 攻击"></a>CSRF 攻击</h3><ul><li><p>跨站请求伪造</p><ul><li><p>在黑客的网站中，利用用户的登录状态发起的跨站请求</p><ul><li>利用服务器的漏洞和用户的登录状态实施攻击</li></ul></li></ul></li><li><p>防止攻击</p><ul><li>充分利用好 Cookie 的 SameSite 属性</li><li>验证请求的站点</li><li>携带 CSRF Token</li></ul></li></ul><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><h3 id="HTTPS-就是-TCP-先和安全层通信，然后安全层再和-TCP-通信"><a href="#HTTPS-就是-TCP-先和安全层通信，然后安全层再和-TCP-通信" class="headerlink" title="HTTPS 就是 TCP 先和安全层通信，然后安全层再和 TCP 通信"></a>HTTPS 就是 TCP 先和安全层通信，然后安全层再和 TCP 通信</h3><ul><li>SSL/TLS</li></ul><h3 id="安全层的职责"><a href="#安全层的职责" class="headerlink" title="安全层的职责"></a>安全层的职责</h3><ul><li>对发起 HTTP 请求的数据进行加密</li><li>解密操作</li></ul><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><ul><li>加密和解密都使用相同的密钥</li><li>传输密钥过程中可能被截取</li></ul><h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><ul><li><p>浏览器向服务器请求公钥和加密套件，之后浏览器使用公钥加密数据向服务器发送</p><ul><li>私钥加密只能公钥解密</li><li>公钥加密只能私钥解密</li></ul></li><li><p>问题</p><ul><li>效率太低</li><li>无法保证服务器发送给浏览器的数据安全</li></ul></li></ul><h3 id="折中方案"><a href="#折中方案" class="headerlink" title="折中方案"></a>折中方案</h3><ul><li>对称加密的密钥使用 非对称加密传输，数据传输阶段还是对称加密</li></ul><h3 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h3><ul><li><p>作用</p><ul><li>向浏览器证明服务器的身份</li><li>数字证书里包含了服务器的公钥</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 浏览器工作原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chrome浏览器</title>
      <link href="/94liucc/2021/05/28/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/Chrome%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
      <url>/94liucc/2021/05/28/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/Chrome%E6%B5%8F%E8%A7%88%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="chrome-浏览器-四个进程"><a href="#chrome-浏览器-四个进程" class="headerlink" title="chrome 浏览器 四个进程"></a>chrome 浏览器 四个进程</h3><ul><li>浏览器进程</li><li>渲染进程</li><li>GPU 进程</li><li>网络进程</li><li>插件进程</li></ul><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="连接过程"><a href="#连接过程" class="headerlink" title="连接过程"></a>连接过程</h3><ul><li>三次握手四次挥手</li></ul><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="请求流程"><a href="#请求流程" class="headerlink" title="请求流程"></a>请求流程</h3><ul><li><p>构建请求</p></li><li><p>查找缓存</p></li><li><p>准备 ip 地址和端口</p><ul><li>HTTP 内容通过 TCP 传输数据实现</li></ul></li><li><p>等待 TCP 队列</p><ul><li>同一个域名同时最多只能建立 6 个 TCP 链接</li></ul></li><li><p>建立 TCP 连接</p></li><li><p>发送 HTTP 请求</p></li></ul><h3 id="服务端处理-HTTP-请求"><a href="#服务端处理-HTTP-请求" class="headerlink" title="服务端处理 HTTP 请求"></a>服务端处理 HTTP 请求</h3><ul><li><p>返回请求</p></li><li><p>断开连接</p><ul><li>如果在头信息中加入 Connection:keep-alive</li><li>则会保持 TCP 连接</li></ul></li><li><p>重定向</p></li></ul><h3 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h3><ul><li><p>DNS 缓存</p></li><li><p>页面资源缓存</p><ul><li><p>浏览器通过响应头中的 Cache-Control 字段来设置是否缓存该资源</p></li><li><p>Cache-Control:Max-age=2000</p><ul><li>2000 秒后过期</li></ul></li><li><p>过期之后重新请求数据</p><ul><li>如果没有更改 返回 304 没有更新</li></ul></li></ul></li><li><p>使用 Cookie 保持登录状态</p><ul><li>服务端将用户信息写到响应头的 Set-Cookie 字段里</li><li>浏览器接收到响应头后，将 Cookie 字段存在本地</li><li>再次访问时将信息放到 Cookie 字段 发送给服务器</li><li>服务器返回登录的状态的信息</li></ul></li></ul><h2 id="导航流程"><a href="#导航流程" class="headerlink" title="导航流程"></a>导航流程</h2><h3 id="大致"><a href="#大致" class="headerlink" title="大致"></a>大致</h3><ul><li><p>用户从浏览器进程中输入请求信息</p></li><li><p>URL 请求</p><ul><li><p>查找缓存</p></li><li><p>DNS 解析</p></li><li><p>建立 TCP 连接</p></li><li><p>向服务器发送构建好的请求信息</p></li><li><p>处理响应数据</p><ul><li><p>301，302 重定向</p></li><li><p>响应数据类型处理</p><ul><li><p>Content-Type</p><ul><li>告诉浏览器返回的响应体的类型</li><li>html</li><li>octet-stream</li></ul></li></ul></li></ul></li></ul></li><li><p>准备渲染进程</p><ul><li><p>一般情况下，每个页面分配一个渲染进程</p></li><li><p>如果从 A 页面打开 B 页面，且 A 和 B 都属于同一站点的话，那么新页面会复用父页面的渲染进程</p><ul><li>相同的协议和根域名</li></ul></li></ul></li><li><p>渲染阶段</p></li></ul><h2 id="渲染流程"><a href="#渲染流程" class="headerlink" title="渲染流程"></a>渲染流程</h2><h3 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h3><ul><li>构建 DOM 树</li><li>样式计算</li><li>布局</li><li>分层</li><li>绘制</li><li>分块</li><li>光栅化</li><li>合成</li></ul><h3 id="样式计算"><a href="#样式计算" class="headerlink" title="样式计算"></a>样式计算</h3><ul><li><p>转换</p><ul><li><p>来源</p><ul><li>link 引用的 css 文件</li><li>style 标记内的 css</li><li>元素 style 属性内的 css</li></ul></li><li><p>转换为 styleSheets</p></li></ul></li><li><p>对属性值进行标准化</p><ul><li>如 blue -&gt; rgb(0,0,255)</li></ul></li><li><p>确定每个元素的样式</p><ul><li><p>样式继承</p><ul><li>每个 DOM 节点都包含有父节点的样式</li></ul></li><li><p>样式层叠</p><ul><li>对多个来源的样式的 优先级算法</li></ul></li></ul></li></ul><h3 id="布局阶段"><a href="#布局阶段" class="headerlink" title="布局阶段"></a>布局阶段</h3><ul><li>创建布局树</li><li>布局计算</li></ul><h3 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h3><ul><li>为特定节点生成专用的图层<ul><li>LayerTree</li></ul></li><li>单独的图层条件<ul><li>具有层叠上下文</li><li>需要被剪裁</li></ul></li></ul><h3 id="图层绘制"><a href="#图层绘制" class="headerlink" title="图层绘制"></a>图层绘制</h3><ul><li>绘制列表只是用来记录绘制顺序和绘制指令的列表</li></ul><h3 id="栅格化"><a href="#栅格化" class="headerlink" title="栅格化"></a>栅格化</h3><ul><li>将图块转换为位图</li></ul><h3 id="合成和显示"><a href="#合成和显示" class="headerlink" title="合成和显示"></a>合成和显示</h3><h2 id="单个文件请求时间线"><a href="#单个文件请求时间线" class="headerlink" title="单个文件请求时间线"></a>单个文件请求时间线</h2><h3 id="Queuing-排队等待"><a href="#Queuing-排队等待" class="headerlink" title="Queuing 排队等待"></a>Queuing 排队等待</h3><ul><li><p>原因</p><ul><li>资源优先级低，比如图片，视频，音频等</li><li>浏览器为每个域名最多维护 6 个 TCP 链接</li><li>等待磁盘分配空间</li></ul></li><li><p>解决</p><ul><li><p>使用一个站点资源放到多个域名下</p></li><li><p>域名分片</p></li></ul></li></ul><h3 id="发起连接"><a href="#发起连接" class="headerlink" title="发起连接"></a>发起连接</h3><h3 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h3><h3 id="TTFB"><a href="#TTFB" class="headerlink" title="TTFB"></a>TTFB</h3><ul><li>第一字节时间</li><li>反映服务端响应速度的重要指标</li></ul><h2 id="DOM-树的生成"><a href="#DOM-树的生成" class="headerlink" title="DOM 树的生成"></a>DOM 树的生成</h2><ol><li><p>DOM 是表述 HTML 的内部数据结构，将 web 页面和 JS 脚本连接起来</p></li><li><p>HTML 字节流转换为 DOM</p></li></ol><ul><li>通过分词器将字节流转换为 Token</li><li>再把 token 解析成 DOM 节点</li></ul><ol start="3"><li>JS 影响 DOM 生成</li></ol><ul><li><p>解析器遇到 JS 脚本，会暂停 DOM 解析</p><ul><li>因为 JS 脚本可能会修改 DOM 结构</li></ul></li><li><p>如果遇到需要下载的 JS 文件</p><ul><li><p>阻塞 DOM 解析</p></li><li><p>Chrome 预解析</p></li><li><p>如果文件中没有改变 DOM 代码</p><ul><li>async</li><li>script 标签内的 async 标记</li><li>defer</li></ul></li></ul></li></ul><ol start="4"><li>我们知道了 JavaScript 会阻塞 DOM 生成，而 CSS 文件又会阻塞 JavaScript 的执行</li></ol><h2 id="分层和合成"><a href="#分层和合成" class="headerlink" title="分层和合成"></a>分层和合成</h2><ol><li><p>提升渲染效率</p></li><li><p>分层是在生成布局树之后，渲染引擎会根据布局树的特点生成 layer tree</p></li><li><p>分块会优先绘制靠近视口的图块</p></li></ol><ul><li>在首次合成图块的时候使用一个低分辨率的图片，当正常比例的网页内容绘制完成之后，再替换掉当前显示的低分辨率内容</li></ul><ol start="4"><li><p>合成操作是在合成线程上完成的，这也就意味着在执行合成操作时，是不会影响到主线程执行的</p></li><li><p>CSS 动画比 JS 动画更加高效</p></li></ol><ul><li>CSS 动画运行在合成线程，没有涉及主线程，大大提升了渲染效率</li></ul><h2 id="系统的优化界面"><a href="#系统的优化界面" class="headerlink" title="系统的优化界面"></a>系统的优化界面</h2><h3 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h3><ul><li><p>能阻塞网页首次渲染的资源称为关键资源</p></li><li><p>影响首次加载的核心因素</p><ul><li><p>关键资源个数</p></li><li><p>关键资源大小</p></li><li><p>请求关键资源需要多少个 RTT</p><ul><li><p>RTT</p><ul><li>表示从发送端发送数据开始，到发送端收到来自接收端的确认所经历的时间</li><li>通常一个 HTTP 数据包在 14kb 左右，0.1M 的页面需要 8 个 RTT</li></ul></li></ul></li></ul></li><li><p>总的优化规则是 减少关键资源个数，降低关键资源大小，降低关键资源的 RTT 次数</p></li></ul><h3 id="交互阶段"><a href="#交互阶段" class="headerlink" title="交互阶段"></a>交互阶段</h3><ul><li><p>单个帧的生成速度更快</p></li><li><p>优化</p><ul><li>减少 JS 脚本执行时间</li><li>尽量使用 css 动画</li><li>避免强制同步布局</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 浏览器工作原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器代码执行</title>
      <link href="/94liucc/2021/05/26/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/"/>
      <url>/94liucc/2021/05/26/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="执行机制"><a href="#执行机制" class="headerlink" title="执行机制"></a>执行机制</h2><ol><li><p>先编译再执行</p></li><li><p>先做变量提升</p></li><li><p>编译阶段 变量的值会被设置为 undefined</p></li><li><p>如果在编译阶段，存在两个相同的函数, 后面的函数覆盖掉前面的函数</p></li></ol><h2 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h2><ol><li><p>管理函数调用关系的数据结构</p></li><li><p>函数执行过程</p></li></ol><ul><li>从全局执行上下文中，取出函数代码</li><li>对函数代码进行编译，并创建该函数的执行上下文和可执行代码</li><li>执行代码</li></ul><ol start="3"><li>调用栈</li></ol><ul><li>在执行上下文创建好后，JS 引擎会将执行上下文压入栈中</li><li>函数执行完之后，将该函数的执行上下文出栈</li></ul><h2 id="作用域链和闭包"><a href="#作用域链和闭包" class="headerlink" title="作用域链和闭包"></a>作用域链和闭包</h2><ol><li>词法作用域是指作用域是由函数声明的代码位置决定的</li></ol><ul><li>词法作用域是代码阶段就决定好的，和函数是怎么调用的没有关系。</li></ul><ol start="2"><li>闭包</li></ol><ul><li>内部函数总是可以访问其外部函数中声明的变量</li></ul><h2 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h2><ol><li>全局执行中的 this</li></ol><ul><li>指向 window 对象</li></ul><ol start="2"><li>函数执行上下文中的 this</li></ol><ul><li>默认打印出来的是 window 对象</li><li>通过 call,bind,apply 更改 this 的指向</li><li>通过一个对象调用内部方法，该方法中的 this 指向对象本身</li><li>通过 new 创建的对象，指向的就是新创建的对象本身</li></ul><ol start="3"><li>通过箭头函数创建的对象的 this 指向父对象</li></ol><h2 id="堆空间和栈空间"><a href="#堆空间和栈空间" class="headerlink" title="堆空间和栈空间"></a>堆空间和栈空间</h2><ol><li>原始类型的数据保存在 栈 中，引用类型的值存放在 堆 中</li></ol><ul><li>对象类型是存放在堆空间的，在栈空间中只是保留了对象的引用地址，当 JavaScript 需要访问该数据的时候，是通过栈中的引用地址来访问的</li></ul><ol start="2"><li>栈空间</li></ol><ul><li>用来维护程序执行期间上下文的状态</li></ul><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ol><li>原始数据类型</li></ol><ul><li>Boolean</li><li>Null</li><li>Undefined</li><li>String</li><li>Number</li><li>Bigint</li><li>symbol</li></ul><ol start="2"><li>引用数据类型</li></ol><ul><li>Object</li></ul><h2 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h2><ol><li>栈中的数据</li></ol><ul><li>通过下移记录当前执行状态的指针（称为 ESP），来销毁该函数保存在栈中的执行上下文</li></ul><ol start="2"><li>堆中的数据</li></ol><ul><li><p>垃圾回收机制</p><ul><li>标记清除算法</li></ul></li></ul><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><ol><li>Chrome 里面的线程是通过消息队列来传递处理消息</li></ol><ul><li>先进先出</li></ul><ol start="2"><li>宏任务和微任务</li></ol><ul><li>每个宏任务都包含一个微任务队列</li><li>宏任务执行完之后，就会执行相应微任务</li></ul><h2 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h2><ol><li><p>微任务是一个需要异步执行的函数</p></li><li><p>微任务</p></li></ol><ul><li><p>执行时机</p><ul><li>主函数执行结束之后、当前宏任务结束之前</li></ul></li></ul><ol start="3"><li>宏任务</li></ol><ul><li>消息队列中的任务</li></ul>]]></content>
      
      
      <categories>
          
          <category> 浏览器工作原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dart</title>
      <link href="/94liucc/2020/11/30/Dart/Dart/"/>
      <url>/94liucc/2020/11/30/Dart/Dart/</url>
      
        <content type="html"><![CDATA[<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><ol><li>final</li></ol><ul><li>一开始不赋值，只能赋值一次</li></ul><ol start="2"><li>const</li></ol><ul><li>不能赋值为方法</li></ul><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ol><li>var</li></ol><ul><li>赋值后 变量的类型无法改变</li></ul><ol start="2"><li>object 与 dynamic</li></ol><ul><li><p>赋值后变量类型可以改变</p></li><li><p>不同</p><ul><li><p>dynamic 声明的变量可以使用提供的所有方法</p></li><li><p>object 声明的变量只能使用 object 包含的方法</p></li><li><p>比如 object a = “1234”</p><ul><li>a.length 报错</li></ul></li></ul></li></ul><h2 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h2><p><strong>Dart 在单线程中是以消息循环机制来运行的</strong></p><ol><li>microtask queue</li></ol><ul><li>通常来源于 Dart 内部，并且微任务非常少</li><li>我们可以通过 Future.microtask(…)方法向微任务队列插入一个任务。</li></ul><ol start="2"><li>event queue</li></ol><ul><li>所有的外部事件任务都在事件队列中，如 IO、计时器、点击、以及绘制事件等</li></ul><ol start="3"><li>微任务队列的执行优先级高于事件队列</li></ol><p><strong>入口函数 main() 执行完后，消息循环机制便启动了。首先会按照先进先出的顺序逐个执行微任务队列中的任务，事件任务执行完毕后程序便会退出，但是，在事件任务执行的过程中也可以插入新的微任务和事件任务，在这种情况下，整个线程的执行过程便是一直在循环，不会退出</strong></p><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><ol><li>b??=23</li></ol><ul><li>如果 b 为空的话 赋值为 23</li></ul><ol start="2"><li>var b = a??10</li></ol><ul><li>如果 a 为空，赋值 10，不为空，赋值 a</li></ul><ol start="3"><li>var b = a++</li></ol><ul><li>++在后面，先赋值在自增</li><li>结果 b=a ; a = a+1</li></ul><h2 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h2><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><ul><li><p>indexOf</p></li><li><p>fillRange</p><ul><li>修改指定 index 的数据</li></ul></li><li><p>join</p><ul><li>List 转化为字符串类型</li></ul></li><li><p>where</p><ul><li>返回符合条件的数组元素</li></ul></li><li><p>any</p><ul><li>只要集合里面有一个满足条件就返回 True,否则为 False</li></ul></li><li><p>every</p><ul><li>集合里面每一个都满足条件就返回 True</li></ul></li></ul><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><ul><li><p>无序且不重复</p></li><li><p>toList</p><ul><li>转换为数组</li></ul></li></ul><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h3><ul><li>print([int age])</li></ul><h3 id="自执行方法"><a href="#自执行方法" class="headerlink" title="自执行方法"></a>自执行方法</h3><ul><li>((){})()</li></ul><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><ul><li><p>函数嵌套函数，并且返回这个函数</p></li><li><p>常驻内存，但是不污染全局环境</p></li><li><p>举例</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fn(){</span><br><span class="line">    <span class="type">var</span> <span class="variable">a</span> <span class="operator">=</span><span class="number">123</span>;</span><br><span class="line">    <span class="keyword">return</span> (){</span><br><span class="line">a++;</span><br><span class="line">        print(a);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="私有属性"><a href="#私有属性" class="headerlink" title="私有属性"></a>私有属性</h3><ul><li>属性名字加 _</li></ul><h3 id="get-set-方法"><a href="#get-set-方法" class="headerlink" title="get set 方法"></a>get set 方法</h3><ul><li>通过访问属性的方式去调用</li></ul><h3 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h3><ul><li>使用 static 关键字来指定</li><li>访问静态成员 不需要实例化类</li><li>静态方法不能访问非静态成员，非静态方法可以访问静态成员</li></ul><h3 id="级联操作符"><a href="#级联操作符" class="headerlink" title="级联操作符"></a>级联操作符</h3><ul><li><p>..</p></li><li><p>示例</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a..name= <span class="string">'aaa'</span></span><br><span class="line">  ..age = <span class="number">30</span>;</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><ul><li>抽象类不能被实例化 只能被继承</li><li>抽象方法 不用 abstract , 只是没有方法体</li><li>抽象类里面可以有非抽象方法</li><li>子类继承抽象类 必须实现里面的抽象方法</li><li>子类实现抽象类 必须实现里面的所有属性和方法</li></ul><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ul><li>implements 关键字</li></ul><h3 id="Mixins"><a href="#Mixins" class="headerlink" title="Mixins"></a>Mixins</h3><ul><li>可以实现类似多继承的功能</li><li>不是继承和接口</li><li>Mixins 只能继承 object，不能继承其他类</li><li>被继承的类不能有构造方法</li><li>如果多个类里面有相同名字的方法，则后写的继承类的方法 重写前面的方法</li><li>with 关键字</li></ul><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul><li>子类自动获取父类的成员变量和方法实现</li></ul><h3 id="接口实现"><a href="#接口实现" class="headerlink" title="接口实现"></a>接口实现</h3><ul><li>子类获取接口的成员变量符号和方法符号，必须重新实现成员变量</li></ul><h3 id="with-关键字"><a href="#with-关键字" class="headerlink" title="with 关键字"></a>with 关键字</h3><ul><li>一个类里可以以非继承的方式使用其他类中的变量与方法</li></ul><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><ul><li><p>类型校验</p></li><li><p>规范数据类型</p></li><li><p>T 表示</p></li></ul><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ol><li><p>?. 运算符：假设 Point 类有 printInfo() 方法，p 是 Point 的一个可能为 null 的实例。那么，p 调用成员方法的安全代码，可以简化为 p?.printInfo() ，表示 p 为 null 的时候跳过，避免抛出异常</p></li><li><p>??= 运算符：如果 a 为 null，则给 a 赋值 value，否则跳过。这种用默认值兜底的赋值语句在 Dart 中我们可以用 a ??= value 表示。</p></li><li><p>?? 运算符：如果 a 不为 null，返回 a 的值，否则返回 b。在 Java 或者 C++ 中，我们需要通过三元表达式 (a != null)? a : b 来实现这种情况。而在 Dart 中，这类代码可以简化为 a ?? b。</p></li></ol><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="同步异常"><a href="#同步异常" class="headerlink" title="同步异常"></a>同步异常</h3><ul><li>try/catch</li></ul><h3 id="异步异常"><a href="#异步异常" class="headerlink" title="异步异常"></a>异步异常</h3><ul><li><p>runZoned</p><ul><li>onError</li></ul></li></ul><h2 id="factory-关键字"><a href="#factory-关键字" class="headerlink" title="factory 关键字"></a>factory 关键字</h2><p><strong>控制在使用构造函数时，并不总是创建一个新的该类的对象，比如它可能会从缓存中返回一个已有的实例，或者是返回子类的实例</strong></p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>避免创建过多的重复实例</li><li>调用子类的构造方法（工厂模式）</li><li>单例模式</li></ul><h2 id="编译模式"><a href="#编译模式" class="headerlink" title="编译模式"></a>编译模式</h2><h3 id="Script"><a href="#Script" class="headerlink" title="Script"></a>Script</h3><ul><li>jit 模式</li></ul><h3 id="Script-Snapshot"><a href="#Script-Snapshot" class="headerlink" title="Script Snapshot"></a>Script Snapshot</h3><ul><li>jit 模式</li></ul><h3 id="Application-Snapshot"><a href="#Application-Snapshot" class="headerlink" title="Application Snapshot"></a>Application Snapshot</h3><ul><li>jit 模式</li><li>这种模式来源于 dart vm 直接载入源码后 dump 出数据。dart vm 通过这种数据启动会更快。不过这种模式是区分架构的，在 X64 下生成的无法给 IA_32 用</li></ul><h3 id="AOT"><a href="#AOT" class="headerlink" title="AOT"></a>AOT</h3>]]></content>
      
      
      <categories>
          
          <category> Dart </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dart </tag>
            
            <tag> 语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter 优化</title>
      <link href="/94liucc/2020/09/18/Flutter/Flutter%20%E4%BC%98%E5%8C%96%20/"/>
      <url>/94liucc/2020/09/18/Flutter/Flutter%20%E4%BC%98%E5%8C%96%20/</url>
      
        <content type="html"><![CDATA[<h2 id="减少页面渲染次数"><a href="#减少页面渲染次数" class="headerlink" title="减少页面渲染次数"></a>减少页面渲染次数</h2><h2 id="使用-RepaintBoundary"><a href="#使用-RepaintBoundary" class="headerlink" title="使用 RepaintBoundary"></a>使用 RepaintBoundary</h2><ul><li>对应子树的 paint 不会导致外部的 repaint</li></ul><h2 id="GPU-优化"><a href="#GPU-优化" class="headerlink" title="GPU 优化"></a>GPU 优化</h2><ul><li><p>减少 saveOverlay</p><ul><li>会在 GPU 中分配一块新的绘图缓冲区（离屏渲染），切换绘图目标，</li><li>主要在离屏的地方会调用</li></ul></li><li><p>减少 clipPath</p><ul><li>会影响接下来每一个绘图指令。尤其这个 Path 比较复杂的时候都需要和这个复杂的 Path 做相交操作，而且把 Path 之外的部分剔除掉</li></ul></li></ul><h2 id="加载策略"><a href="#加载策略" class="headerlink" title="加载策略"></a>加载策略</h2><ul><li><p>按需加载</p></li><li><p>错峰加载</p></li></ul><h2 id="耗时计算"><a href="#耗时计算" class="headerlink" title="耗时计算"></a>耗时计算</h2><ul><li><p>Isolate</p><ul><li>不要乱用</li></ul></li></ul><h2 id="耗电优化"><a href="#耗电优化" class="headerlink" title="耗电优化"></a>耗电优化</h2><ul><li><p>cpu 计算耗电</p></li><li><p>网络耗电</p><ul><li>移动数据比 wifi 更费电</li></ul></li><li><p>避免后台长时间获取 WakeLock、WIFI 和蓝牙的扫描</p></li><li><p>定位相关</p></li><li><p>使用低精度的定位</p></li><li><p>使用后关闭</p></li></ul><h3 id="界面相关"><a href="#界面相关" class="headerlink" title="界面相关"></a>界面相关</h3><ul><li>离开界面后停止相关活动，例如关闭动画。</li><li>耗电操作判断前后台，如果是后台则不执行相关操作</li></ul>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> 跨平台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter组件</title>
      <link href="/94liucc/2020/09/16/Flutter/Flutter%E7%BB%84%E4%BB%B6/"/>
      <url>/94liucc/2020/09/16/Flutter/Flutter%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="RichText"><a href="#RichText" class="headerlink" title="RichText"></a>RichText</h2><ul><li><p>行内多样式文本</p></li><li><p>子 Widget</p><ul><li>TextSpan</li></ul></li></ul><h2 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h2><h3 id="属性-decoration"><a href="#属性-decoration" class="headerlink" title="属性 decoration"></a>属性 decoration</h3><ul><li>BoxDecoration</li><li>增加边框</li><li>增加圆角</li><li>增加阴影</li><li>增加渐变</li></ul><h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><ol><li><p>层叠布局</p></li><li><p>子 widget</p></li></ol><ul><li><p>Positioned</p><ul><li>left,right,top,bottom 属性</li><li>定位组件</li></ul></li></ul><h2 id="对齐与相对位置"><a href="#对齐与相对位置" class="headerlink" title="对齐与相对位置"></a>对齐与相对位置</h2><h3 id="Align"><a href="#Align" class="headerlink" title="Align"></a>Align</h3><ul><li><p>Alignment</p><ul><li>指定子组件相对位置，原始位置在组件中心点</li></ul></li><li><p>FractionalOffset</p><ul><li>指定相对位置，原始位置在组件的左上角</li></ul></li><li><p>只能有一个元素，不可堆叠</p></li></ul><h2 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h2><h3 id="Transform"><a href="#Transform" class="headerlink" title="Transform"></a>Transform</h3><ul><li><p>在子组件绘制时，通过矩阵，对其进行变换</p></li><li><p>注意</p><ul><li>Transform 的变换是发生在 绘制阶段，而不是布局阶段</li><li>所以 组件占用的位置空间已经确定，只是绘制时进行放大等变换</li></ul></li></ul><h3 id="RotatedBox"><a href="#RotatedBox" class="headerlink" title="RotatedBox"></a>RotatedBox</h3><ul><li>对子组件进行旋转等 操作</li><li>不同的是 变换发生在布局阶段，而不是绘制阶段</li></ul><h2 id="SizedBox"><a href="#SizedBox" class="headerlink" title="SizedBox"></a>SizedBox</h2><ul><li>固定尺寸布局</li></ul><h2 id="AspectRatio"><a href="#AspectRatio" class="headerlink" title="AspectRatio"></a>AspectRatio</h2><ul><li>设置  宽高比例的布局</li></ul><h2 id="CustomScrollView"><a href="#CustomScrollView" class="headerlink" title="CustomScrollView"></a>CustomScrollView</h2><ul><li><p>可以控制布局内的组件同步滚动</p></li><li><p>属性 sliver</p><ul><li>Widget 组</li><li>sliverAppBar</li><li>sliverList</li><li>sliverPadding</li><li>sliverGrid</li></ul></li></ul><h2 id="Form"><a href="#Form" class="headerlink" title="Form"></a>Form</h2><h3 id="表单组件"><a href="#表单组件" class="headerlink" title="表单组件"></a>表单组件</h3><h3 id="子-widget"><a href="#子-widget" class="headerlink" title="子 widget"></a>子 widget</h3><ul><li><p>TextFormFiled</p><ul><li><p>decoration</p><ul><li>InputDectoration</li></ul></li><li><p>obscureText</p><ul><li>密码格式</li></ul></li><li><p>validator</p><ul><li>验证值</li></ul></li><li><p>autovalidate</p><ul><li>自动验证</li></ul></li></ul></li></ul><h2 id="SnackBar"><a href="#SnackBar" class="headerlink" title="SnackBar"></a>SnackBar</h2><ul><li>Scaffold.of(context).showSnackBar</li></ul><h2 id="对话框"><a href="#对话框" class="headerlink" title="对话框"></a>对话框</h2><ul><li><p>SimpleDialog</p></li><li><p>AlertDialog</p></li><li><p>BottomSheet</p></li><li><p>底部滑动窗口</p></li><li><p>ExpansionPanel</p></li><li><p>下拉窗口</p></li></ul><h2 id="小标签"><a href="#小标签" class="headerlink" title="小标签"></a>小标签</h2><h3 id="Chip"><a href="#Chip" class="headerlink" title="Chip"></a>Chip</h3><ul><li><p>ActionChip</p></li><li><p>FilterChip</p><ul><li>点击后选定</li></ul></li><li><p>ChoiceChip</p><ul><li>单选标签</li></ul></li></ul><h3 id="Wrap"><a href="#Wrap" class="headerlink" title="Wrap"></a>Wrap</h3><ul><li>换行显示小组件</li></ul><h3 id="Divider"><a href="#Divider" class="headerlink" title="Divider"></a>Divider</h3><ul><li>分隔符</li></ul><h2 id="步骤组件"><a href="#步骤组件" class="headerlink" title="步骤组件"></a>步骤组件</h2><ul><li>Stepper</li></ul><h2 id="WillPopScope"><a href="#WillPopScope" class="headerlink" title="WillPopScope"></a>WillPopScope</h2><ul><li>返回键拦截组件</li></ul><h2 id="InheritedWidget"><a href="#InheritedWidget" class="headerlink" title="InheritedWidget"></a>InheritedWidget</h2><ul><li><p>数据在子组件和父组件之间共享</p></li><li><p>父组件数据改变 子组件的 didChangeDependencies 的方法会被调用</p></li></ul><h2 id="FutureBuilder"><a href="#FutureBuilder" class="headerlink" title="FutureBuilder"></a>FutureBuilder</h2><ul><li><p>处理异步数据框架</p></li><li><p>返回的数据自动更新到子组件中</p></li><li><p>future</p></li><li><p>builder</p></li></ul><h2 id="手势监听"><a href="#手势监听" class="headerlink" title="手势监听"></a>手势监听</h2><h3 id="GestureDetector"><a href="#GestureDetector" class="headerlink" title="GestureDetector"></a>GestureDetector</h3><ul><li><p>onPanDown</p></li><li><p>onPanUpdate</p><ul><li>手指滑动</li></ul></li><li><p>onScaleUpdate</p><ul><li>双指缩放事件</li></ul></li><li><p>onVerticalDragUpdate</p><ul><li>只监听垂直方向的拖动</li></ul></li></ul><h3 id="GestureRecognizer"><a href="#GestureRecognizer" class="headerlink" title="GestureRecognizer"></a>GestureRecognizer</h3><ul><li>GestureDetector 内部是使用一个或多个 GestureRecognizer 来识别各种手势的，而 GestureRecognizer 的作用就是通过 Listener 来将原始指针事件转换为语义手势</li></ul><h2 id="NotificationListener"><a href="#NotificationListener" class="headerlink" title="NotificationListener"></a>NotificationListener</h2><ol><li>onNotification</li></ol><ul><li>监听 child 的通知回调</li><li>当返回值为 true 时，阻止冒泡，其父级 Widget 将再也收不到该通知</li></ul><ol start="2"><li><p>child</p></li><li><p>原理</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> 跨平台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter框架原理</title>
      <link href="/94liucc/2020/09/16/Flutter/Flutter%E6%A1%86%E6%9E%B6%E5%8E%9F%E7%90%86/"/>
      <url>/94liucc/2020/09/16/Flutter/Flutter%E6%A1%86%E6%9E%B6%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="CachedNetworkImage"><a href="#CachedNetworkImage" class="headerlink" title="CachedNetworkImage"></a>CachedNetworkImage</h2><h3 id="缓存相关"><a href="#缓存相关" class="headerlink" title="缓存相关"></a>缓存相关</h3><ul><li><p>cacheManager</p><ul><li>如果我们自己没有设置 cacheManager</li><li>自动设置一个 DefaultCacheManager</li></ul></li><li><p>本地缓存首先调用内存缓存</p><ul><li>如果没有数据，则从本地 sqlite 查询</li><li>sqlite 缓存的是原图片 url 和本地图片 path 的对应关系</li></ul></li><li><p>网络获取</p></li></ul><h2 id="dio"><a href="#dio" class="headerlink" title="dio"></a>dio</h2><p><strong>无论何种请求，最终一定是调用 request 方法</strong></p><h2 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h2><h3 id="ImageProvider"><a href="#ImageProvider" class="headerlink" title="ImageProvider"></a>ImageProvider</h3><ul><li>是一个抽象类，定义了图片数据获取和加载的相关接口</li><li>加载图片数据并进行缓存、解码</li><li>NetworkImage 类和 AssetImage 类，它们都是 ImageProvider 的子类</li></ul><p><strong>主要通过 ImageProvider 获取到图片资源将 ImageStream 给到 ImageState</strong></p><p><strong>如果两张图片的 url 或 scale 只要有一个不同，便会重新下载并分别缓存</strong></p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> 跨平台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter工程架构</title>
      <link href="/94liucc/2020/09/14/Flutter/Flutter%E5%B7%A5%E7%A8%8B%E6%9E%B6%E6%9E%84/"/>
      <url>/94liucc/2020/09/14/Flutter/Flutter%E5%B7%A5%E7%A8%8B%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h2><h3 id="单一性原则"><a href="#单一性原则" class="headerlink" title="单一性原则"></a>单一性原则</h3><ul><li>每个组件专注做一件事</li></ul><h3 id="抽象化原则"><a href="#抽象化原则" class="headerlink" title="抽象化原则"></a>抽象化原则</h3><ul><li>对外暴露的接口很少发生变化，要做到这一点，需要我们提升对功能的抽象总结能力，在组件封装时做好功能抽象和接口设计，将所有可能发生变化的因子都在组件内部做好适配，不要暴露给它的调用方</li></ul><h3 id="稳定性原则"><a href="#稳定性原则" class="headerlink" title="稳定性原则"></a>稳定性原则</h3><ul><li>不要让稳定的组件依赖不稳定的组件</li></ul><h3 id="自完备性原则"><a href="#自完备性原则" class="headerlink" title="自完备性原则"></a>自完备性原则</h3><ul><li>组件需要尽可能地做到自给自足，尽量减少对其他底层组件的依赖，达到代码可复用的目的</li></ul><h3 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h3><ul><li>剥离基础功能、抽象业务模块和最小化服务能力。</li></ul><h2 id="平台化"><a href="#平台化" class="headerlink" title="平台化"></a>平台化</h2><p><strong>平台化是组件化的升级，即在组件化的基础上，对它们提供的功能进行分类，统一分层划分，增加依赖治理的概念</strong></p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li>具备 UI 属性的独立业务模块</li><li>不具备 UI 属性的基础业务功能</li><li>不具备业务属性的 UI 控件</li><li>不具备业务属性的基础功能</li></ul><h3 id="单向依赖原则"><a href="#单向依赖原则" class="headerlink" title="单向依赖原则"></a>单向依赖原则</h3><ul><li>组件依赖的顺序应该按照应用架构的层数从上到下依赖，不要出现下层模块依赖上层模块这样循环依赖的现象</li></ul><p><strong>平台化架构是目前应用最广的软件架构设计，其核心在于如何将离散的组件依照单向依赖的原则进行分层</strong></p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> 跨平台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter核心原理</title>
      <link href="/94liucc/2020/09/14/Flutter/Flutter%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/"/>
      <url>/94liucc/2020/09/14/Flutter/Flutter%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="FlutterUI"><a href="#FlutterUI" class="headerlink" title="FlutterUI"></a>FlutterUI</h2><p><strong>底层通过 OpenGl 这种跨平台绘制库实现一套代码跨多端，性能接近原生</strong></p><h2 id="Element-与-BuildContext"><a href="#Element-与-BuildContext" class="headerlink" title="Element 与 BuildContext"></a>Element 与 BuildContext</h2><p><strong>根据 Widget 生成 Element，然后创建相应的 RenderObject 并关联到 Element.renderObject 属性上，最后再通过 RenderObject 来完成布局排列和绘制</strong></p><h3 id="Element"><a href="#Element" class="headerlink" title="Element"></a>Element</h3><ul><li><p>Element 树根据 Widget 树生成，而 RenderObject 树又依赖于 Element 树</p></li><li><p>生命周期</p><ul><li><p>widget.createElement</p><ul><li>创建实例</li></ul></li><li><p>element.mount</p><ul><li>用 element.attachRenderObject 方法将 element.renderObject 添加到渲染树中插槽指定的位置</li></ul></li><li><p>状态更新</p><ul><li>重新构建 Element 树之前调用 widget.canUpdate 判断是否需要更新</li><li>widget.canUpdate 主要判断新旧 widget 的 runtimeType 和 key 是否同时相等</li></ul></li><li><p>移除 Element</p><ul><li>deactivateChild</li><li>unmount</li></ul></li></ul></li></ul><h3 id="BuildContext"><a href="#BuildContext" class="headerlink" title="BuildContext"></a>BuildContext</h3><ul><li>BuildContext 就是 widget 对应的 Element</li><li>我们可以通过 context 在 StatelessWidget 和 StatefulWidget 的 build 方法中直接访问 Element 对象</li></ul><h2 id="RenderObject-和-RenderBox"><a href="#RenderObject-和-RenderBox" class="headerlink" title="RenderObject 和 RenderBox"></a>RenderObject 和 RenderBox</h2><h3 id="RenderObject"><a href="#RenderObject" class="headerlink" title="RenderObject"></a>RenderObject</h3><ul><li>主要职责 Layout 和 绘制</li></ul><h3 id="RenderBox"><a href="#RenderBox" class="headerlink" title="RenderBox"></a>RenderBox</h3><ul><li><p>继承自 RenderBox，提供了坐标系统</p></li><li><p>布局过程</p><ul><li><p>Constraints</p><ul><li>父节点对子节点大小的限制</li></ul></li><li><p>relayoutBoundary</p></li><li><p>performResize 和 performLayout</p><ul><li>只有 sizedByParent 为 true 时，performResize() 才会被调用，而 performLayout() 是每次布局都会被调用的</li></ul></li><li><p>ParentData</p><ul><li>不仅仅可以用来存储偏移信息，通常所有和子节点特定的数据都可以存储到子节点的 ParentData 中</li></ul></li></ul></li><li><p>绘制过程</p><ul><li>RenderObject 可以通过 paint 方法来完成具体绘制逻辑</li><li>RepaintBoundary</li></ul></li></ul><h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><ul><li>创建 StreamBuilder</li><li>获取 StreamSink 作为事件入口</li><li>获取 Stream 对象用于监听</li><li>通过监听得到 StreamSubscription 管理事件订阅</li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul><li>基于事件流驱动设计代码，然后监听订阅事件，并针对事件变换处理响应。</li></ul><h2 id="与原生通信"><a href="#与原生通信" class="headerlink" title="与原生通信"></a>与原生通信</h2><h3 id="MethodChannel"><a href="#MethodChannel" class="headerlink" title="MethodChannel"></a>MethodChannel</h3><ul><li><p>返回类型不一致</p><ul><li>由于涉及到跨系统数据交互，Flutter 会使用 StandardMessageCodec 对通道中传输的信息进行类似 JSON 的二进制序列化，以标准化数据传输行为</li><li>这样在我们发送或者接收数据时，这些数据就会根据各自系统预定的规则自动进行序列化和反序列化</li></ul></li><li><p>方法通道是非线程安全的</p><ul><li>这意味着原生代码与 Flutter 之间所有接口调用必须发生在主线程</li><li>而原生代码在处理方法调用请求时，如果涉及到异步或非主线程切换，需要确保回调过程是在原生系统的 UI 线程（也就是 Android 和 iOS 的主线程）中执行的</li></ul></li></ul><h3 id="EventChannel"><a href="#EventChannel" class="headerlink" title="EventChannel"></a>EventChannel</h3><ul><li>原生平台主动调用 flutter 端事件通道</li></ul><h3 id="平台视图"><a href="#平台视图" class="headerlink" title="平台视图"></a>平台视图</h3><ul><li><p>过程</p><ul><li>flutter 通过向原生视图的封装类传入视图标志，发起原生视图的创建请求</li><li>原生代码将对应原生视图的创建交给 PlatformViewFactory 实现</li><li>最后，在原生代码侧将视图标识符与平台视图工厂进行关联注册，让 Flutter 发起的视图创建请求可以直接找到对应的视图创建工厂。</li></ul></li><li><p>实现</p><ul><li>AndroidView</li><li>UikitView</li></ul></li></ul><h2 id="线程管理"><a href="#线程管理" class="headerlink" title="线程管理"></a>线程管理</h2><h3 id="四个线程"><a href="#四个线程" class="headerlink" title="四个线程"></a>四个线程</h3><ul><li>UI TaskRunner</li><li>Platform TaskRunner</li><li>GPU TaskRunner</li><li>IO TaskRunner</li></ul><h2 id="自绘组件"><a href="#自绘组件" class="headerlink" title="自绘组件"></a>自绘组件</h2><h3 id="CustomPaint"><a href="#CustomPaint" class="headerlink" title="CustomPaint"></a>CustomPaint</h3><ul><li><p>Canvas</p><ul><li><p>画布</p><ul><li>drawLine</li><li>drawRect</li><li>drawPaint</li></ul></li></ul></li><li><p>Paint</p><ul><li><p>画笔</p><ul><li>颜色</li><li>样式</li><li>粗细</li></ul></li></ul></li><li><p>CustomPainter</p><ul><li>绘制逻辑</li><li>继承</li></ul></li></ul><h2 id="RenderObject-和-RenderBox-1"><a href="#RenderObject-和-RenderBox-1" class="headerlink" title="RenderObject 和 RenderBox"></a>RenderObject 和 RenderBox</h2><p><strong>RenderObject 类本身实现了一套基础的 layout 和绘制协议，但是并没有定义子节点模型，坐标系统等</strong></p><h3 id="RenderBox-1"><a href="#RenderBox-1" class="headerlink" title="RenderBox"></a>RenderBox</h3><ul><li><p>布局过程</p><ul><li><p>Constraints</p><ul><li>限制子节点的最大和最小宽高，子节点必须遵守父节点给定的限制条件</li></ul></li></ul></li></ul><h2 id="Flutter-从启动到显示"><a href="#Flutter-从启动到显示" class="headerlink" title="Flutter 从启动到显示"></a>Flutter 从启动到显示</h2><ul><li><p>启动</p></li><li><p>渲染</p></li><li><p>绘制</p></li></ul><h2 id="编译模式"><a href="#编译模式" class="headerlink" title="编译模式"></a>编译模式</h2><ol><li><p>Script</p></li><li><p>Script Snapshot</p></li><li><p>Kernel Snapshot</p></li></ol><ul><li><p>Dart 的 bytecode 模式，在某种程度上类似 JVM。在 Flutter 项目中也被叫做 Core Snapshot，它是和设备架构无关的</p></li><li><p>debug 模式下的编译模式</p></li><li><p>生成产物</p><ul><li>isolate_snapshot_data: 加速 isolate 启动的数据，和业务无关</li><li>vm_snapshot_data: 加速 Dart VM 启动的数据，和业务无关</li><li>kernel_blob.bin: 业务代码产物</li></ul></li></ul><ol start="4"><li>Core JIT</li></ol><ul><li>aot 模式</li><li>编译后的二进制格式</li></ul><ol start="5"><li>AOT Assembly</li></ol><ul><li>aot</li></ul>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> 跨平台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter动画</title>
      <link href="/94liucc/2020/09/13/Flutter/Flutter%E5%8A%A8%E7%94%BB/"/>
      <url>/94liucc/2020/09/13/Flutter/Flutter%E5%8A%A8%E7%94%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="AnimationController"><a href="#AnimationController" class="headerlink" title="AnimationController"></a>AnimationController</h2><ul><li><p>duration</p></li><li><p>controller.forward()</p><ul><li>动画开启</li></ul></li><li><p>controller.reset()</p></li><li><p>controller.reverse()</p></li></ul><h2 id="Tween"><a href="#Tween" class="headerlink" title="Tween"></a>Tween</h2><ul><li><p>补间动画</p></li><li><p>Tween 继承自 Animatable<t> 而不是 Animation</t></p></li><li><p>子主题 3</p></li></ul><h2 id="Animation"><a href="#Animation" class="headerlink" title="Animation"></a>Animation</h2><ul><li><p>保存动画的差值和状态</p></li><li><p>监听</p></li><li><p>addListener</p></li><li><p>addStatusListener</p><ul><li>动画状态监听</li></ul></li></ul><h2 id="Curve"><a href="#Curve" class="headerlink" title="Curve"></a>Curve</h2><h2 id="CurvedAnimation"><a href="#CurvedAnimation" class="headerlink" title="CurvedAnimation"></a>CurvedAnimation</h2><ul><li>非线性曲线</li></ul><h2 id="Ticker"><a href="#Ticker" class="headerlink" title="Ticker"></a>Ticker</h2><ul><li><p>Flutter 应用在启动时都会绑定一个 SchedulerBinding，通过 SchedulerBinding 可以给每一次屏幕刷新添加回调，而 Ticker 就是通过 SchedulerBinding 来添加屏幕刷新回调，这样一来，每次屏幕刷新都会调用 TickerCallback</p></li><li><p>使用 Ticker(而不是 Timer)来驱动动画会防止屏幕外动画（动画的 UI 不在当前屏幕时，如锁屏时）消耗不必要的资源</p></li></ul><h2 id="AnimatedWidget"><a href="#AnimatedWidget" class="headerlink" title="AnimatedWidget"></a>AnimatedWidget</h2><ul><li><p>封装了调用 setState()的细节，并允许我们将 widget 分离出来</p></li><li><p>动画组件继承 AnimatedWidget</p></li><li><p>会自动调用 addListener 的 setState 方法</p></li></ul><h2 id="AnimatedBuilder"><a href="#AnimatedBuilder" class="headerlink" title="AnimatedBuilder"></a>AnimatedBuilder</h2><ul><li><p>进一步封装动画组件</p></li><li><p>将渲染逻辑分离出来</p></li><li><p>好处</p><ul><li>不用显式的去添加帧监听器，然后再调用 setState()</li><li>动画构建的范围缩小了，只会导致子组件重新 setState</li><li>通过 AnimatedBuilder 可以封装常见的过渡效果来复用动画</li></ul></li></ul><h2 id="AnimatedSwitcher"><a href="#AnimatedSwitcher" class="headerlink" title="AnimatedSwitcher"></a>AnimatedSwitcher</h2><ul><li>对新旧动画的切换效果</li></ul>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> 跨平台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter基础</title>
      <link href="/94liucc/2020/09/12/Flutter/Flutter%E5%9F%BA%E7%A1%80/"/>
      <url>/94liucc/2020/09/12/Flutter/Flutter%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="Widget"><a href="#Widget" class="headerlink" title="Widget"></a>Widget</h2><ul><li><p>Row,Column</p><ul><li>弹性布局</li></ul></li><li><p>Stack</p><ul><li>允许子元素堆叠</li></ul></li></ul><h2 id="Flutter-架构"><a href="#Flutter-架构" class="headerlink" title="Flutter 架构"></a>Flutter 架构</h2><h2 id="手势"><a href="#手势" class="headerlink" title="手势"></a>手势</h2><ul><li>GestureDetector</li></ul><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><ul><li><p>StatelessWidget</p></li><li><p>build</p></li><li><p>StatefulWidget</p><ul><li>createState</li><li>initState</li><li>reassemble</li><li>didChangeDependencies</li><li>build</li><li>deactivate</li><li>dispose</li><li>didUpdateWidget</li></ul></li></ul><h2 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h2><h3 id="widget-自己管理"><a href="#widget-自己管理" class="headerlink" title="widget 自己管理"></a>widget 自己管理</h3><h3 id="父-widget-管理"><a href="#父-widget-管理" class="headerlink" title="父 widget 管理"></a>父 widget 管理</h3><ul><li>管理状态并告诉子 widget 合适更新</li><li>将状态通过参数等方式传递给子 widget</li><li>子 widget 通过回调等方式更新父组件状态</li></ul><h3 id="混搭管理"><a href="#混搭管理" class="headerlink" title="混搭管理"></a>混搭管理</h3><h2 id="ListView"><a href="#ListView" class="headerlink" title="ListView"></a>ListView</h2><h3 id="懒加载机制"><a href="#懒加载机制" class="headerlink" title="懒加载机制"></a>懒加载机制</h3><ul><li><p>只绘制视窗内的 item</p></li><li><p>预加载视窗下的提前一个 widget</p></li><li><p>滑动过后的 item dispose 掉，之后再重新创建</p><ul><li>调用 initState 方法</li></ul></li></ul><h2 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h2><h3 id="直接执行-build-方法"><a href="#直接执行-build-方法" class="headerlink" title="直接执行 build 方法"></a>直接执行 build 方法</h3><h2 id="Decoration"><a href="#Decoration" class="headerlink" title="Decoration"></a>Decoration</h2><h3 id="BoxDecoration"><a href="#BoxDecoration" class="headerlink" title="BoxDecoration"></a>BoxDecoration</h3><ul><li>边框，圆角，阴影，形状，渐变，背景图</li></ul><h3 id="ShapeDecoration"><a href="#ShapeDecoration" class="headerlink" title="ShapeDecoration"></a>ShapeDecoration</h3><h3 id="FlutterLogoDecoration"><a href="#FlutterLogoDecoration" class="headerlink" title="FlutterLogoDecoration"></a>FlutterLogoDecoration</h3><h3 id="UnderlineTabindicator"><a href="#UnderlineTabindicator" class="headerlink" title="UnderlineTabindicator"></a>UnderlineTabindicator</h3><ul><li>下划线</li></ul><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li>使用 decoration 不能使用外部的样式</li></ul><h2 id="Dart-工厂模式"><a href="#Dart-工厂模式" class="headerlink" title="Dart 工厂模式"></a>Dart 工厂模式</h2><h2 id="手势竞争和处理"><a href="#手势竞争和处理" class="headerlink" title="手势竞争和处理"></a>手势竞争和处理</h2><ul><li><p>Flutter 中的手势识别引入了一个 Arena 的概念</p></li><li><p>当发生滑动事件时，他们都要在“竞技场”去竞争本次事件的处理权，而最终只有一个“竞争者”会胜出(win)</p></li><li><p>首次移动时的位移在水平和垂直方向上的分量大的一个获胜</p></li><li><p>在遇到复杂的冲突场景时，都可以通过 Listener 直接识别原始指针事件来解决冲突</p></li></ul><h2 id="Notification"><a href="#Notification" class="headerlink" title="Notification"></a>Notification</h2><ul><li><p>在 widget 树中，每一个节点都可以分发通知，通知会沿着当前节点向上传递，所有父节点都可以通过 NotificationListener 来监听通知</p></li><li><p>通知冒泡可以中止，但用户触摸事件不行</p></li></ul><h2 id="自定义路由动画"><a href="#自定义路由动画" class="headerlink" title="自定义路由动画"></a>自定义路由动画</h2><ul><li>PageRouteBuilder</li></ul><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><ul><li><p>布局调试</p></li><li><p>debugPaintEnable = true</p></li><li><p>flutter Inspector</p></li></ul><h2 id="分析模式"><a href="#分析模式" class="headerlink" title="分析模式"></a>分析模式</h2><ul><li><p>分析渲染问题</p></li><li><p>dart devtools</p></li></ul><h2 id="自动化测试用例"><a href="#自动化测试用例" class="headerlink" title="自动化测试用例"></a>自动化测试用例</h2><ul><li><p>单元测试</p></li><li><p>UI 测试</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> 跨平台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FlutterAPI</title>
      <link href="/94liucc/2020/09/11/Flutter/FlutterAPI/"/>
      <url>/94liucc/2020/09/11/Flutter/FlutterAPI/</url>
      
        <content type="html"><![CDATA[<h2 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h2><h3 id="InheritedWidget"><a href="#InheritedWidget" class="headerlink" title="InheritedWidget"></a>InheritedWidget</h3><ul><li>可以将父类数据直接传递给孙子类</li><li>而不是子类传递子类</li></ul><h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><ol><li><p>基于事件流驱动设计代码，然后监听订阅事件，并针对事件变换处理响应</p></li><li><p>提供一个异步的数据序列</p></li><li><p>_streams.listen(onData,onError,onDone)</p></li><li><p>StreamSubscription</p></li></ol><ul><li>暂停，恢复，取消监听</li><li>取消监听之后 不能恢复</li></ul><ol start="5"><li>StreamController</li></ol><ul><li><p>动态添加订阅</p></li><li><p>StreamController.brodcast()</p><ul><li>多次添加订阅信息</li></ul></li></ul><ol start="6"><li>StreamSink</li></ol><ul><li>向 stream 添加数据</li></ul><ol start="7"><li>StreamBuilder</li></ol><ul><li>获取到异步的数据后，自动更新组件</li></ul><h2 id="RxDart"><a href="#RxDart" class="headerlink" title="RxDart"></a>RxDart</h2><ul><li><p>Observable</p></li><li><p>PublishObservable</p></li><li><p>BehaviorSubject</p></li><li><p>ReplaySubject</p></li></ul><h2 id="Bloc"><a href="#Bloc" class="headerlink" title="Bloc"></a>Bloc</h2><h2 id="Animation"><a href="#Animation" class="headerlink" title="Animation"></a>Animation</h2><ul><li>AnimationController</li></ul><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><ul><li>单元测试</li></ul><h2 id="与-Native-通信"><a href="#与-Native-通信" class="headerlink" title="与 Native 通信"></a>与 Native 通信</h2><ul><li><p>PlatformChannel</p></li><li><p>MethodChannel</p><ul><li>用于方法传递</li></ul></li><li><p>EventChannel</p><ul><li>用于传递事件</li></ul></li><li><p>BasicMessageChannel</p><ul><li>传递数据</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> 跨平台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter Provider</title>
      <link href="/94liucc/2020/09/10/Flutter/Flutter%20Provider/"/>
      <url>/94liucc/2020/09/10/Flutter/Flutter%20Provider/</url>
      
        <content type="html"><![CDATA[<h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p><strong>关注由于值的变化进行  跨组件的状态更新</strong></p><h2 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider</h2><ol><li><p>ChangeNotifierProvider</p></li><li><p>ProxyProvider</p></li></ol><ul><li>当两个 view model 之间存在依赖关系的时候使用这个类型的 provider。</li></ul><ol start="3"><li>ChangeNotifierProxyProvider</li></ol><ul><li>会发送更新到 ChangeNotifierProvider</li></ul><ol start="4"><li>StreamProvider</li></ol><ul><li>对 StreamBulder 的一层封装</li></ul><ol start="5"><li>FutureProvider</li></ol><ul><li>对 FutureBuilder 的一层封装</li></ul><h2 id="触发"><a href="#触发" class="headerlink" title="触发"></a>触发</h2><ul><li>Provider.of<t>()</t></li></ul><h2 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h2><ul><li><p>consumer</p></li><li><p>selector</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> 跨平台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础架构</title>
      <link href="/94liucc/2020/01/30/Android/%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/"/>
      <url>/94liucc/2020/01/30/Android/%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><h3 id="model"><a href="#model" class="headerlink" title="model"></a>model</h3><ul><li>代表数据模型，管理数据状态</li></ul><h3 id="view"><a href="#view" class="headerlink" title="view"></a>view</h3><ul><li>视图，即呈现给用户的 UI</li></ul><h3 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h3><ul><li>负责处理用户与 app 之间的交互</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>View 与 Model 之间存在依赖关系，Controller 很重很复杂</li><li>view 层和 model 层是相互可知的，这意味着两层之间存在耦合</li></ul><p><strong>在 Android 中 Activity 即是 View 又是 Controller，所以会很复杂</strong></p><ul><li>xml 文件就对应于 MVC 的 view 层</li><li>网络请求相当于 Model 层</li><li>Activity 相当于 Controller</li></ul><h2 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h2><h3 id="model-1"><a href="#model-1" class="headerlink" title="model"></a>model</h3><ul><li>同上</li></ul><h3 id="view-1"><a href="#view-1" class="headerlink" title="view"></a>view</h3><ul><li>同上</li></ul><h3 id="presenter"><a href="#presenter" class="headerlink" title="presenter"></a>presenter</h3><ul><li><p>Presenter 通过 View 接收用户的输入，然后在 Model 的帮助下处理用户的数据并将结果传递回 View</p><ul><li>Presenter 通过接口与 View 进行通信</li></ul></li></ul><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><ul><li>presenter 层充当了桥梁的作用，用于操作 view 层发出的事件传递到 presenter 层中，presenter 层去操作 model 层，并且将数据返回给 view 层</li></ul><p><strong>虽然是 MVC 模式的演变，但 Presenter 依旧很‘重’很复杂。</strong></p><h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><h3 id="model-2"><a href="#model-2" class="headerlink" title="model"></a>model</h3><ul><li>同上</li></ul><h3 id="view-2"><a href="#view-2" class="headerlink" title="view"></a>view</h3><ul><li>同上</li></ul><h3 id="viewModel"><a href="#viewModel" class="headerlink" title="viewModel"></a>viewModel</h3><ul><li>View 引用持有 ViewModel，但 ViewModel 得不到任何关于 View 的信息</li><li>View 与 ViewModel 之间存在着一对多的关系，一个 View 可以持有多个 ViewModel</li></ul><p><strong>view 层和 viewmodel 层是相互绑定的关系，这意味着当你更新 viewmodel 层的数据的时候，view 层会相应的变动 ui</strong></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android基础</title>
      <link href="/94liucc/2020/01/27/Android/Android%E5%9F%BA%E7%A1%80/"/>
      <url>/94liucc/2020/01/27/Android/Android%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h2><h3 id="Linux-内核"><a href="#Linux-内核" class="headerlink" title="Linux 内核"></a>Linux 内核</h3><h3 id="系统运行库"><a href="#系统运行库" class="headerlink" title="系统运行库"></a>系统运行库</h3><ul><li><p>c/c++库</p><ul><li>sqlite</li><li>opengl</li></ul></li><li><p>运行时库</p><ul><li>虚拟机</li><li>ART</li></ul></li></ul><h3 id="应用框架层"><a href="#应用框架层" class="headerlink" title="应用框架层"></a>应用框架层</h3><ul><li>framework 层</li></ul><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><h2 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h2><h3 id="launchMode"><a href="#launchMode" class="headerlink" title="launchMode"></a>launchMode</h3><ul><li><p>standard</p><ul><li>无论栈中是否有实例，都会去重新创建</li></ul></li><li><p>singleTop</p><ul><li>如果栈顶已经是这个实例，不会重新创建</li></ul></li><li><p>singleTask</p><ul><li>每次启动该实例，都会检查是否存在</li><li>如果存在，直接使用该实例，并把这个活动之上的所有活动出栈</li></ul></li><li><p>singleInstance</p><ul><li>启动这个实例的时候，启动一个栈来专门存放该实例</li></ul></li></ul><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><ul><li>onCreate</li><li>onStart</li><li>onPause</li><li>onResume</li><li>onStop</li><li>onDestory</li></ul><h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><ol><li>基本布局</li></ol><ul><li>LinearLayout</li><li>RelativeLayout</li><li>FrameLayout</li><li>PercentLayout</li></ul><ol start="2"><li>自定义布局</li></ol><h2 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h2><ul><li>replaceFragment</li></ul><ol><li>生命周期</li></ol><ul><li><p>onAttach</p><ul><li>当 fragment 和 activity 关联的时候调用</li></ul></li><li><p>onCreateView</p><ul><li>加载布局的时候调用</li></ul></li><li><p>onActivityCreated</p></li><li><p>onDestroyView</p></li><li><p>onDetach</p><ul><li>和 Activity 解除关联的时候</li></ul></li><li><p>完整生命周期</p></li></ul><h2 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h2><ol><li>标准广播</li></ol><ul><li>异步执行的</li><li>广播接收器会在同一时刻接收到这条信息</li></ul><ol start="2"><li>有序广播</li></ol><ul><li>同步执行的广播</li></ul><ol start="3"><li>本地广播</li></ol><h2 id="ContentProvider"><a href="#ContentProvider" class="headerlink" title="ContentProvider"></a>ContentProvider</h2><ul><li>跨进程共享数据</li></ul><h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><ol><li>生命周期</li></ol><ul><li>onCreate</li><li>onStartCommand</li><li>onBind</li><li>onDestroy</li></ul><ol start="2"><li>前台服务</li></ol><ul><li>当系统内存不足时，有可能回收正在后台运行的服务</li><li>前台服务会有一个正在运行的图表在系统的状态栏显示</li></ul><ol start="3"><li>Service 运行在主线程，耗时操作需要启动一个子线程</li></ol><h2 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h2><ul><li>Message,Handler,MessageQueue,Looper</li></ul><ol><li>Message</li></ol><ul><li>在线程之间传递消息，内部携带少量数据</li></ul><ol start="2"><li>Handler</li></ol><ul><li>发送和处理信息</li></ul><ol start="3"><li>MessageQueue</li></ol><ul><li>主要用户存放所有通过 Handler 发送的消息</li></ul><ol start="4"><li>Looper</li></ol><ul><li>当发现 MessageQueue 中存在一条消息，会将它取出，并传递到 handleMessage 方法中</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="Serializable-和-Parcelable"><a href="#Serializable-和-Parcelable" class="headerlink" title="Serializable 和 Parcelable"></a>Serializable 和 Parcelable</h3><ul><li><p>Serializable</p><ul><li>java 序列化</li></ul></li><li><p>Parcelable</p><ul><li>Android 独有的序列化</li><li>进行了优化 但是实现较为复杂</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React生态圈</title>
      <link href="/94liucc/2019/09/12/React/React%E7%94%9F%E6%80%81%E5%9C%88/"/>
      <url>/94liucc/2019/09/12/React/React%E7%94%9F%E6%80%81%E5%9C%88/</url>
      
        <content type="html"><![CDATA[<h2 id="React-Router"><a href="#React-Router" class="headerlink" title="React Router"></a>React Router</h2><p><strong>在一个组件容器中，根据 url 去判断，要展示什么组件</strong></p><ul><li>单页面应用中</li></ul><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li><p>声明式路由定义</p><ul><li><route></route></li></ul></li><li><p>动态路由</p></li></ul><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><ul><li><p>URL 路径</p></li><li><p>hash 路由</p><ul><li>低版本浏览器兼容</li></ul></li><li><p>内存路由</p><ul><li><p>MemoryRouter</p><ul><li>url 链接没有变化</li><li>路由存在内存中</li></ul></li></ul></li></ul><h3 id="基于路由配置进行资源组织"><a href="#基于路由配置进行资源组织" class="headerlink" title="基于路由配置进行资源组织"></a>基于路由配置进行资源组织</h3><ul><li>实现业务逻辑的解耦</li><li>易于扩展，重构，维护</li><li>路由层面实现 Lazy Load</li></ul><h3 id="核心-API"><a href="#核心-API" class="headerlink" title="核心 API"></a>核心 API</h3><ul><li><link><ul><li>不会触发浏览器刷新</li></ul></li><li><p>NavLink</p><ul><li>类似 Link 而且会添加当前选中状态</li></ul></li><li><p>Prompt</p><ul><li>满足条件时提示用户是否离开当前页面</li></ul></li><li><p>Redirect</p><ul><li>重定向到指定界面</li></ul></li><li><p>Route</p><ul><li><p>路径匹配时显示对应组件</p></li><li><p>可以多匹配不同的路由</p><ul><li>同时显示</li></ul></li></ul></li><li><p>Switch</p><ul><li>只显示第一个匹配的路由</li></ul></li></ul><h3 id="通过-URL-传递参数"><a href="#通过-URL-传递参数" class="headerlink" title="通过 URL 传递参数"></a>通过 URL 传递参数</h3><ul><li><p>参数获取</p><ul><li>match.params.id</li></ul></li><li><p>通过 url 获取参数</p></li></ul><h3 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h3><h2 id="UI-组件库"><a href="#UI-组件库" class="headerlink" title="UI 组件库"></a>UI 组件库</h2><ul><li><p>AntD</p></li><li><p>Material-UI</p></li></ul><h2 id="Next-js"><a href="#Next-js" class="headerlink" title="Next.js"></a>Next.js</h2><h3 id="同构应用"><a href="#同构应用" class="headerlink" title="同构应用"></a>同构应用</h3><ul><li>初次发送请求</li><li>返回渲染后的 App 界面</li><li>客户端本地操作</li></ul><h3 id="使用-Link"><a href="#使用-Link" class="headerlink" title="使用 Link"></a>使用 Link</h3><ul><li><p>同步路由</p></li><li><p>不会刷新界面</p></li><li><p>prefetch</p><ul><li>预加载</li></ul></li><li><p>replace</p><ul><li>使用新的 URL 链接</li></ul></li><li><p>lazyLoad</p><ul><li>next/dynamic</li></ul></li></ul><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><h3 id="虚拟-DOM-可以在-NodeJs-环境运行和测试"><a href="#虚拟-DOM-可以在-NodeJs-环境运行和测试" class="headerlink" title="虚拟 DOM 可以在 NodeJs 环境运行和测试"></a>虚拟 DOM 可以在 NodeJs 环境运行和测试</h3><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><ul><li><p>jest</p></li><li><p>jsdom</p><ul><li>模拟浏览器的 NodeJs 环境</li></ul></li><li><p>Enzyme</p><ul><li><p>Shallow Rendering</p><ul><li>shallow</li></ul></li><li><p>Full Render</p><ul><li>count</li></ul></li></ul></li><li><p>nock</p><ul><li>模拟 HTTP 请求</li><li>模拟返回数据 和 返回类型</li></ul></li><li><p>Sinon</p><ul><li>函数的跟踪</li></ul></li></ul><h2 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h2><ol><li>ESLint</li></ol><ul><li><p>.eslintrc 进行规则配置</p></li><li><p>extend 属性</p><ul><li>依赖本地的 .eslintrc</li></ul></li></ul><ol start="2"><li>Prettier</li></ol><ul><li>代码风格格式化</li></ul><ol start="3"><li><p>React Dev Tool</p></li><li><p>Redux Dev Tool</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React架构</title>
      <link href="/94liucc/2019/09/12/React/React%E6%9E%B6%E6%9E%84/"/>
      <url>/94liucc/2019/09/12/React/React%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><h3 id="易开发"><a href="#易开发" class="headerlink" title="易开发"></a>易开发</h3><ul><li>开发工具</li><li>生态圈</li><li>社区活跃</li></ul><h3 id="易于扩展"><a href="#易于扩展" class="headerlink" title="易于扩展"></a>易于扩展</h3><h3 id="易于维护"><a href="#易于维护" class="headerlink" title="易于维护"></a>易于维护</h3><ul><li>文档是否健全</li></ul><h3 id="易于测试"><a href="#易于测试" class="headerlink" title="易于测试"></a>易于测试</h3><ul><li>功能分层是否清晰</li><li>副作用少</li><li>尽量使用纯函数</li></ul><h3 id="易于构建"><a href="#易于构建" class="headerlink" title="易于构建"></a>易于构建</h3><ul><li>使用通用技术和架构</li><li>构建工具</li></ul><h2 id="拆分复杂度"><a href="#拆分复杂度" class="headerlink" title="拆分复杂度"></a>拆分复杂度</h2><h3 id="按-feature-组织代码，降低耦合度"><a href="#按-feature-组织代码，降低耦合度" class="headerlink" title="按 feature 组织代码，降低耦合度"></a>按 feature 组织代码，降低耦合度</h3><ul><li>将业务逻辑拆分成高内聚松耦合的模块</li></ul><h3 id="文件夹结构"><a href="#文件夹结构" class="headerlink" title="文件夹结构"></a>文件夹结构</h3><ul><li>按照功能组织源文件</li><li>组件和样式在同一级</li><li>把 action 和 reducer 放到同一级</li></ul><h3 id="组织-Router-路由配置"><a href="#组织-Router-路由配置" class="headerlink" title="组织 Router 路由配置"></a>组织 Router 路由配置</h3><ul><li><p>每个 feature 中单独定义自己的路由</p><ul><li>每个 feature 都有一个 route.js</li></ul></li><li><p>使用 JSON 定义顶层路由</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React性能优化</title>
      <link href="/94liucc/2019/09/10/React/React%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
      <url>/94liucc/2019/09/10/React/React%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="时刻注意性能问题"><a href="#时刻注意性能问题" class="headerlink" title="时刻注意性能问题"></a>时刻注意性能问题</h2><h3 id="常见性能问题场景"><a href="#常见性能问题场景" class="headerlink" title="常见性能问题场景"></a>常见性能问题场景</h3><ul><li>键盘输入</li><li>组件移动或页面滚动</li></ul><h3 id="代码的潜在性能问题"><a href="#代码的潜在性能问题" class="headerlink" title="代码的潜在性能问题"></a>代码的潜在性能问题</h3><ul><li>组件的粒度</li></ul><h3 id="代码可重构"><a href="#代码可重构" class="headerlink" title="代码可重构"></a>代码可重构</h3><ul><li>耦合性低</li></ul><h3 id="使用工具定位性能问题"><a href="#使用工具定位性能问题" class="headerlink" title="使用工具定位性能问题"></a>使用工具定位性能问题</h3><ul><li>devtool</li></ul><h2 id="网络性能优化"><a href="#网络性能优化" class="headerlink" title="网络性能优化"></a>网络性能优化</h2><ul><li><p>webpack 的 import API</p></li><li><p>react-loadable 组件进行按需加载</p></li></ul><h2 id="Reselect-避免重复计算"><a href="#Reselect-避免重复计算" class="headerlink" title="Reselect 避免重复计算"></a>Reselect 避免重复计算</h2><ul><li><p>对 store 中的数据进行计算缓存</p></li><li><p>当数据发生变化时才会去执行计算过程，否则使用缓存的结果</p></li></ul><h2 id="异步渲染"><a href="#异步渲染" class="headerlink" title="异步渲染"></a>异步渲染</h2><h3 id="时间分片"><a href="#时间分片" class="headerlink" title="时间分片"></a>时间分片</h3><ul><li><p>DOM 操作的优先级低于浏览器原生行为</p></li><li><p>如键盘和鼠标输入，保证操作的流畅</p></li><li><p>Chrome 的 API</p><ul><li>requestIdleCallback</li><li>浏览器不忙的状态</li></ul></li><li><p>React 的 API</p><ul><li>deferredUpdates</li></ul></li></ul><h3 id="渲染挂起"><a href="#渲染挂起" class="headerlink" title="渲染挂起"></a>渲染挂起</h3><ul><li>虚拟 DOM 节点可以等待某个异步操作的完成，指定 timeout 之后才完成真正渲染</li></ul><h2 id="Chrome-DevTool"><a href="#Chrome-DevTool" class="headerlink" title="Chrome DevTool"></a>Chrome DevTool</h2><h3 id="React-DevTool"><a href="#React-DevTool" class="headerlink" title="React DevTool"></a>React DevTool</h3><ul><li>HighLight Update</li></ul><h3 id="Chrome-DevTool-1"><a href="#Chrome-DevTool-1" class="headerlink" title="Chrome DevTool"></a>Chrome DevTool</h3><ul><li>CPU 降速</li></ul>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
