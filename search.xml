<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hexo部署到GitHubPages</title>
      <link href="/2023/02/03/Hexo/"/>
      <url>/2023/02/03/Hexo/</url>
      
        <content type="html"><![CDATA[<p>最近想要把 Hexo 部署到 GitHubPages 来搭建自己的博客，分享一下具体步骤。</p><h2 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h2><p>登录自己的 GitHub 账号，然后创建一个仓库</p><p><strong>repository 应该直接命名为 &lt;你的 GitHub 用户名&gt;.github.io</strong></p><p><strong>这一步是必须要做的，哪怕你之前有一个仓库专门放 Hexo 的代码</strong></p><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>在 hexo 项目根目录</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cnpm <span class="token function">install</span> <span class="token parameter variable">--save</span> hexo-deployer-git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="修改-config-yml-文件"><a href="#修改-config-yml-文件" class="headerlink" title="修改_config.yml 文件"></a>修改_config.yml 文件</h2><p>根目录文件夹中找到_config.yml 文件，在文件的最后，加入 如下内容</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token literal-property property">deploy</span><span class="token operator">:</span> type<span class="token operator">:</span> git<span class="token punctuation">;</span><span class="token literal-property property">repo</span><span class="token operator">:</span> 第一步创建的仓库地址<span class="token punctuation">;</span><span class="token literal-property property">branch</span><span class="token operator">:</span> master<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>例如</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token literal-property property">deploy</span><span class="token operator">:</span>  <span class="token literal-property property">type</span><span class="token operator">:</span> git  <span class="token literal-property property">repo</span><span class="token operator">:</span> git@github<span class="token punctuation">.</span>com<span class="token operator">:</span>94liucc<span class="token operator">/</span>94liucc<span class="token punctuation">.</span>github<span class="token punctuation">.</span>io<span class="token punctuation">.</span>git  <span class="token literal-property property">branch</span><span class="token operator">:</span> master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="修改-url"><a href="#修改-url" class="headerlink" title="修改 url"></a>修改 url</h2><p>如果不去修改 Url 的话，可能导致我们的博客无法找到 css 文件</p><p><strong>更改_config.yml 文件下的如下参数</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token literal-property property">url</span><span class="token operator">:</span> https<span class="token operator">:</span><span class="token operator">/</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">gitname.github.io</span><span class="token regex-delimiter">/</span></span><span class="token literal-property property">root</span><span class="token operator">:</span> <span class="token operator">/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>其中 root 参数可以在自己的 github 仓库的 Settings-&gt;Pages-&gt;Branch 里面找到文件夹，默认是 root，所以参数这里填写 /</p><h2 id="打包部署"><a href="#打包部署" class="headerlink" title="打包部署"></a>打包部署</h2><p>依次执行一下命令，打包部署即可</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo ghexo d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>然后打开 git 项目地址的 Actions 等待部署完成，之后去你填写的 url 的地址就能看到你的博客了</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端需要了解的设计模式</title>
      <link href="/2022/04/19/%E5%89%8D%E7%AB%AF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/04/19/%E5%89%8D%E7%AB%AF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><p><strong><em>为子系统中的一组接口提供一个统一的高层接口，使子系统更容易使用。</em></strong></p><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p><strong><em>一个类只能构造出唯一实例</em></strong></p><ul><li><p>案例：</p><ul><li>弹窗</li><li>操作回退栈</li></ul></li></ul><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><ol><li>增加一个对象的访问控制</li><li>对访问对象的过程中增加额外的逻辑</li></ol><h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><p><strong><em>在不改变对象自身的基础上，动态地给某个对象添加一些额外的指责</em></strong></p><ul><li>案例<ul><li>高阶函数</li></ul></li></ul><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p><strong><em>工厂模式是用来创建对象的一种最常见的设计模式</em></strong></p><p>不暴露创建对象的具体逻辑，而是将逻辑封装在一个函数中，这个函数就可以被视为一个工厂</p><h2 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h2><p><strong><em>订阅者订阅相关主题，发布者通过发布主题事件的方式，通知订阅该主题的对象</em></strong><br>与观察者的区别在于，发布订阅模式需要中间的 Broker</p><ul><li>观察者和被观察者，是松耦合的关系</li><li>发布者和订阅者，则完全不存在耦合</li></ul><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p><strong><em>当对象发生变化时，会通知观察者进行更新</em></strong></p><ul><li>案例<ul><li>Vue 双向绑定</li></ul></li></ul><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p><strong><em>对象有某个行为，但是在不同的场景中，该行为有不同的实现算法</em></strong></p><ul><li>案例<ul><li>登录鉴权，鉴权算法取决于用户的登录方式是手机、邮箱或者第三方的微信登录等等，而且登录方式也只有在运行时才能获取，获取到登录方式后再动态的配置鉴权策略</li></ul></li></ul><h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><ol><li>提供一致的遍历各种数据结构的方式，而不用了解数据的内部结构</li><li>提供遍历容器的能力而无需改变容器的接口</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端需要了解的数据结构</title>
      <link href="/2022/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
      <url>/2022/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul><li>主要求代码循环多少次</li><li>最好时间复杂度</li><li>最坏时间复杂度</li></ul><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li>线性表</li><li>内存空间连续</li><li>成员类型相同</li></ul><h3 id="根据下标查找的时间复杂度为-O-1"><a href="#根据下标查找的时间复杂度为-O-1" class="headerlink" title="根据下标查找的时间复杂度为 O(1)"></a>根据下标查找的时间复杂度为 O(1)</h3><h3 id="高效的随机访问"><a href="#高效的随机访问" class="headerlink" title="高效的随机访问"></a>高效的随机访问</h3><h3 id="低效的插入和删除操作"><a href="#低效的插入和删除操作" class="headerlink" title="低效的插入和删除操作"></a>低效的插入和删除操作</h3><ul><li><p>插入</p><ul><li>为了把第 k 个位置腾出来，给新来的数据，我们需要将第 k ～ n 这部分的元素都顺序地往后挪一位</li></ul></li><li><p>删除类似</p></li><li><p>时间复杂度 O(n)</p></li></ul><h3 id="Java-ArrayList"><a href="#Java-ArrayList" class="headerlink" title="Java ArrayList"></a>Java ArrayList</h3><ul><li><p>支持动态扩容</p><ul><li>耗费性能</li><li>建议  预先指定数组大小</li></ul></li></ul><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><ul><li><p>通过指针将松散的内存块连在一起</p></li><li><p>链表节点除了存储数据，还要存储下个节点的地址</p></li><li><p>插入和删除数据的速度很快</p><ul><li>O(1)</li></ul></li><li><p> 随机访问很慢</p><ul><li>O(n)</li></ul></li></ul><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><ul><li>每个  节点不止有一个后续指针 ，还有一个前驱指针指向前面的节点</li><li>占用更多的空间</li><li>插入和删除  操作更高效</li></ul><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><ul><li>比单链表具有环形结构</li></ul><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><h3 id="O-logn"><a href="#O-logn" class="headerlink" title="O(logn)"></a>O(logn)</h3><h3 id="必须是有序的数组"><a href="#必须是有序的数组" class="headerlink" title="必须是有序的数组"></a>必须是有序的数组</h3><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul><li>O(n)</li></ul><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="树的种类"><a href="#树的种类" class="headerlink" title="树的种类"></a>树的种类</h3><ul><li><p>满二叉树</p></li><li><p>完全二叉树</p><ul><li>叶子节点都在最底下两层，最后一层的叶子节点都靠左排列</li><li>便于存储于数组</li></ul></li></ul><h3 id="二叉树存储"><a href="#二叉树存储" class="headerlink" title="二叉树存储"></a>二叉树存储</h3><ul><li><p>链式存储</p><ul><li>每个节点有三个字段</li><li>一个存储数据，另外两个存储左右子节点指针</li><li>图例</li></ul></li><li><p>数组存储</p><ul><li><p>我们把根节点存储在下标 i = 1 的位置，那左子节点存储在下标 2 _ i = 2 的位置，右子节点存储在 2 _ i + 1 = 3 的位置</p></li><li><p>图例</p></li><li><p>如果是非完全二叉树，会浪费更多的存储空间</p></li><li><p>如果某棵二叉树是一棵完全二叉树，那用数组存储无疑是最节省内存的一种方式</p><ul><li>也是为什么完全二叉树要求最后一层的子节点都靠左的原因</li></ul></li><li><p>数组顺序存储的方式比较适合完全二叉树，其他类型的二叉树用数组存储会比较浪费存储空间</p></li></ul></li></ul><h3 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h3><ul><li><p>深度优先遍历</p><ul><li><p>图例</p></li><li><p>前序遍历</p><ul><li>先打印当前，然后先左后右</li></ul></li><li><p>中序遍历</p><ul><li>先左，然后当前，后右</li></ul></li><li><p>后序遍历</p><ul><li>先左后右，最后当前节点</li></ul></li><li><p>具体实现</p><ul><li><p>递归法</p><ul><li>使用递归将 tree(object)的节点 push 到数组当中</li></ul></li><li><p>非递归法</p><ul><li>使用栈这个数据结构</li></ul></li></ul></li></ul></li><li><p>广度优先遍历</p><ul><li><p>按照层去遍历</p></li><li><p>步骤</p><ul><li>使用队列来实现</li><li>1 初始化一个队列，把根节点如队列</li><li>当队列为非空时，循环执行步骤 3 到 4，否则执行结束；</li><li>出队列取得一个结点，访问该结点；</li><li>若该结点的左子树为非空，则将该结点的左子树入队列，若该结点的右子树为非空，则将该结点的右子树入队列；</li></ul></li></ul></li></ul><h3 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h3><ul><li><p>支持动态数据集合的快速插入，删除，查找操作</p></li><li><p>树的任意一个节点，其左子树中的每个节点的值，要小于这个节点的值，右节点的值要大于这个节点的值</p></li><li><p>查找</p><ul><li>如果要查找的数据比根节点的值小，那就在左子树中递归查找；如果要查找的数据比根节点的值大，那就在右子树中递归查找</li></ul></li><li><p>插入</p><ul><li><p>如果要插入的数据比节点的数据大，并且节点的右子树为空，就将新数据直接插到右子节点的位置；如果不为空，就再递归遍历右子树，查找插入位置。同理，如果要插入的数据比节点数值小，并且节点的左子树为空，就将新数据插入到左子节点的位置；如果不为空，就再递归遍历左子树，查找插入位置。</p></li><li><p>值相同</p><ul><li>把相同的值放在同一个节点上</li><li>把值插入到右树</li></ul></li></ul></li><li><p>删除</p><ul><li><p>删除节点没有子节点</p><ul><li>置位 null</li></ul></li><li><p>删除节点只有一个子节点</p><ul><li>更新父节点，删除子节点</li></ul></li><li><p>删除节点有两个节点</p><ul><li>找到节点的右树中最小的节点，替换到要删除的节点</li></ul></li><li><p>还有一个方法</p><ul><li>单纯将要删除的节点标记为 已删除，但是并不真正从树中将节点删除</li></ul></li></ul></li><li><p>效率</p><ul><li>在二叉查找树中，查找、插入、删除等很多操作的时间复杂度都跟树的高度成正比。两个极端情况的时间复杂度分别是 O(n) 和 O(logn)，分别对应二叉树退化成链表的情况和完全二叉树。</li></ul></li></ul><h2 id="搜索算法"><a href="#搜索算法" class="headerlink" title="搜索算法"></a>搜索算法</h2><h3 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h3><ul><li><p>地毯式层层推进，从顶点开始，一次往外遍历</p></li><li><p>需要借助队列来实现</p></li><li><p>时间复杂度 O（E）</p><ul><li>E 表示边的个数</li></ul></li><li><p>空间复杂度 O（V）</p><ul><li>V 表示顶点个数</li></ul></li></ul><h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><ul><li><p>使用回溯思想，使用递归来实现</p><ul><li>借助栈来实现</li></ul></li><li><p>时间复杂度 O（E）</p></li><li><p>空间复杂度 O（V）</p></li></ul><h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><ul><li>O(n2)</li></ul><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><ul><li>O(N2)</li></ul><h3 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h3><ul><li><p>O(nlogn)</p></li><li><p>步骤</p><ul><li>随机选取数组中一个数 p</li><li>其他数比 p 大的一组，比 p 小的一组</li><li>递归调用以上步骤，最后合并</li></ul></li><li><p>循环实现和递归实现</p></li></ul><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><ul><li><p>O(nlogn)</p></li><li><p>分而治之的思想</p></li><li><p>两步走</p><ul><li>将数组分成两部分，并分别排序</li><li>将排序好的部分合并</li></ul></li></ul><h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><ul><li>O(n)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端需要了解的算法</title>
      <link href="/2022/04/19/%E7%AE%97%E6%B3%95/"/>
      <url>/2022/04/19/%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="评价标准"><a href="#评价标准" class="headerlink" title="评价标准"></a>评价标准</h3><ul><li><p>执行效率</p></li><li><p>原地排序</p><ul><li>空间复杂度是否是 O(1)</li></ul></li><li><p>稳定性</p><ul><li>对于值相等的元素，经过排序后，位置是否改变</li></ul></li></ul><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><ul><li>每次只操作相邻元素，看是否满足大小顺序</li><li>一次冒泡一个元素到达指定位置，要重复 N 次</li><li>第一次将最大的值放到最后</li></ul><h3 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h3><ul><li><p>最好</p><ul><li>O(N)</li></ul></li><li><p>最坏</p></li></ul><h3 id="原地排序"><a href="#原地排序" class="headerlink" title="原地排序"></a>原地排序</h3><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul><li>双层 for 循环</li></ul><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h3><ul><li><p>首先将数组分为已排序区间和未排序区间</p></li><li><p>取未排序区间的元素，在已排序区间找到合适的插入位置</p><ul><li>过程是比较和排序</li><li>比较的话从后往前比较</li></ul></li><li><p>插入数据</p></li><li><p>代码</p></li></ul><h3 id="效率-1"><a href="#效率-1" class="headerlink" title="效率"></a>效率</h3><ul><li><p>同冒泡排序</p></li><li><p>但是冒泡排序数据交换比插入排序的数据移动要复杂，赋值操作要更多</p><ul><li>所以要优于冒泡排序</li></ul></li></ul><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="过程-2"><a href="#过程-2" class="headerlink" title="过程"></a>过程</h3><ul><li>将数组分为已排序区间和未排序区间</li><li>每次都从未排序区间找到最小的元素，放到已排序区间末尾</li></ul><h3 id="效率-2"><a href="#效率-2" class="headerlink" title="效率"></a>效率</h3><ul><li>最好情况时间复杂度、最坏情况和平均情况时间复杂度都为 O(n2)</li></ul><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="效率-3"><a href="#效率-3" class="headerlink" title="效率"></a>效率</h3><ul><li><p>时间复杂度</p><ul><li><p>最好</p><ul><li>每次正好把数组分成大小接近相等的两个小区间</li></ul></li><li><p>最坏</p></li></ul></li><li><p>不是稳定的排序</p></li><li><p>原地排序</p></li></ul><h3 id="整体思想"><a href="#整体思想" class="headerlink" title="整体思想"></a>整体思想</h3><ul><li>分治 + 递归思想</li></ul><h3 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h3><ul><li><p>基本步骤</p><ul><li>选择一个元素作为基准点</li><li>将所有比基准小的放到左边，所有比基准大的放到右边</li><li>递归实现整个过程，最后合并</li></ul></li><li><p>JS 代码</p><ul><li>此时 空间复杂度为 O(N)</li><li>不是原地排序</li></ul></li></ul><h3 id="节省空间的方法"><a href="#节省空间的方法" class="headerlink" title="节省空间的方法"></a>节省空间的方法</h3><ul><li><p>过程图</p><ul><li>将数组元素和 pivot 标记的元素比较大小，决定要不要更换位置，最后更换标志位，让 pivot 放在中间</li></ul></li><li><p>实现代码</p></li><li><p>基本步骤</p><ul><li>初始化 i = -1</li><li>循环数组，找到比分割点小的数就将指针 i +1 ，然后与指针指向的数交换位置</li><li>循环结束后，最后将分割点与 i+1 位置的元素进行交换位置</li></ul></li></ul><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="非原地排序"><a href="#非原地排序" class="headerlink" title="非原地排序"></a>非原地排序</h3><h3 id="效率-4"><a href="#效率-4" class="headerlink" title="效率"></a>效率</h3><ul><li><p>空间复杂度</p><ul><li>O(N)</li></ul></li><li><p>时间复杂度</p><ul><li>稳定</li></ul></li></ul><h3 id="过程-3"><a href="#过程-3" class="headerlink" title="过程"></a>过程</h3><ul><li><p>使用递归思想</p><ul><li>先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>渲染优化</title>
      <link href="/2022/03/28/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96/"/>
      <url>/2022/03/28/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="浏览器渲染过程"><a href="#浏览器渲染过程" class="headerlink" title="浏览器渲染过程"></a>浏览器渲染过程</h2><ul><li><p>解析 HTML 生成 DOM tree</p></li><li><p>解析 CSS 生成 CSSOM Tree</p></li><li><p>JS 通过 DOM API 和 CSSOM API 来操作 DOM tree 和 CSS tree，浏览器将 DOM Tree 和 CSSOM Tree 合成 Render Tree</p></li></ul><h3 id="布局-layout"><a href="#布局-layout" class="headerlink" title="布局 layout"></a>布局 layout</h3><ul><li>根据生成的 RenderTree 计算每个节点的位置，大小，样式等等</li></ul><h3 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h3><ul><li>根据每个节点的位置信息，得到每个节点的绝对像素</li></ul><h3 id="展示"><a href="#展示" class="headerlink" title="展示"></a>展示</h3><ul><li>将像素信息发布到 GPU，展示到页面上</li></ul><h2 id="页面渲染技术架构"><a href="#页面渲染技术架构" class="headerlink" title="页面渲染技术架构"></a>页面渲染技术架构</h2><h3 id="服务端渲染"><a href="#服务端渲染" class="headerlink" title="服务端渲染"></a>服务端渲染</h3><ul><li><p>后端同步渲染 JSP</p><ul><li>先实现业务逻辑和数据，再输出 HTML</li><li>需求变更上线周期比较长</li></ul></li></ul><h3 id="客户端渲染"><a href="#客户端渲染" class="headerlink" title="客户端渲染"></a>客户端渲染</h3><ul><li><p>页面静态化</p><ul><li><p>生成静态 HTML 页面</p><ul><li>包含请求的数据</li></ul></li><li><p>提高页面访问速度，降低服务器负担</p></li><li><p>服务器存储占用问题</p></li><li><p>链接更新有问题</p></li><li><p>实现</p><ul><li>已有的动态内容生成静态页面</li></ul></li></ul></li><li><p>前后端分离</p></li><li><p>单页面应用</p><ul><li>SPA</li><li>首次加载时间较多</li></ul></li><li><p>BigPipe</p><ul><li>PHP?</li></ul></li><li><p>同构直出</p><ul><li>一套代码既可以在服务端运行也可以在客户端运行</li><li>降低首屏渲染时间</li><li>前端人员负责 前端和后端的开发</li></ul></li><li><p>PWA</p><ul><li>service worker</li><li>渐进式网络应用</li></ul></li></ul><h2 id="页面加载"><a href="#页面加载" class="headerlink" title="页面加载"></a>页面加载</h2><h3 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h3><ul><li>延迟加载</li><li>减少当前屏无效资源的加载</li><li>lazy-data</li></ul><h3 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h3><ul><li>preload,prefetch,preconnect</li></ul><h3 id="预渲染"><a href="#预渲染" class="headerlink" title="预渲染"></a>预渲染</h3><ul><li>prerender</li></ul><h3 id="按需加载"><a href="#按需加载" class="headerlink" title="按需加载"></a>按需加载</h3><ul><li>Router</li></ul>]]></content>
      
      
      <categories>
          
          <category> 性能优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>静态资源优化</title>
      <link href="/2022/03/25/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E4%BC%98%E5%8C%96/"/>
      <url>/2022/03/25/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="图片优化"><a href="#图片优化" class="headerlink" title="图片优化"></a>图片优化</h2><h3 id="图片分类"><a href="#图片分类" class="headerlink" title="图片分类"></a>图片分类</h3><ul><li><p>jpeg</p><ul><li>不支持透明度</li></ul></li><li><p>png</p><ul><li><p>无损压缩</p><ul><li>索引，灰度，Alpha 通道</li></ul></li><li><p>文件比 JPEG 大</p></li><li><p>支持 24 位和 8 位</p></li></ul></li><li><p>GIF</p><ul><li>适合动画或图标</li></ul></li><li><p>Webp</p><ul><li>体积小 质量高</li></ul></li></ul><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ul><li><p>不同网络环境下 加载不同尺寸的图片</p><ul><li>通过参数控制请求的图片大小</li></ul></li><li><p>逐步加载图片</p><ul><li><p>图片加载成功之前 占位符</p></li><li><p>LQIP</p><ul><li>首先加载低质量的图片</li><li>npm install lqip</li></ul></li><li><p>SQIP</p><ul><li>基于 SVG 的低质量图片</li><li>npm install sqip</li></ul></li></ul></li><li><p>Web Font 代替图片</p></li><li><p>Data URL 代替</p></li></ul><h3 id="图片服务器自动优化"><a href="#图片服务器自动优化" class="headerlink" title="图片服务器自动优化"></a>图片服务器自动优化</h3><h2 id="HTML-优化"><a href="#HTML-优化" class="headerlink" title="HTML 优化"></a>HTML 优化</h2><h3 id="文件放到合适位置"><a href="#文件放到合适位置" class="headerlink" title="文件放到合适位置"></a>文件放到合适位置</h3><ul><li><p>CSS 文件链接放到头部</p><ul><li>CSS 加载不会阻塞 DOM tree 解析，但是会阻塞 DOM tree 渲染，减少浏览器重排文档次数</li></ul></li><li><p>JS 引用放到底部</p><ul><li>JS 加载，解析执行阻塞渲染</li></ul></li></ul><h2 id="CSS-优化"><a href="#CSS-优化" class="headerlink" title="CSS 优化"></a>CSS 优化</h2><h3 id="提升-CSS-文件加载性能"><a href="#提升-CSS-文件加载性能" class="headerlink" title="提升 CSS 文件加载性能"></a>提升 CSS 文件加载性能</h3><ul><li>尽量使用外链 CSS</li><li>尽量避免使用 @import</li></ul><h3 id="合理使用-WebFont"><a href="#合理使用-WebFont" class="headerlink" title="合理使用 WebFont"></a>合理使用 WebFont</h3><h2 id="JS-优化"><a href="#JS-优化" class="headerlink" title="JS 优化"></a>JS 优化</h2><h3 id="事件节流"><a href="#事件节流" class="headerlink" title="事件节流"></a>事件节流</h3><h3 id="动画优化"><a href="#动画优化" class="headerlink" title="动画优化"></a>动画优化</h3><ul><li><p>CSS 动画</p></li><li><p>Canvas 动画</p></li><li><p>尽量使用 requestAnimationFrame</p><ul><li>可以在正确的时机运行</li></ul></li></ul><h3 id="缓存优化"><a href="#缓存优化" class="headerlink" title="缓存优化"></a>缓存优化</h3><ul><li><p>Cookie</p><ul><li>用户信息等</li><li>cookie 数据始终在同源的 http 请求中携带</li><li>cookie 数据不能超过 4k</li><li>cookie 只在设置的 cookie 过期时间之前一直有效</li><li>cookie 也是在所有同源窗口中都是共享的</li></ul></li><li><p>sessionStorage</p><ul><li>本地存储的键值对</li><li>仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持</li><li>sessionStorage 不在不同的浏览器窗口中共享，即使是同一个页面</li></ul></li><li><p>indexedDB</p><ul><li>索引数据库</li></ul></li><li><p>localStorage</p><ul><li>缓存静态文件内容</li><li>浏览在页面的具体位置</li><li>始终有效，窗口或浏览器关闭也一直保存</li><li>localStorage 在所有同源窗口中都是共享的</li></ul></li></ul><!-- ## 减少浏览器回流和重绘## 减少 DOM 操作## 静态文件压缩和打包 -->]]></content>
      
      
      <categories>
          
          <category> 性能优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端架构入门</title>
      <link href="/2022/03/19/%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84/"/>
      <url>/2022/03/19/%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="技术架构实施"><a href="#技术架构实施" class="headerlink" title="技术架构实施"></a>技术架构实施</h2><h3 id="技术准备期"><a href="#技术准备期" class="headerlink" title="技术准备期"></a>技术准备期</h3><ul><li>Poc 概念验证</li><li>创建应用脚手架</li><li>创建代码库</li><li>创建持续集成</li><li>形成代码规范</li><li>权限配置等</li></ul><h3 id="业务回补期"><a href="#业务回补期" class="headerlink" title="业务回补期"></a>业务回补期</h3><ul><li>追补业务</li><li>人员培训</li><li>扩大团队规模</li><li>形成文档</li></ul><h3 id="成长优化期"><a href="#成长优化期" class="headerlink" title="成长优化期"></a>成长优化期</h3><ul><li>偿还技术债务</li><li>提升代码质量</li><li>提升测试覆盖率</li><li>优化开发体验</li></ul><h2 id="工作流设计"><a href="#工作流设计" class="headerlink" title="工作流设计"></a>工作流设计</h2><h3 id="规范代码格式"><a href="#规范代码格式" class="headerlink" title="规范代码格式"></a>规范代码格式</h3><h3 id="规范命名"><a href="#规范命名" class="headerlink" title="规范命名"></a>规范命名</h3><h3 id="绘制项目架构图"><a href="#绘制项目架构图" class="headerlink" title="绘制项目架构图"></a>绘制项目架构图</h3><h3 id="项目文档化"><a href="#项目文档化" class="headerlink" title="项目文档化"></a>项目文档化</h3><ul><li><p>可编辑文档</p></li><li><p>可视化文档</p><ul><li>侧重管理代码质量</li></ul></li></ul><h3 id="看板工具"><a href="#看板工具" class="headerlink" title="看板工具"></a>看板工具</h3><ul><li>项目协作</li></ul><h3 id="提升代码质量"><a href="#提升代码质量" class="headerlink" title="提升代码质量"></a>提升代码质量</h3><ul><li><p>代码提交预处理</p></li><li><p>代码扫描</p><ul><li>sona</li></ul></li></ul><h3 id="测试策略"><a href="#测试策略" class="headerlink" title="测试策略"></a>测试策略</h3><ul><li>单元测试</li><li>组件测试</li><li>服务测试</li></ul><h2 id="构建流设计"><a href="#构建流设计" class="headerlink" title="构建流设计"></a>构建流设计</h2><h3 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h3><h3 id="包源管理"><a href="#包源管理" class="headerlink" title="包源管理"></a>包源管理</h3><h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><h3 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a>持续集成</h3><h2 id="微前端"><a href="#微前端" class="headerlink" title="微前端"></a>微前端</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>类似于微服务架构，将一个应用拆分成多个应用，独立开发，独立部署</li></ul><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><ul><li>遗留系统迁移</li><li>聚合前端应用</li></ul><h3 id="为什么不是-iframe"><a href="#为什么不是-iframe" class="headerlink" title="为什么不是 iframe"></a>为什么不是 iframe</h3><ul><li>iframe 最大的特性就是提供了浏览器原生的硬隔离方案，不论是样式隔离、js 隔离这类问题统统都能被完美解决。但他的最大问题也在于他的隔离性无法被突破，导致应用间上下文无法被共享，随之带来的开发体验、产品体验的问题。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端汇总</title>
      <link href="/2022/03/18/%E5%89%8D%E7%AB%AF%E5%A4%A7%E5%85%A8/"/>
      <url>/2022/03/18/%E5%89%8D%E7%AB%AF%E5%A4%A7%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="编程思想"><a href="#编程思想" class="headerlink" title="编程思想"></a>编程思想</h2><h3 id="架构模式"><a href="#架构模式" class="headerlink" title="架构模式"></a>架构模式</h3><ul><li>MVC</li><li>MVVM</li><li>MVP</li><li>Code Blocks</li><li>Code Behind</li></ul><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><ul><li>单例模式</li><li>工厂模式</li><li>策略模式</li><li>发布订阅模式</li><li>代理模式</li><li>命令模式</li><li>适配器模式</li><li>…..</li></ul><h3 id="编程范型"><a href="#编程范型" class="headerlink" title="编程范型"></a>编程范型</h3><ul><li>面向对象编程（OOP）</li><li>面向切面编程（AOP）</li><li>函数式编程</li><li>响应式编程</li></ul><h3 id="程序设计"><a href="#程序设计" class="headerlink" title="程序设计"></a>程序设计</h3><ul><li><p>结构化程序</p><ul><li>自顶而下</li><li>逐步求精</li><li>模块化</li><li>限制使用 goto</li></ul></li><li><p>面向对象程序</p><ul><li>单一功能原则（S）</li><li>开放关闭原则（O）</li><li>里氏替换原则（L）</li><li>接口隔离原则（I）</li><li>依赖反转原则（D）</li></ul></li></ul><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li><p>适配方案</p><ul><li><p>通过媒体查询</p></li><li><p>viewport 缩放</p><ul><li>简单、高效</li></ul></li><li><p>rem 布局</p><ul><li>动态设置根元素 font-size，等比缩放元素大小</li></ul></li></ul></li><li><p>lazyimage</p><ul><li>图片先用占位图表示，属性放到 data 里面</li><li>页面加载完成后，监听窗口滚动，</li><li>当图片出现在视口内，再赋予真实的地址</li></ul></li><li><p>移动端 300ms 延时</p></li><li><p>骨架屏</p></li></ul><h2 id="前端基础"><a href="#前端基础" class="headerlink" title="前端基础"></a>前端基础</h2><h3 id="HTML（5）"><a href="#HTML（5）" class="headerlink" title="HTML（5）"></a>HTML（5）</h3><ul><li>Canvas</li><li>SVG</li><li>Drag 、 drop 拖拽</li><li>Video、audio</li><li>web worker</li><li>localStorage、sessionStorage</li><li>navigator.geolocation.getCurrentPosition()<br>地理定位</li></ul><h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><ul><li><p>权重</p><ul><li><pre><code>!important&gt;行内样式&gt;ID选择器 &gt; 类选择器 | 属性选择器 | 伪类选择器 &gt; 元素选择器</code></pre></li></ul></li><li><p>盒模型</p><pre><code>- 将所有元素表示为一个矩形盒- 这个模型描述了元素所占空间的内容。</code></pre><p>每个盒子有四个边：外边距, 边框, 内填充边与 内容。 - 两种</p><pre><code>    - 标准        - box-sizing: content-box            - width = content    - IE        - box-sizing: border-box            - width = content+padding+margin        - IE盒模型用的最多，也是被推荐使用的</code></pre></li><li><p>流式布局</p><ul><li><p>以“块”和“内联”元素的最基础的自动排列方式</p></li><li><p>本质上是一系列的元素，都在布局中一起工作，项目了解，一旦脱离的流，就会独立的工作</p></li><li><p>规则</p><ul><li>按照先后位置从上而下布局</li><li>行内元素水平排列，占满一行后后换行</li><li>块级元素独占一行</li></ul></li></ul></li><li><p>选择器匹配规则</p><ul><li><p>从右向左</p></li><li><p>探究 CSS 解析原理</p><ul><li><a href="https://juejin.im/entry/5a123c55f265da432240cc90">https://juejin.im/entry/5a123c55f265da432240cc90</a></li></ul></li><li><p>css *号</p><ul><li><p>*可以继承</p></li><li><p>从后向前</p><ul><li>？</li></ul></li></ul></li></ul></li><li><p>定位方案</p><ul><li><p>浮动定位</p><ul><li>先按照普通流的位置出现</li><li>然后脱离文档流，根据浮动的方向尽可能的向左或右偏移</li></ul></li><li><p>绝对定位</p><ul><li>脱离普通流</li><li>不会影响其兄弟元素</li><li>具体坐标由决定定位的坐标决定</li></ul></li></ul></li><li><p>FC</p><pre><code>- 概念    - 格式化上下文    - 特定规则的区域，独立的容器和布局环境    - 一个封闭的大箱子，内部无论如何变化，都不会影响到外部- 分类    - IFC        - 高度            - 由包含元素的实际高度计算得出            - 不受竖直方向margin/padding影响    - BFC        - 规则            - 继承了普通流的定位规则            - 浮动                - 高度包含内部的浮动元素                - 不会与外部的浮动元素重叠            - 垂直方向的距离由margin决定。</code></pre><p>属于同一个 BFC 的两个相邻的 BlockBox 的 margin 会发生重叠。</p><pre><code>        - 创建            - 根元素 body            - overflow 值不为 visible 的块元素            - 浮动元素 float不为none            - 绝对定位元素                - position为absolute和fixed            - 行内块元素                - inline-block            - 弹性元素            - 网格元素        - 应用            - 外边距折叠（Margin collapsing）                - 有的译成外边距塌陷                - 规范                    - 相邻盒子(可以是兄弟或祖先关系？)的外边距可以结合成一个单独的外边距                - 发生情况                    - 属于同一个BFC的块级元素                    - 在normal flow的布局中                        - 也就是说绝对定位元素和浮动元素不会发生折叠                    - 垂直方向相邻                    - 块级盒子                        - 也就是说inline-block不会发生折叠                        - 也就是说水平方向不会发生折叠                - 解决                    - 放在个BFC中            - BFC可以包含浮动的元素                - 场景描述                    - 一个block元素中，包含一个浮动元素，此时block元素会失去高度                - 解决                    - 为block元素加入overflow:hidden属性，触发BFC                    - 那么容器就回包裹着元素            - 阻止被浮动元素覆盖              &lt;div style="height: 100px;width: 100px;float: left;background: lightblue"&gt;我是一个左浮动的元素&lt;/div&gt;              &lt;div style="width: 200px; height: 200px;background: #eee"&gt;我是一个没有设置浮动,              也没有触发 BFC 元素, width: 200px; height:200px; background: #eee;&lt;/div&gt;            - 两列布局    - GFC    - FFC</code></pre></li><li><p>position 和 zindex</p><ul><li>决定同一父元素中的同级子元素的垂直方向顺序</li><li>position 属性：relative、absolute、fixed</li></ul></li><li><p>常见行内元素和块级元素</p><ul><li><p>行内</p><ul><li>b, em, strong,</li><li>a, br, img, span, sub, sup</li><li>button, input, label, select, textarea</li></ul></li><li><p>块级</p><ul><li>canvas，div，dl，footer，form，h1，header，hr，p，pre，section，table，ul，li</li></ul></li></ul></li><li><p>inline 和 inline-block</p><pre><code>- inline    - 不会独占一行    - 多个相邻的行内元素会排列在同一行里，直到一行排列不下    - 设置width,height属性无效    - 水平margin、padding有效，</code></pre><p>垂直 margin、padding 无效</p><pre><code>- block    - 独占一行    - 默认情况下，block元素宽度自动填满其父元素宽度    - 可以设置width,height属性    - 设置margin和padding有效- inline-block    - 对象呈现为inline对象，但是对象的内容作为block对象呈现    - Margin?</code></pre></li><li><p>margin: 0 auto 水平居中原因</p><ul><li>水平方向独占一行</li><li>auto 是自动分配剩余空间的意思</li></ul></li><li><p>清除浮动</p><ul><li><p>利用 overflow 包裹浮动</p></li><li><p>clear</p><ul><li>利用伪元素（clearfix）</li><li>父元素结束标签之前插入清除浮动的块级元素</li><li>利用 clear 样式</li></ul></li></ul></li><li><p>css3 技巧</p><ul><li>vw、vh</li><li>calc</li><li>transition</li></ul></li><li><p>居中</p><ul><li><p>水平居中</p><ul><li><p>行内元素</p><ul><li>text-align: center</li></ul></li><li><p>块级元素</p><ul><li><p>定宽</p><ul><li>margin: 0 auto</li></ul></li><li><p>不定宽</p><ul><li>flex</li><li>inline-block + text-align:center</li></ul></li></ul></li></ul></li><li><p>垂直居中布局</p><ul><li><p>文本垂直居中</p><ul><li>line-height:height</li></ul></li><li><p>margin + translate</p></li><li><p>Relative + margin + top</p></li><li><p>表格</p><p>.box1{<br>display: table-cell;<br>vertical-align: middle;<br>text-align: center;<br>}</p></li><li><p>flex</p><ul><li><p>justify-content</p><ul><li>主轴</li></ul></li><li><p>align-center</p><ul><li>交叉轴</li></ul></li><li><p>margin: auto</p></li></ul></li></ul></li></ul></li><li><p>布局案例</p><ul><li><a href="https://github.com/hookex/layout">https://github.com/hookex/layout</a></li></ul></li></ul><h3 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h3><ul><li><p>XMLHttpRequest</p><ul><li><p>new XMLHttpRequest()</p></li><li><p>xhr.open</p></li><li><p>onload</p><ul><li>status == 200 || status == 304</li></ul></li></ul></li><li><p>dom 操作</p><ul><li><p>基础</p><ul><li><p>创建</p><ul><li>document.createElement</li><li>document.createTextNode</li></ul></li><li><p>删除</p><ul><li>removeChild</li></ul></li><li><p>修改</p><ul><li>insertBefore</li><li>replaceChild</li><li>appendChild</li></ul></li><li><p>查</p><ul><li>document.getElementById</li><li>document.querySelector</li></ul></li></ul></li><li><p>JS 交换两个节点如何实现</p><div id="parent">    <span id="a1">a</span>    <span id="b1">b</span></div><script>    let changeNode = document.getElementById("b1");    let existingnode= document.getElementById("a1");    let p= document.getElementById("parent");    p.insertBefore(changeNode,existingnode);</script></li></ul></li><li><p>创建对象</p><ul><li><p>{}</p></li><li><p>new</p><ul><li><p>模拟</p><ul><li><a href="https://gist.github.com/hookex/25eaf1338110cdcac24ea27f02d42de6#file-new-ts">https://gist.github.com/hookex/25eaf1338110cdcac24ea27f02d42de6#file-new-ts</a></li></ul></li></ul></li><li><p>Object.create(proto, [propertiesObject])</p><ul><li>Object.create(null) 无原型的对象</li></ul></li></ul></li><li><p>数组判断</p><ul><li>Array.isArray([])</li><li>Object.prototype.toString.apply([]) === “[object Array]”</li><li>[].constructor === Array</li><li>[] instanceof Array === true</li></ul></li><li><p>slice vs splice</p><ul><li><p>slice</p><ul><li>切片</li><li>return 选定的元素作为新的数组对象</li><li>不更改原始数组</li></ul></li><li><p>splice</p><ul><li>铰接</li><li>return 已删除的项</li><li>更改原始数组</li></ul></li></ul></li><li><p>for-in for-of</p><pre><code>- for-in    - 循环对象&amp;数组    - 循环只遍历可枚举属性    - 可枚举属性</code></pre><p>从构造函数原型中继承的属性（更接近原型链中对象的属性覆盖原型属性）。 - 如果你只要考虑对象本身的属性，而不是它的原型，那么使用 getOwnPropertyNames() 或执行 hasOwnProperty() 来确定某属性是否是对象本身的属性（也能使用 propertyIsEnumerable)</p><pre><code>- for-of    - 循环数组    - ES6新特性    - 不会循环对象的key，只会循环对象的value    - 遍历实现iterator接口</code></pre></li><li><p>箭头函数</p><ul><li>更简短&amp;不绑定 this</li><li>没有 this, arguments</li><li>不能用作构造函数</li></ul></li><li><p>ES6</p><ul><li><p>let</p><ul><li><p>暂时性死区</p><ul><li>存在，但是不让使用</li><li>所以提前使用会报错</li></ul></li></ul></li><li><p>const</p><ul><li>除了不能再赋值以外，和 let 相同</li></ul></li><li><p>块级作用域</p></li><li><p>=&gt;</p></li><li><p>解构</p></li><li><p>Set</p></li><li><p>map</p></li><li><p>symbol</p><ul><li>不可改变且唯一的</li><li>以被用做对象属性的键</li><li>对原始数据类型的隐式对象包装器。</li><li>可以用来避免被覆盖</li></ul></li><li><p>模板字符串</p></li><li><p>module</p><ul><li><p>和 CMD 的区别</p><ul><li><p>ES6</p><ul><li>静态分析</li><li>引用方式</li><li>异步</li></ul></li></ul></li></ul></li></ul></li><li><p>类型化数组</p><ul><li>通用的、固定长度的二进制数据缓冲区</li></ul></li><li><p>JS 开始执行时机</p><ul><li><p>window.load</p><ul><li>必须等待网页中所有内容加载完毕后才能执行</li></ul></li><li><p>ondomcontentloaded</p><ul><li><p>dom 结构绘制完毕后开始执行</p></li><li><p>$(document).ready</p><ul><li>封装了 ondomcontentready、ondomcontentloaded</li></ul></li></ul></li></ul></li><li><p>事件</p><ul><li><p>本质</p><ul><li><p>事件驱动</p><ul><li>浏览器中很多行为是异步</li></ul></li><li><p>会创建事件并放入执行队列，等待当前代码执行完成</p></li><li><p>GUI 渲染线程与 JS 引擎线程互斥</p></li></ul></li><li><p>绑定，监听，委托的区别</p><ul><li><p>绑定</p><ul><li>HTML 直接绑定</li><li>在 JavaScript 代码中绑定</li><li>绑定事件监听函数</li></ul></li></ul></li><li><p>事件委托</p><ul><li><p>一般来讲，会把一个或者一组元素的事件委托到它的父层或者更外层元素上，真正绑定事件的是外层元素，当事件响应到需要绑定的元素上时，会通过事件冒泡机制从而触发它的外层元素的绑定事件上，然后在外层元素上去执行函数。</p></li><li><p>好处</p><ul><li>减少重复工作</li><li>减少内存消耗</li></ul></li></ul></li><li><p>异步事件驱动</p><ul><li>浏览器有一个内部大消息循环，Event Loop（事件循环），会轮询大的事件队列并处理事件</li><li>只有前面的处理完毕了，空闲了才会执行这个事件</li></ul></li><li><p>事件流</p><ul><li><p>冒泡</p><ul><li>事件捕获</li><li>目标阶段</li><li>事件冒泡 （常用）</li></ul></li></ul></li><li><p>宏任务&amp;微任务</p><ul><li>promise &amp; setTimeout</li></ul></li></ul></li><li><p>js 异步操作</p><ul><li><p>回调函数</p><ul><li><p>执行一个函数时，在函数内部处理操作，把操作结果以参数形式传入回调函数中</p></li><li><p>坏处</p><ul><li>回调地狱</li><li>不利于阅读</li><li>不利于调整回调顺序</li></ul></li><li><p>好处</p><ul><li>代码清晰地表达出了执行关系</li></ul></li></ul></li><li><p>监听事件</p></li><li><p>定时器</p><ul><li>宏任务</li></ul></li><li><p>ajax</p><ul><li>Ajax 请求确实是异步的，这请求是由浏览器新开一个线程请求，事件回调的时候是放入 Event loop 单线程事件队列等候处理</li></ul></li><li><p>Promise</p><ul><li>标准</li><li>立即执行</li><li>微任务</li><li>同步的立即执行函数</li></ul></li><li><p>generator</p><ul><li>交出函数的执行权</li><li>调用 Generator 函数，会返回一个内部指针</li><li>next 方法的作用是分阶段执行 Generator 函数</li><li>流程不方便管理</li></ul></li><li><p>async/await</p><ul><li><p>好</p><ul><li>异步操作的同步写法</li></ul></li><li><p>坏</p><ul><li>反设计</li><li>容易引起性能问题</li></ul></li><li><p>async 返回一个 promise</p></li><li><p>await 让出线程，跳出 async 函数体</p></li><li><p>Generator/function* 来实现</p></li><li><p>await 是一个让出线程的标志。await 后面的表达式会先执行一遍，将 await 后面的代码加入到 microtask 中，然后就会跳出整个 async 函数来执行后面的代码。</p></li></ul></li><li><p>Observable</p></li><li><p>事件循环</p><ul><li>执行一个宏任务（栈中没有就从事件队列中获取）</li><li>执行过程中如果遇到微任务，就将它添加到微任务的任务队列中</li><li>宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）</li><li>当前宏任务执行完毕，开始检查渲染，然后 GUI 线程接管渲染</li><li>渲染完毕后，JS 线程继续接管，开始下一个宏任务（从事件队列中获取）</li><li></li></ul></li></ul></li><li><p>复制对象</p><ul><li><p>for-in</p></li><li><p>object.assign()</p><ul><li>浅拷贝</li></ul></li><li><p>JSON.parse(JSON.stringify(obj))</p><ul><li>方法不能用于复制用户定义的对象方法</li><li>不能用于复制循环引用对象。</li></ul></li><li><p>展开操作符(…)</p><ul><li>浅拷贝</li></ul></li><li><p>自实现</p><ul><li><a href="https://gist.github.com/hookex/25eaf1338110cdcac24ea27f02d42de6#file-copy-ts">https://gist.github.com/hookex/25eaf1338110cdcac24ea27f02d42de6#file-copy-ts</a></li></ul></li></ul></li><li><p>编解码</p><ul><li><p>escape</p><ul><li><p>已从 Web 标准中删除</p></li><li><p>对字符串进行编码，让计算机可以读取</p></li><li><p>编码集合</p><ul><li><p>除</p><ul><li>ASCII 字母和数字</li><li>ASCII 标点符号 - _ . ! ~ * ‘ ( )</li></ul></li></ul></li></ul></li><li><p>encode</p><ul><li><p>encodeURI</p><ul><li><p>把字符串作为 URI 进行编码</p></li><li><p>目的是对 URI 进行完整的编码</p></li><li><p>编码集合</p><ul><li><p>除</p><ul><li><p>非转义字符</p><ul><li>字母 数字 - _ . ! ~ * ‘ ( )</li></ul></li><li><p>保留字符</p><ul><li>; , / ? : @ &amp; = + $</li></ul></li><li><p>数字符号</p><ul><li><h1 id=""><a href="#" class="headerlink" title=""></a></h1></li></ul></li></ul></li></ul></li></ul></li><li><p>encodeURIComponent</p><ul><li><p>编码集合</p><ul><li><p>除</p><ul><li>字母 数字 - _ . ! ~ * ‘ ( )</li></ul></li><li><p>;/?:@&amp;=+$,# 这些用于分隔 URI 组件的标点符号</p><ul><li>十六进制的转义序列</li></ul></li></ul></li></ul></li></ul></li><li><p>decode</p><ul><li>docodeURI</li><li>decodeURIComponent</li></ul></li><li><p>为什么需要编解码？</p></li></ul></li><li><p>事件阻止</p><ul><li><p>阻止传播</p><ul><li><p>event.Propagation()</p><ul><li>W3C</li></ul></li><li><p>event.cancleBubble()</p><ul><li>IE</li></ul></li></ul></li><li><p>默认事件</p><ul><li><p>event.preventDefault()</p><ul><li>W3C</li></ul></li><li><p>return false</p><ul><li><p>原生 JS 事件</p><ul><li>阻止默认行为</li></ul></li><li><p>jQuery</p><ul><li>阻止默认行为</li><li>阻止冒泡</li></ul></li><li><p>W3c</p></li></ul></li><li><p>e.returnValue = false</p><ul><li>IE</li></ul></li></ul></li></ul></li><li><p>闭包</p><ul><li><p>定义</p><ul><li>函数和其相关引用对象组成的实体</li></ul></li><li><p>闭包原理</p><ul><li><p>从 schema 语言借鉴来</p></li><li><p>基础</p><ul><li>词法作用域</li><li>函数的变量作用范围可以超越创建的它的环境</li></ul></li><li><p>在一些语言中，函数可以嵌套函数，当内部函数引用了外部函数的变量时，就有可能会形成闭包</p></li><li><p>由于有引用，不会被垃圾回收</p></li></ul></li><li><p>弊端</p><ul><li>内存占用过多</li></ul></li><li><p>应用场景</p><ul><li><p>模仿块级作用域</p><ul><li>settimeout 拿到正确的值</li></ul></li><li><p>创建私有变量</p></li><li><p>封装相关的功能集</p><ul><li>模块化</li><li>jquery</li></ul></li><li><p>设计单例模式？</p></li><li><p>惰性求值？</p></li></ul></li></ul></li><li><p>上下文</p><ul><li><p>变量对象</p><ul><li>变量 (var, 变量声明);</li><li><pre><code>函数的形参</code></pre></li><li><pre><code>函数声明 (FunctionDeclaration, 缩写为FD);</code></pre></li></ul></li><li><p>作用域链</p><ul><li><p>本质</p><ul><li><p>是指向变量对象的指针列表</p><ul><li><p>变量对象</p><ul><li>arguments</li><li>this</li><li>局部属性和方法</li></ul></li></ul></li></ul></li><li><p>定义</p><ul><li>每个函数都有自己的执行环境</li><li>当代码在一个环境中执行时，会创建作用域链</li></ul></li><li><p>作用</p><ul><li>保证对执行环境的所有变量和函数的有序访问</li></ul></li><li><p>链</p><ul><li><p>前端</p><ul><li>当前代码所在环境的的变量对象</li></ul></li><li><p>下一个变量，来自外部执行环境</p></li><li><p>最外层为全局执行环境</p><ul><li><p>作用域链的尽头</p><ul><li><p>node</p><ul><li>global</li></ul></li><li><p>web</p><ul><li>window</li></ul></li></ul></li></ul></li></ul></li><li><p>变量搜索</p></li><li><p>静态作用域</p></li></ul></li><li><p>this</p><ul><li><p>this 是面向对象的表示</p></li><li><p>通过对象调用</p></li><li><p>其它</p><ul><li>window</li></ul></li><li><p>本质</p><ul><li><p>this 引用的是函数据以执行的环境对象</p><ul><li><p>执行环境</p><ul><li><p>全局执行环境</p><ul><li><p>创建</p><ul><li>当执行流进入一个函数时，函数的执行环境就会被推入环境栈中</li></ul></li><li><p>销毁</p><ul><li>在函数执行完之后，栈将其环境弹出，该环境被销毁</li></ul></li><li><p>定义</p><ul><li>每个执行环境都有一个与之关联的变量对象</li><li>环境中定义的所有变量和函数都保存在这个对象中</li></ul></li></ul></li><li><p>函数执行环境</p><ul><li><p>函数调用时时</p><ul><li>函数入栈</li><li>创建执行环境</li><li>创建作用域链</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>原型</p><ul><li><p>两方面</p><ul><li><p>对 constructor 模式的改善</p><ul><li>对 constructor 模式的改善</li><li>避免重复定义</li></ul></li><li><p>设计思想</p><ul><li><p>JS 的设计思想</p><ul><li>不同于面向类，基于原型的语言是对实例友好的</li></ul></li><li><p>实现继承</p></li></ul></li></ul></li><li><p>铁三角</p><ul><li><p>实例</p><ul><li>prototype 指向原型对象</li><li>constructor 指向构造函数</li></ul></li><li><p>构造函数</p><ul><li>prototype 指向原型对象</li><li>constructor 指向构 Function</li></ul></li><li><p>原型对象</p><ul><li>constructor 指向构造函数</li><li>prototype 指向原型的原型</li></ul></li></ul></li><li><p>组合继承？</p></li><li><p>读写</p><ul><li><p>读</p><ul><li>先遍历自身的属性，如果没有一层层往上层寻找</li></ul></li><li><p>写</p><ul><li>如果原型存在该属性，则对该实例自身创建属性</li></ul></li></ul></li></ul></li></ul><h2 id="类库-框架"><a href="#类库-框架" class="headerlink" title="类库/框架"></a>类库/框架</h2><h3 id="工具库"><a href="#工具库" class="headerlink" title="工具库"></a>工具库</h3><ul><li><p>jQuery</p></li><li><p>Zepto</p></li><li><p>Bootstrap</p></li><li><p>RxJS</p><p>RxJS 是使用 Observables 的响应式编程的库，它使编写异步或基于回调的代码更容易。<br>RxJS 中数据的流向也是固定的，就是从发送者到订阅者<br>promise 相较于 Rxjs 而言功能更单一</p></li><li><p>Moment.js</p><p>JavaScript 日期处理类库</p></li><li><p>Animate.css</p></li><li><p>MUI</p></li><li><p>Layui</p></li></ul><h3 id="开发库-框架"><a href="#开发库-框架" class="headerlink" title="开发库/框架"></a>开发库/框架</h3><ul><li><p>Vue</p><ul><li><p>Vuex</p></li><li><p>Vue-router</p></li><li><p>Vue-cli</p></li><li><p>数据绑定</p><ul><li><p>实现原理</p><ul><li><p>数据劫持的方式来做数据绑定</p></li><li><p>方法</p><ul><li><p>Object.defineProperty()</p><ul><li>getter</li><li>setter</li></ul></li><li><p>notify</p></li><li><p>监听变化</p><ul><li><p>Watcher</p><ul><li>Observer</li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>UI 库</p><ul><li>Element UI</li><li>iView</li><li>mint-ui</li></ul></li></ul></li><li><p>React</p><ul><li><p>本质</p><ul><li>规范</li><li>接口</li></ul></li><li><p>生命周期</p><ul><li>shouldComponentUpdate</li><li>componentWillUpdate</li><li>componentDidUpdate</li><li>componentWillMount</li><li>componentDidMount</li><li>componentWillReciveProps</li><li>componentWillUnmout</li><li>shouldComponentUpdate</li><li>getSnapshotBeforeUpdate</li></ul></li><li><p>state 和 props</p><ul><li>state 是做为状态管理</li><li>而 props 相当于 api，由外界传入</li></ul></li><li><p>setState</p><ul><li><p>合并旧 state</p></li><li><p>放进 state 队列，等待更新</p><ul><li>集齐一批需要更新的组件然后一起更新</li></ul></li><li><p>updater</p><ul><li>react-dom</li></ul></li><li><p>render</p></li><li><p>reconciler</p></li><li><p>同步，但延后</p></li></ul></li><li><p>数组中的 key</p><ul><li>提高比对效率</li></ul></li><li><p>Virtual Dom</p><ul><li><p>可能非 MVVM 模式的必须选择</p></li><li><p>性能</p><ul><li>不一定比原生更快</li><li>同 MVVM 一样，速度在过得去的范围内</li></ul></li><li><p>virtual DOM</p><ul><li><p>原理</p><ul><li>本质上就是在 JS 和 DOM 之间做了一个缓存</li></ul></li><li><p>会跟踪每一个组件的依赖关系</p></li><li><p>弊端</p><ul><li>如果你的应用中，交互复杂，需要处理大量的 UI 变化，那么使用 Virtual DOM 是一个好主意。如果你更新元素并不频繁，那么 Virtual DOM 并不一定适用，性能很可能还不如直接操控 DOM。</li></ul></li><li><p>好处</p><ul><li>diff</li><li>抽象</li></ul></li><li><p>diff 算法</p></li></ul></li></ul></li><li><p>Redux</p><ul><li><p>Predictable State Container</p></li><li><p>三大原则</p><ul><li>单一数据源：state</li><li>state 只读：action</li><li>纯函数：reducer</li></ul></li><li><p>优势</p><ul><li><p>让视图层简单&amp;快照化</p></li><li><p>编程对数据的中心化处理</p></li><li><p>针对数据更易操作</p><ul><li>函数话编程</li><li>时间化</li><li>状态持久性</li></ul></li></ul></li></ul></li><li><p>Ant Design</p></li><li><p>diff 时间复杂度</p><ul><li><p>O(n)</p></li><li><p>问题定义：讲一棵树转换成另一颗树的最小操作数</p></li><li><p>新旧虚拟树比对，返回补丁对象</p></li><li><p>折中的算法</p><ul><li>两个不同类型的元素会产生不同的树</li><li>可以通过 key prop 来暗示哪些子元素在不同的渲染下保持稳定</li></ul></li></ul></li></ul></li><li><p>Angular</p><ul><li><p>脏值检查</p><ul><li><p>数据何时变化</p><ul><li>用户输入</li><li>请求服务端数据</li><li>定时事件</li></ul></li><li><p>监听变化</p><ul><li>使用 zone.js Monkey patch 的方式，监听所有异步事件</li></ul></li><li><p>变化检测</p><ul><li><p>新旧数据对比</p></li><li><p>angular 改善的脏检查</p><ul><li><p>组件树</p><ul><li><p>每个组件都有自己的变化检测器</p><ul><li>变化检测器树</li></ul></li></ul></li></ul></li><li><p>数据流自上而下</p><ul><li><p>高效</p></li><li><p>可预测</p><ul><li>相比之下，AngularJS 采用的是双向数据流，错综复杂的数据流使得它不得不多次检查，使得数据最终趋向稳定。理论上，数据可能永远不稳定。AngularJS 给出的策略是，脏检查超过 10 次，就认为程序有问题，不再进行检查。这个 10，我不知道它的给出依据是什么，也许是个经验值吧。</li></ul></li></ul></li><li><p>变化检测对象</p></li><li><p>定制变化检测</p></li></ul></li></ul></li><li><p>DI</p><ul><li><p>目标</p><ul><li><p>控制反转</p><ul><li><p>好处</p><ul><li>降低代码之间的耦合度</li></ul></li><li><p>每个对象都需要获取与其合作的对象（也就是它所依赖的对象）的引用。如果这个获取过程要靠自身实</p></li></ul></li></ul></li><li><p>实现方式</p><ul><li><p>依赖注入</p><ul><li>Injector 会自动帮你将需要的依赖注入到类的构造器里，并返回这个类的实例</li></ul></li></ul></li><li><p>使用的三个技术</p><ul><li>reflect-metadata</li><li>typescript</li><li>Decorator</li></ul></li></ul></li><li><p>数组绑定</p></li><li><p>生命周期</p><ul><li><p>ngOnChanges</p></li><li><p>ngOnInit</p></li><li><p>ngDoCheck</p></li><li><p>ngAfterContentInit</p><ul><li>在外来内容被投影到组件中之后/投影组件内容的变更检测之后调用</li></ul></li><li><p>ngAfterContentChecked</p></li><li><p>ngAfterViewInit</p><ul><li>初始化完/检测变更完组件视图及其子视图之后调用。</li></ul></li><li><p>ngAfterViewChecked</p></li><li><p>ngOnDestroy</p></li></ul></li></ul></li><li><p>Ember.js</p></li><li><p>Knockout.js</p></li><li><p>Backbone.js</p></li></ul><h2 id="领域分支"><a href="#领域分支" class="headerlink" title="领域分支"></a>领域分支</h2><h3 id="移动端"><a href="#移动端" class="headerlink" title="移动端"></a>移动端</h3><ul><li><p>H5 网页</p><p>唤起 App：<br>判断浏览器，动态加载对应浏览器的下载逻辑<br>通过 universal link、URL Scheme、a 标签、iframe 几种方式找出最适合这个浏览器的唤起方式。<br>如果下载了 App，就会走打开逻辑，如果没有下载则走下载逻辑。<br>如果已知不能唤起的浏览器引导其它浏览器打开</p><ul><li>例：微信里的网页</li></ul></li><li><p>Web App</p><ul><li><p>SPA（single page web application）</p><ul><li><p>SSR</p><p>服务端渲染（Server Side Render）：网页是通过服务端渲染生成后输出给客户端。</p><ul><li>Nuxt.js</li><li>Next.js</li></ul></li></ul></li><li><p>PWA（Progressive Web App）</p><p>Chrome 团队开发，”渐进式 Web App”（Progressive Web App，缩写 PWA）。<br>PWA 结合了最好的 Web 应用和最好的原生应用的用户体验。<br>它可以把网站缓存在手机里面，供离线时使用，还能在手机首屏生成图标，直接点击进入，并且有通知推送能力，也不带有浏览器的地址栏和状态栏，跟原生 App 的使用体验非常接近。<br>*&nbsp; 渐进式 &nbsp;- 每个用户都可用而不管选择什么样的浏览器，因为它们是以渐进式增强为核心原则构建的。<br>*&nbsp; 自适应 &nbsp;- 适应任何形态：桌面，移动设备，平板电脑或尚未出现的形式。<br>*&nbsp; 不依赖网络连接 &nbsp;-&nbsp;Service Workers 允许离线工作，或在低质量网络上工作。<br>*&nbsp; 类似于应用程序 &nbsp;- 使用应用程序风格的交互和导航，感觉像一个应用程序。<br>*&nbsp; 保持最新 &nbsp;- 得益于 service Woker 的更新进程，应用能始终保持最新状态。<br>*&nbsp; 安全 &nbsp;- 借助于 HTTPS，防止窥探，并确保内容没有被篡改<br>*&nbsp; 可发现 &nbsp;- 受益于 W3C 清单和 service Worker 注册作用域，搜索引擎可找到它们，可以识别为“应用程序”。<br>*&nbsp; 用户粘性 &nbsp;- 通过推送通知等功能让用户重返应用。<br>*&nbsp; 可安装 &nbsp;- 允许用户在主屏幕上“保留”他们认为最有用的应用程序，而无需经过应用程序商店。</p><ul><li>可链接 - 通过 URL 轻松共享，不需要复杂的安装。</li></ul><ul><li><p>Service Worker</p><p>位于客户端（浏览器）和服务器之间的代理。<br>如果浏览器支持 SW 并且已注册，则 SW 文件将在 ServiceWorkerGlobalScope 中运行，这是一个独立的执行线程，不具有 DOM 访问权限，也不会干扰 JS 主线程。 Service worker 生命周期事件包括。<br>安装 &nbsp;- 主要用来缓存静态资源（js，css，图片等）<br>激活 &nbsp;- 主要用于缓存管理<br>空闲<br>收发消息 &nbsp;- 处理后续页面加载的所有网络请求<br>终止 &nbsp;- 不使用时，节省内存</p></li></ul></li><li><p>例：扫码点餐</p></li></ul></li><li><p>hybrid App</p><ul><li><p>Native + WebView</p><ul><li>jsBridge</li></ul></li><li><p>Ionic 平台</p></li><li><p>Dcloud 平台</p></li><li><p>Cordova （PhoneGap 前身）</p></li><li><p>例：电商 App</p></li></ul></li><li><p>Web to Native</p><ul><li><p>React Native</p></li><li><p>Flutter</p></li><li><p>Weex</p><ul><li>WeexSDK</li></ul></li><li><p>Taro</p><p>Taro&nbsp; 是一套遵循 &nbsp;React&nbsp; 语法规范的 &nbsp; 多端开发 &nbsp; 解决方案。<br>采用与 React 一致的组件化思想，组件生命周期与 React 保持一致，同时支持使用 &nbsp;JSX 语法</p></li><li><p>uni-app</p></li></ul></li><li><p>小程序（微信/支付宝/百度/头条/QQ/钉钉）</p><ul><li>webview 渲染</li></ul></li><li><p>快应用（十大手机厂商，共同发布快应用标准）</p><ul><li>native 渲染</li></ul></li></ul><h3 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h3><ul><li><p>Canvas 2D</p><ul><li><p>Echarts</p></li><li><p>HighCharts</p></li><li><p>AntV</p><p>AntV 是蚂蚁金服全新一代数据可视化解决方案，致力于提供一套简单方便、专业可靠、无限可能的数据可视化最佳实践。</p></li></ul></li><li><p>SVG</p><ul><li>D3</li><li>Snap</li><li>Raphael</li></ul></li><li><p>WebGL</p><ul><li>Three.js</li></ul></li></ul><h3 id="前端微服务"><a href="#前端微服务" class="headerlink" title="前端微服务"></a>前端微服务</h3><p>使用 HTTP 服务器的路由来重定向多个应用<br>在不同的框架之上设计通讯、加载机制，诸如 &nbsp;Mooa&nbsp; 和 &nbsp;Single-SPA<br>通过组合多个独立应用、组件来构建一个单体应用<br>iFrame。使用 iFrame 及自定义消息传递机制<br>使用纯 Web Components 构建应用<br>结合 Web Components 构建</p><ul><li>Egg.js</li></ul><h3 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h3><ul><li><p>性能体验质量等较高的层面往下回答解决方案</p></li><li><p>设计思路</p><ul><li><p>面向问题的分析</p><ul><li>发现可以做的事情</li><li>解决什么问题</li><li>ROI</li></ul></li><li><p>规划</p><ul><li><p>项目设计（明确重点）</p><ul><li><p>性能</p><ul><li>量化</li><li>链路分析</li></ul></li><li><p>体验</p></li><li><p>质量</p></li><li><p>分层</p></li><li><p>工程</p></li><li><p>效率</p></li></ul></li><li><p>明确需要调用的资源</p></li><li><p>如何推广</p></li></ul></li><li><p>把控过程</p><ul><li><p>排期</p><ul><li>时间</li><li>难度</li><li>任务量</li></ul></li></ul></li><li><p>事后</p><ul><li>推广</li><li>量化或质化分析</li></ul></li></ul></li><li><p>案例</p><h2 id="-1"><a href="#-1" class="headerlink" title="-"></a>-</h2><h2 id="-2"><a href="#-2" class="headerlink" title="-"></a>-</h2></li></ul><h3 id="WebAssembly"><a href="#WebAssembly" class="headerlink" title="WebAssembly"></a>WebAssembly</h3><h3 id="复杂性管理"><a href="#复杂性管理" class="headerlink" title="复杂性管理"></a>复杂性管理</h3><ul><li><p>概念</p><ul><li>相互作用的成分组成的系统</li></ul></li><li><p>应对</p><ul><li>较优选择、逐渐认知、相对有序</li></ul></li><li><p>应用</p><ul><li><p>模型管理</p><ul><li><p>建模</p></li><li><p>实践</p><ul><li><p>开发技术栈</p></li><li><p>研发流程</p></li><li><p>基础库</p></li><li><p>工具栈</p></li><li><p>开发规范</p><ul><li>代码规范</li><li>Commit 规范</li><li>版本规范</li></ul></li><li><p>最佳实践</p></li><li><p>知识库</p></li></ul></li></ul></li><li><p>不确定性管理</p><ul><li><p>未来、预期和风险</p></li><li><p>实践</p><ul><li><p>奖惩规则明确</p></li><li><p>提高对未来的信息</p><ul><li>技术的积累</li><li>分享</li></ul></li></ul></li></ul></li><li><p>模块间效率管理</p><ul><li><p>实践</p><ul><li>团队如何分工</li><li>跨团队配合</li></ul></li></ul></li></ul></li><li><p>持续优化</p></li></ul><h3 id="web-游戏开发"><a href="#web-游戏开发" class="headerlink" title="web 游戏开发"></a>web 游戏开发</h3><ul><li>Cocos2d</li><li>Egret Engine</li></ul><h2 id="服务端分支"><a href="#服务端分支" class="headerlink" title="服务端分支"></a>服务端分支</h2><h3 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h3><ul><li>Express</li><li>Koa</li><li>Egg</li><li>压力测试</li></ul><h3 id="web-服务器"><a href="#web-服务器" class="headerlink" title="web 服务器"></a>web 服务器</h3><ul><li>Nginx</li><li>Apache</li><li>Tomcat</li></ul><h3 id="数据库模型"><a href="#数据库模型" class="headerlink" title="数据库模型"></a>数据库模型</h3><ul><li><p>层次模型</p></li><li><p>网状模型</p></li><li><p>关系模型</p><ul><li><p>SQL</p><ul><li>MySQL</li><li>Oracle</li><li>SQL Server</li><li>…..</li></ul></li><li><p>NOSQL</p><ul><li>MongoDB</li><li>memcached</li><li>Redis</li><li>Cassandra</li><li>…..</li></ul></li></ul></li></ul><h2 id="全链路分支"><a href="#全链路分支" class="headerlink" title="全链路分支"></a>全链路分支</h2><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><ul><li>CommonJS</li><li>SeaJS/CMD</li><li>RequireJS/AMD</li><li>CSS Module</li><li>ES6 Module</li></ul><h3 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h3><ul><li>npm</li><li>Yarn</li><li>cnpm</li></ul><h3 id="构建工具"><a href="#构建工具" class="headerlink" title="构建工具"></a>构建工具</h3><ul><li><p>Webpack</p><ul><li><p>npm install</p><ul><li><p>查找</p><ul><li><p>寻找 package.json 并解析</p></li><li><p>执行勾子 preInstall</p></li><li><p>确定首层依赖</p><ul><li>从根节点（项目）进行多进程遍历</li></ul></li></ul></li><li><p>下载</p><ul><li><p>向指定源查找</p></li><li><p>确定语义化版本</p></li><li><p>和 lock 文件进行优先级比对</p></li><li><p>三个优先级</p><ul><li>项目 node_modules</li><li>.npm</li><li>网络</li></ul></li></ul></li><li><p>安装</p><ul><li><p>deduple</p><ul><li>去除冗余模块</li><li>扁平化处理</li></ul></li><li><p>安装模块</p><ul><li>更新 node_modules</li></ul></li><li><p>执行勾子 postInstall</p></li></ul></li></ul></li><li><p>webpack 热更新</p><ul><li><p>监听变化</p><ul><li>对变化模块进行打包编译</li><li>把编译后结果以 JS 对象形式写进内存</li></ul></li><li><p>通道传回</p><ul><li><p>建立 webpack-dev-server 和 websocket 的连接通道</p></li><li><p>传递消息</p><ul><li>变化模块 hash 值</li></ul></li></ul></li><li><p>更新代码</p><ul><li><p>HotMuduleReplacement</p><ul><li>接收到变化模块 hash 值</li></ul></li><li><p>JsonpMainTemplate</p><ul><li>根据 hash 集合，通过 jsonp 获取最新的模块代码</li></ul></li><li><p>如果热更失败，则退回到 live reload 操作</p></li></ul></li></ul></li><li><p>webpack loader 和 plugin 区别</p><ul><li><p>loader</p><ul><li>文件翻译器</li></ul></li><li><p>plugin</p><ul><li><p>扩展编译过程</p></li><li><p>在对应的事件节点定义操作</p><ul><li>资源管理</li><li>bundle 文件优化</li><li>输出信息</li></ul></li></ul></li></ul></li><li><p>webpack 模块化</p><ul><li>吸取了各个模块化的经验，把模块化的概念用于更多文件类型</li></ul></li><li><p>webpack 性能优化</p><ul><li>多进程处理</li><li>sourcemap 可选</li><li>编译成较新的 es 标准（ts 的）</li><li>缩小源文件定义范围</li><li>平衡压缩配置</li><li>平衡 eslint 配置</li><li>代码分割</li></ul></li><li><p>webpack vs rollup</p><ul><li><p>rollup</p><ul><li><p>tree-shaking</p></li><li><p>对 es6 支持好</p><ul><li><p>基于 2015 模块</p><ul><li>webpack 使用 CommonJS</li></ul></li></ul></li><li><p>更适合开发基础库</p></li></ul></li></ul></li><li><p>原理和思想</p><ul><li><p>核心是一个静态模块捆绑器，内部维护一个依赖关系图，映射每个模块并生成捆绑包</p></li><li><p>概念</p><ul><li>配置化</li><li>模块化</li><li>entry</li><li>loader</li><li>plugin</li><li>trunk</li></ul></li><li><p>过程</p><ul><li>模块依赖分析</li><li>webpack 处理</li><li>静态资源包</li></ul></li><li><p>WebPack 打包原理</p><ul><li><p>require</p><ul><li>根据 node 的规范封装的模块化</li></ul></li><li><p>名词</p><ul><li><p>loader</p><ul><li>模块转换器</li></ul></li><li><p>plugin</p><ul><li>自定义打包流程</li></ul></li></ul></li><li><p>过程</p><ul><li><p>准备</p><ul><li>加载所有插件</li></ul></li><li><p>确定入口文件</p></li><li><p>编译</p><ul><li>递归寻找模块依赖</li><li>调用 loader 对模块进行编译</li></ul></li><li><p>资源输出</p><ul><li>输出 chunk 文件</li></ul></li></ul></li></ul></li></ul></li><li><p>整套构建部署流程</p><ul><li><p>工作流平台</p><ul><li><p>gitlab | jenkins</p></li><li><p>DSL</p></li><li><p>runner</p><ul><li>考虑环境</li><li>是否容器化</li></ul></li></ul></li><li><p>pipline</p><ul><li><p>webhook</p></li><li><p>prepare</p></li><li><p>build</p></li><li><p>test</p><ul><li>unit test</li><li>安全检查</li></ul></li><li><p>deploy</p><ul><li>dev</li><li>prod</li></ul></li><li><p>rollback</p></li></ul></li></ul></li></ul></li><li><p>Gulp</p></li></ul><h3 id="语言增强"><a href="#语言增强" class="headerlink" title="语言增强"></a>语言增强</h3><ul><li><p>CSS</p><ul><li>Less</li><li>Sass（scss）</li><li>Stylus</li><li>Post css</li></ul></li><li><p>JavaScript</p><ul><li>TypeScript</li><li>CoffeeScript</li><li>Flow</li></ul></li></ul><h3 id="代码质量"><a href="#代码质量" class="headerlink" title="代码质量"></a>代码质量</h3><ul><li><p>自动化测试</p><ul><li>puppeteer</li></ul></li><li><p>单元测试</p></li><li><p>UI 测试</p></li><li><p>E2E 测试</p></li></ul><h3 id="转换器"><a href="#转换器" class="headerlink" title="转换器"></a>转换器</h3><ul><li>Babel</li><li>Traceur</li></ul><h3 id="CI-CD"><a href="#CI-CD" class="headerlink" title="CI / CD"></a>CI / CD</h3><ul><li>Git web hook</li><li>Jenkins</li></ul><h2 id="进阶分支"><a href="#进阶分支" class="headerlink" title="进阶分支"></a>进阶分支</h2><h3 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h3><ul><li><p>HTTP 应用层协议</p><ul><li><p>基本概念</p><ul><li><p>请求头</p><ul><li>request header</li></ul></li><li><p>响应头</p><ul><li>response header</li></ul></li><li><p>状态码</p><ul><li><p>分类</p><ul><li><p>1xx</p><ul><li><p>信息响应类</p></li><li><p>100</p><ul><li>服务端收到请求头，客户端应继续发送 body</li></ul></li></ul></li><li><p>2xx</p><ul><li><p>处理成功响应类</p></li><li><p>200</p><ul><li>请求成功</li><li>请求的内容，随此返回</li></ul></li></ul></li><li><p>3xx</p><ul><li><p>重定向响应类</p></li><li><p>301</p><ul><li>请求的资源已永久移到新位置</li></ul></li><li><p>304 Not Modifyed</p><ul><li>版本未修改</li><li>客户端仍有以前的副本，服务端无需传回资源</li></ul></li></ul></li><li><p>4xx</p><ul><li><p>客户端错误类</p></li><li><p>400</p><ul><li>客户端有语法错误，不能被服务器理解</li></ul></li><li><p>401 未授权</p></li><li><p>403 拒绝提供服务</p></li><li><p>404 资源不存在</p></li></ul></li><li><p>5xx</p><ul><li><p>通用错误消息</p></li><li><p>500</p><ul><li>服务端异常，没有给出具体信息</li></ul></li></ul></li></ul></li><li><p>解决了什么问题</p></li></ul></li><li><p>报文</p><ul><li><p>是什么</p><ul><li>承载多个请求参数的数据</li></ul></li><li><p>报文格式</p></li></ul></li><li><p>一次 http 完整的过程</p><ul><li><p>输入网址</p></li><li><p>根据 DNS，将域名解析为 IP 地址</p></li><li><p>建立 TCP 连接</p><ul><li>三次握手</li></ul></li><li><p>客户端发送报文</p></li><li><p>服务端应答</p><ul><li>服务端返回状态码和请求体</li></ul></li><li><p>关闭 TCP 连接</p></li></ul></li></ul></li><li><p>http2</p><ul><li><p>基于 google SPDY</p></li><li><p>多路复用</p><ul><li><p>相同域名请求，同一个 TCP 链接并发完成</p><ul><li>1.x keep alive 串行传输</li></ul></li><li><p>一个 TCP 连接分为若干流</p></li><li><p>一个流可以传输若干消息</p></li><li><p>每个消息由若干二进制 Frame 组成</p><ul><li>1.x 为文本格式</li></ul></li></ul></li><li><p>Hpack 头压缩</p></li><li><p>二进制传输</p></li><li><p>服务端推送</p></li><li><p>解决队头阻塞问题</p></li></ul></li><li><p>Accept - Encoding</p><ul><li><p>和性能有关，对 body 部分进行编码，达到压缩的目的</p></li><li><p>编码类型</p><ul><li><p>gzip</p><ul><li><p>好处</p><ul><li>节省空间</li></ul></li><li><p>弊端</p><ul><li>JPEG 这类文件用 gzip 压缩的不够好</li></ul></li></ul></li><li><p>compress</p></li><li><p>deflate</p><ul><li>zlib</li></ul></li></ul></li></ul></li><li><p>websocket</p><ul><li><p>使用 HTTP 101 状态码进行握手</p></li><li><p>持久性连接</p></li><li><p>双向通信</p></li><li><p>依赖 TCP 协议</p><ul><li>同 HTTP</li></ul></li><li><p>使用 HTTP Upgrade 头</p><ul><li>从 HTTP 协议更改为 WebSocket 协议</li></ul></li><li><p>优点</p><ul><li>较少的控制开销</li><li>更强的实时性</li><li>持久性</li><li>更好的二进制支持</li></ul></li></ul></li><li><p>异步请求和同步请求的区别</p><ul><li><p>异步请求</p><ul><li>并行处理</li><li>不等待</li></ul></li><li><p>同步请求</p><ul><li>顺序处理</li><li>等待</li></ul></li></ul></li><li><p>cookie &amp; session</p><ul><li><p>cookie</p><ul><li>服务器在本地机器上存储的小段文本</li><li>只能保管 ASCII 字符串</li><li>受浏览器安全策略限制</li><li>而 Cookie 保管在客户端，不占用服务器资源</li></ul></li><li><p>session</p><ul><li>服务器端的机制</li><li>任何类型的数据</li><li>Session 存储在服务器上，对客户端是透明的，不存在敏感信息泄露的风险</li><li>Session 是保管在服务器端的，每个用户都会产生一个 Session。假如并发访问的用户十分多，会产生十分多的 Session，耗费大量的内存</li></ul></li></ul></li><li><p>https？</p><ul><li><p>对称加密 + 证书颁发机构 CA</p></li><li><p>https 的信任基于预先安装在浏览器中的证书颁发机构</p><ul><li>我信任证书颁发机构我应该信任的</li></ul></li><li><p>HTTPS 报文中的任何东西都被加密，包括所有报头和荷载。</p></li><li><p>和 http 的差异</p><ul><li><p>端口</p><ul><li><p>http</p><ul><li>默认 80 端口</li></ul></li><li><p>https</p><ul><li>默认 443 端口</li></ul></li></ul></li></ul></li><li><p>加密</p><ul><li><p>对称加密</p><ul><li>加、解密用同一串秘钥</li><li>只有一个私钥</li></ul></li><li><p>非对称加密</p><ul><li>公钥、私钥</li><li>效率低</li></ul></li><li><p>中心化加密</p></li><li><p>去中心化加密</p></li></ul></li><li><p><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/74">https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/74</a></p></li><li><p>get</p><ul><li>参数也是加密的</li></ul></li><li><p>加密层：SSL/TSL</p></li></ul></li><li><p>请求方式</p><ul><li><p>get 和 post 区别</p><ul><li><p>同</p><ul><li>TCP 链接</li><li>底层是 TCP/IP</li><li>GET 和 POST 能做的事情是一样的</li></ul></li><li><p>定义</p><ul><li><p>get</p><ul><li>Get 是向服务器发索取数据的一种请求</li></ul></li><li><p>post</p><ul><li>Post 是向服务器提交数据的一种请求</li></ul></li></ul></li><li><p>不同</p><ul><li><p>长度</p><ul><li><p>get</p><ul><li><p>无长度限制</p><ul><li>但是浏览器会对 URL 厂区做出限制，2000 多个字符</li></ul></li></ul></li><li><p>post</p><ul><li><p>无长度限制</p><ul><li>大多数服务器最多处理 64K 大小的 url</li></ul></li></ul></li></ul></li><li><p>字符</p><ul><li><p>get</p><ul><li>ASCII 字符</li></ul></li><li><p>post</p><ul><li>没有限制</li></ul></li></ul></li><li><p>编码</p><ul><li><p>get</p><ul><li>application/x-www-form-urlencoded</li></ul></li><li><p>post</p><ul><li>POST 支持多种编码方式</li></ul></li></ul></li><li><p>安全</p><ul><li><p>get</p><ul><li>GET 参数直接暴露在 URL 上</li></ul></li><li><p>post</p><ul><li>POST 参数在 HTTP 消息主体中</li><li>不会被保存在浏览器历史</li></ul></li></ul></li><li><p>缓存</p><ul><li><p>get</p><ul><li>请求会被浏览器主动缓存</li></ul></li><li><p>post</p><ul><li>POST 不会</li></ul></li></ul></li><li><p>浏览器</p><ul><li>GET 请求参数会被完整保留在浏览器历史记录里</li><li>而 POST 中的参数不会被保留</li></ul></li><li><p>建立过程？</p><ul><li><p>产生一个 TCP 数据包</p><ul><li>浏览器会把 http header 和 data 一并发送出去，服务器响应 200（返回数据）</li></ul></li><li><p>产生两个 TCP 数据包</p><ul><li>浏览器先发送 header，服务器响应 100 continue</li><li>浏览器再发送 data，服务器响应 200 ok（返回数据）</li></ul></li><li><p><a href="https://zhuanlan.zhihu.com/p/25028045">https://zhuanlan.zhihu.com/p/25028045</a></p></li></ul></li></ul></li><li><p><a href="https://www.zhihu.com/question/20552352">https://www.zhihu.com/question/20552352</a></p></li></ul></li><li><p>请求类型</p><ul><li><p>get</p></li><li><p>post</p><ul><li>创建</li></ul></li><li><p>put</p><ul><li>更新</li></ul></li><li><p>delete</p></li><li><p>head</p><ul><li>仅仅返回相应的头部，没有具体的响应体。它也不会对服务器造成其他影响</li></ul></li><li><p>TRACE</p></li><li><p>options</p><ul><li>OPTIONS 允许客户端请求一个服务所支持的请求方法。它所对应的响应头是 Allow，它非常简洁地列出了支持的方法。下面为服务端成功处理了 OPTIONS 请求后，响应的内容：</li><li>Allow: HEAD,GET,PUT,DELETE,OPTIONS</li><li>发生时机？</li></ul></li><li><p>connect</p></li><li><p>用途？</p></li></ul></li></ul></li><li><p>跨域携带 cookie</p></li></ul></li><li><p>TCP/IP</p><ul><li><p>全双工通信</p><ul><li>输入通道</li><li>输出通道</li></ul></li><li><p>协议集</p><ul><li>应用层</li><li>传输层</li><li>网络层</li><li>网络访问层</li></ul></li><li><p>握手 &amp; 分手</p><ul><li><p>建立连接的最小安全次数</p></li><li><p>三次握手</p><ul><li><p>1 客户端 发起请求</p><ul><li>等待确认</li></ul></li><li><p>2 服务器收到消息 &amp; 发送确认请求</p><ul><li>等待状态</li></ul></li><li><p>3 客户端收到消息，发送确认包</p><ul><li>连接建立</li></ul></li></ul></li><li><p>四次分手</p><ul><li>1 客户端提出分手请求</li><li>2 服务端收到请求，关闭连接</li><li>3 并提出反方向关闭请求</li><li>4 客户端对服务端请求确认，双方向的关闭结束</li></ul></li><li><p>断开连接时服务器和客户端均可以主动发起断开 TCP 连接的请求</p></li></ul></li></ul></li></ul><h3 id="前端监控"><a href="#前端监控" class="headerlink" title="前端监控"></a>前端监控</h3><p>采集阶段、<br>储存阶段、<br>分析阶段、<br>报警阶段</p><ul><li><p>行为（数据）监控</p><ul><li>PV/PU(点击量/不同 IP 人数)</li><li>用户在每个页面的停留时间</li><li>用户通过什么入口访问该页面</li><li>用户在相应的页面中触发的行为</li></ul></li><li><p>异常监控</p><ul><li>1.服务端异常，2.浏览器抛出异常，3.样式加载异常</li></ul></li><li><p>性能监控</p><ul><li>不同用户、机型、系统下的首屏加载时间</li><li>白屏（骨架屏）时间</li><li>http 等请求的响应时间</li><li>静态资源整体下载时间</li><li>页面渲染时间</li><li>页面交互动画完成时间</li></ul></li></ul><h3 id="前端性能"><a href="#前端性能" class="headerlink" title="前端性能"></a>前端性能</h3><p>根据性能监测的结果可以进一步的去优化前端性能，比如兼容低版本浏览器的动画效果，加快首屏加载等</p><ul><li><p>性能指标</p><ul><li>首次绘制（FP）</li><li>首次内容绘制（FCP）</li><li>首次有效绘制（FMP）</li><li>每秒传输帧数（FPS）</li><li>DNS 解析时间</li><li>TCP 连接时间</li><li>HTTP 请求响应时间</li><li>用户可交互时间</li></ul></li><li><p>评估工具</p><ul><li>Page Speed</li><li>Lighthouse</li><li>Chrome dev tools</li></ul></li><li><p>性能优化</p><ul><li><p>页面加载链路优化</p><ul><li><p>网络</p><ul><li>缓存技术</li><li>负载均衡</li><li>压缩</li><li>优化协议（HTTP,HTTP2.TCP/IP）</li><li>CDN</li><li>HTTP 请求数量</li></ul></li><li><p>资源</p><ul><li>分包</li><li>压缩</li><li>懒加载</li><li>缓存</li><li>热加载&amp;离线包</li></ul></li><li><p>首屏</p><ul><li>首屏处理</li><li>外壳处理</li><li>拆分过程，并行处理</li></ul></li><li><p>构建</p><ul><li>压缩</li><li>分包</li><li>tree shaking</li><li>aot</li><li>并行处理</li></ul></li></ul></li><li><p>runtime 优化</p><ul><li><p>容器</p><ul><li><p>WKWebview</p></li><li><p>V8</p><ul><li>内联类</li></ul></li><li><p>wasm</p></li><li><p>RN</p></li><li><p>canvas</p></li><li><p>webgl</p></li><li><p>硬件加速</p></li></ul></li><li><p>语言层面</p><ul><li>CSS</li><li>JS</li></ul></li><li><p>框架层面</p></li><li><p>视觉</p><ul><li>动画</li></ul></li><li><p>交互</p><ul><li><p>避免重排重绘</p></li><li><p>fastclick</p><ul><li><p>解决问题</p><ul><li><p>300ms 延迟</p><ul><li><p>原因</p><ul><li>移动浏览器存在双击缩放或双击放大操作</li><li>第一次点击之后，系统需要等待 300ms，以判断用户是否再次点击了屏幕</li></ul></li></ul></li></ul></li><li><p>事件发生顺序</p><ul><li>touchstart</li><li>touchmove</li><li>touchend</li><li>click</li></ul></li><li><p>解决方法</p><ul><li><p>禁用缩放</p><ul><li>user-scalable=no</li><li>但同时也禁用了双指缩放操作</li></ul></li><li><p>更累默认视口宽度</p><ul><li><meta name="viewport" content="width=device-width"></li><li>仍可进行双指缩放操作</li></ul></li><li><p>指针事件</p><ul><li><p>pointerdown 事件</p></li><li><p>css touchaction: none</p><ul><li>是否触摸操作会触发用户代理的默认行为</li></ul></li></ul></li><li><p>zepto tap</p><ul><li>document</li><li>touch 事件</li><li>计算时间和位置差</li></ul></li><li><p>fastlick</p><ul><li>监听 touchend</li><li>发出自定义 click 事件</li><li>把原来的 click 事件阻止掉</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><ul><li><p>HTTP 劫持与对策</p><ul><li>https</li></ul></li><li><p>DOS 攻击</p><ul><li>阻断服务攻击</li><li>使网络和系统资源耗尽</li></ul></li><li><p>XSS 攻击与防御</p><ul><li><p>含义</p><ul><li>跨站脚本攻击</li></ul></li><li><p>方法</p><ul><li>恶意将未经过滤的代码植入到页面中</li></ul></li><li><p>分类</p><ul><li><p>反射性</p><ul><li>URL 到页面</li></ul></li><li><p>持久型</p><ul><li>数据库</li></ul></li></ul></li><li><p>避免</p><ul><li><p>常见符号编码转换</p><ul><li>&amp; &lt; &gt; “ ‘ /</li></ul></li><li><p>对诸如<script>、<img>、<a>等标签进行过滤</p></li><li><p>HttpOnly</p><ul><li>避免 cookie 劫持</li></ul></li></ul></li><li><p>HTML 属性、HTML 文字内容、HTML 注释、跳转链接、内联 JavaScript 字符串、内联 CSS 样式表等，所需要的转义规则不一致。 业务 RD 需要选取合适的转义库，并针对不同的上下文调用不同的转义规则。</p></li></ul></li><li><p>CSRF 攻击</p><ul><li><p>跨站请求伪造</p><ul><li>攻击者盗用了用户的身份，以用户的名义发送恶意请求</li><li>在不同的 domain 下，攻击者却能为造出”用户本人发出的 request“</li></ul></li><li><p>避免</p><ul><li><p>关键请求使用验证码或者 token 机制</p></li><li><p>验证码</p></li><li><p>在 HTTP 头中自定义属性并验证</p></li><li><p>Cross Site</p><ul><li>验证 HTTP Referer 字段</li><li>具体来说就是服务器每次返回客户端页面的时候，在页面中埋上一个 token 字段</li></ul></li><li><p>SameSite</p></li></ul></li><li><p>参考</p><ul><li><a href="https://blog.techbridge.cc/2017/02/25/csrf-introduction/">https://blog.techbridge.cc/2017/02/25/csrf-introduction/</a></li></ul></li><li><p>有了同源策略，为什么还会发生 csrf</p><ul><li><a href="http://tech.jiu-shu.com/Web-Applications-Technologies/web-security-csrf">http://tech.jiu-shu.com/Web-Applications-Technologies/web-security-csrf</a></li></ul></li></ul></li><li><p>接口如何防刷</p><ul><li>在 nginx 代理层控制 IP 限制调用次数</li><li>验证码</li><li>人机验证</li></ul></li></ul><h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><h3 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h3><ul><li><p>定义</p><ul><li>限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制</li></ul></li><li><p>协议，端口（如果有指定）和域名</p></li></ul><h3 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h3><ul><li><p>分类</p><ul><li><p>DNS 缓存</p></li><li><p>CDN 缓存</p></li><li><p>浏览器缓存</p><ul><li><p>强缓存</p><ul><li><p>cache-control</p><ul><li>no-cache</li><li>max-age=<seconds></li></ul></li><li><p>expires</p></li></ul></li><li><p>协商缓存</p><ul><li>Last-Modify</li><li>ETag</li></ul></li></ul></li></ul></li></ul><h3 id="渲染引擎"><a href="#渲染引擎" class="headerlink" title="渲染引擎"></a>渲染引擎</h3><ul><li><p>KHTML</p></li><li><p>Webkit</p><ul><li><p>排版引擎</p></li><li><p>01 年开始苹果</p></li><li><p>组件</p><ul><li><p>JS Core</p></li><li><p>webcore</p></li><li><p>Drosera</p><ul><li>调试工具</li></ul></li></ul></li><li><p>组成</p><ul><li><p>渲染引擎</p><ul><li>HTML 解释器</li><li>CSS 解释器</li><li>布局</li></ul></li></ul></li></ul></li><li><p>Blink</p><ul><li><p>blink</p><ul><li>13 年，webkit 的分支</li><li>V8</li></ul></li></ul></li></ul><h3 id="事件模型"><a href="#事件模型" class="headerlink" title="事件模型"></a>事件模型</h3><ul><li><p>DOM0 级模型</p><ul><li>事件不会传播，即没有事件流的概念</li><li>btn.onclick = fun;</li></ul></li><li><p>DOM2 级模型</p><ul><li><p>W3C 标准模型</p></li><li><p>三个阶段</p><ul><li>捕获</li><li>目标</li><li>冒泡</li></ul></li></ul></li></ul><h3 id="WebGL-渲染的过程？"><a href="#WebGL-渲染的过程？" class="headerlink" title="WebGL 渲染的过程？"></a>WebGL 渲染的过程？</h3><h3 id="页面加载"><a href="#页面加载" class="headerlink" title="页面加载"></a>页面加载</h3><ul><li><p>HTMl</p><ul><li>下载</li><li>解析</li><li>合并渲染</li></ul></li><li><p>CSS</p><ul><li>下载</li><li>解析</li><li>合并渲染</li></ul></li><li><p>JS</p><ul><li>下载</li><li>解释和执行</li></ul></li></ul><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><ul><li><p>概念</p><ul><li>像 C 语言一般都有自己的内存管理接口，JS 创建变量时分配内存，而不再使用时再释放内存。</li><li>在定义变量时完成内存分配</li></ul></li><li><p>方法</p><ul><li><p>引用计数</p><ul><li><p>问题定义</p><ul><li>对象有没有其它对象引用它</li></ul></li><li><p>优势</p><ul><li>算法简单</li><li>释放时间快</li></ul></li><li><p>劣势</p><ul><li>循环引用问题</li><li>对计数要求高</li><li>不能并行计算</li></ul></li></ul></li><li><p>标记清除</p><ul><li><p>问题定义</p><ul><li>对象是否可获得</li></ul></li><li><p>从根部开始遍历，找出不再使用的变量</p></li><li><p>阶段</p><ul><li><p>初始阶段</p></li><li><p>标记阶段</p><ul><li>JS 会停止运行</li></ul></li><li><p>清楚阶段</p></li></ul></li><li><p>V8</p><ul><li>增量标记</li></ul></li></ul></li></ul></li><li><p>堆内存</p><ul><li>全局变量</li><li>对象的引用</li><li>事件</li><li>定时器</li></ul></li><li><p>堆和栈的区别</p><ul><li><p>堆</p><ul><li>动态分配的内存，大小不定也不会自动释放</li><li>JS 中引用类型占据空间大、大小不固定，栈内存中存放地址指向堆内存中的对象。按引用访问</li></ul></li><li><p>栈</p><ul><li>自动分配的内存空间，由系统自动释放</li><li>基本类型占据空间小、大小固定，值保存在栈空间。按值来访问</li></ul></li></ul></li><li><p>内存泄漏实例？</p></li></ul><h3 id="浏览器和-Node-事件循环的区别"><a href="#浏览器和-Node-事件循环的区别" class="headerlink" title="浏览器和 Node 事件循环的区别"></a>浏览器和 Node 事件循环的区别</h3><ul><li><a href="https://muyiy.cn/question/browser/25.html">https://muyiy.cn/question/browser/25.html</a></li></ul><h3 id="JS-引擎"><a href="#JS-引擎" class="headerlink" title="JS 引擎"></a>JS 引擎</h3><ul><li><p>JS 引擎</p><ul><li><p>下载源代码</p><ul><li>并行解析</li><li>字节码缓存</li></ul></li><li><p>AST</p></li><li><p>字节码</p></li><li><p>JIT</p></li><li><p>机器码，执行</p></li></ul></li></ul><h3 id="输入-URL-到页面渲染的经历"><a href="#输入-URL-到页面渲染的经历" class="headerlink" title="输入 URL 到页面渲染的经历"></a>输入 URL 到页面渲染的经历</h3><ul><li><a href="http://fex.baidu.com/blog/2014/05/what-happen/">http://fex.baidu.com/blog/2014/05/what-happen/</a></li></ul><h3 id="HTML-加载过程？"><a href="#HTML-加载过程？" class="headerlink" title="HTML 加载过程？"></a>HTML 加载过程？</h3><ul><li><p>输入地址，返回 HTML，解析</p></li><li><p>解析 DOM</p><ul><li><p>遇到 body 标签</p><ul><li>加载并渲染 DOM</li></ul></li><li><p>浏览器遇到 dom 元素时，正常顺序加载，边加载边渲染</p></li><li><p>CSS</p><ul><li><p>内联 CSS</p><ul><li>浏览器继续加载，但渲染被阻塞</li><li>生成新的 CSS Rule Tree</li><li>生成后重新渲染界面</li></ul></li><li><p>外联 CSS</p><ul><li>并行下载</li><li>不会阻止 DOM 树解析</li><li>CSS 继续下载</li><li>会阻止渲染</li></ul></li></ul></li><li><p>JS</p><ul><li><p>内联 Javascript</p><ul><li><p>DOM 的加载和渲染同时被阻塞</p><ul><li>由于 JavaScript 有可能会更改 DOM Tree 和 Render Tree，因此同时被阻塞</li></ul></li></ul></li><li><p>外联 Javascript</p><ul><li>DOM 的加载和渲染同时被阻塞</li></ul></li><li><p>现代浏览器并行下载 JS 文件，以增强下载过程。但是他们也按照 dom 中出现的顺序解释和执行 JS。</p></li><li></li></ul></li></ul></li><li><p>render tree</p></li><li><p>layout</p></li><li><p>文档碎片？</p><ul><li>内存</li><li>合成一个 DOM？</li></ul></li></ul><h3 id="渲染过程"><a href="#渲染过程" class="headerlink" title="渲染过程"></a>渲染过程</h3><ul><li><p>JS 触发 reflow？</p><ul><li><p>过程</p><ul><li><p>JS 影响 Dom</p><ul><li>影响 DOM 变化，dom 树变化并解析</li></ul></li><li><p>JS 影响到 CSS</p><ul><li>影响 css 变化，css 树变化并解析</li></ul></li><li><p>两树合并</p><ul><li>生成一个渲染树，记录每个节点的布局和样式信息</li></ul></li><li><p>layout or reflow (option)</p><ul><li>计算每个 DOM 元素最终在屏幕上显示的大小和位置</li></ul></li><li><p>Paint</p><ul><li><p>为每个 dom 填充像素</p><ul><li>本质上就是填充像素</li><li>一个 DOM 的所有可能效果</li><li>这个绘制过程是在多个层上完成的。</li></ul></li><li><p>Composite</p><ul><li><p>渲染层合并</p><ul><li>在每个层上完成绘制过程之后，浏览器会将所有层按照合理的顺序合并成一个图层，然后显示在屏幕上</li></ul></li><li><p>完成绘制之后，浏览器会按照所有层顺序，合理的合并成一个图层，显示在屏幕上</p></li><li><p>某些特殊的渲染层会被认为是合成层（Compositing Layers），合成层拥有单独的 GraphicsLayer，</p></li></ul></li><li><p>调用图形接口</p></li></ul></li></ul></li><li><p>扩展</p><ul><li>某些特殊的渲染层会被认为是合成层（Compositing Layers），合成层拥有单独的 GraphicsLayer，而其他不是合成层的渲染层，则和其第一个拥有 GraphicsLayer 父层公用一个。</li><li>每个 GraphicsLayer 都有一个 GraphicsContext，GraphicsContext 会负责输出该层的位图，位图是存储在共享内存中，作为纹理上传到 GPU 中，最后由 GPU 将多个位图进行合成，然后 draw 到屏幕上，此时，我们的页面也就展现到了屏幕上。</li></ul></li><li><p><a href="http://taobaofed.org/blog/2016/04/25/performance-composite/">http://taobaofed.org/blog/2016/04/25/performance-composite/</a></p></li><li></li><li></li></ul></li><li><p>层压缩</p><ul><li><p>原因</p><ul><li>大量合成层来，而每个合成层都要消耗 CPU 和内存资源，岂不是严重影响页面性能</li></ul></li></ul></li></ul><h2 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h2><h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><p><a href="https://www.cnblogs.com/zyxnhr/p/11055797.html#_label0_1">https://www.cnblogs.com/zyxnhr/p/11055797.html#_label0_1</a></p><ul><li><p>OSI 七层模型</p><ul><li><p>应用层</p><ul><li>HTTP，FTP，DNS, SMTP，SNMP</li></ul></li><li><p>表示层</p></li><li><p>会话层</p></li><li><p>传输层</p><ul><li>TCP，UDP</li></ul></li><li><p>网络层</p><ul><li><pre><code>IP，ICMP，OSPF，EIGRP，IGMP</code></pre></li></ul></li><li><p>数据链路层</p><ul><li><pre><code>SLIP，CSLIP，PPP，MTU</code></pre></li></ul></li><li><p>物理层</p><ul><li>ISO2110，IEEE802，IEEE802.2</li></ul></li></ul></li><li><p>五层协议的体系结构</p></li></ul><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><ul><li><p>常用 PC</p><ul><li>Linux</li><li>Windows</li><li>Mac OS</li><li>UNIX</li></ul></li><li><p>常用 Mobile</p><ul><li>Android</li><li>IOS</li></ul></li></ul><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul><li>堆（Heap）</li><li>栈（Stack）</li><li>队列（Queue）</li><li>链表（Linked List）</li><li>数组（Array）</li><li>树（tree）</li><li>集合（Set）</li><li>哈希表（Map）</li></ul><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><ul><li><p>排序</p><ul><li>冒泡排序</li><li>插入排序</li><li>快速排序</li><li>选择排序</li><li>希尔排序</li><li>归并排序</li><li>堆排序</li></ul></li><li><p>检索</p><ul><li>线性查找</li><li>二分查找</li><li>索引</li><li>深度优先搜索（DFS）</li><li>广度优先搜索（BFS）</li></ul></li><li><p>Diff</p><ul><li>Element Diff</li><li>Tree Diff</li><li>Component Diff</li></ul></li></ul></script></p></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>应用层</title>
      <link href="/2022/02/10/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/%E5%BA%94%E7%94%A8%E5%B1%82/"/>
      <url>/2022/02/10/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/%E5%BA%94%E7%94%A8%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p><strong>基于 TCP</strong></p><h3 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h3><ul><li><p>请求行</p><ul><li><p>get</p><ul><li>查</li></ul></li><li><p>post</p><ul><li>增</li><li>创建一个资源</li></ul></li><li><p>put</p><ul><li>改</li></ul></li><li><p>delet</p><ul><li>删</li></ul></li></ul></li><li><p>首部字段</p><ul><li><p>key value 形式</p></li><li><p>content-type 等</p></li><li><p>Cache-control</p><ul><li>控制缓存</li></ul></li><li><p>if-Modified-Since</p><ul><li>判断服务器的资源是否更新</li></ul></li></ul></li></ul><h3 id="HTTP2-0"><a href="#HTTP2-0" class="headerlink" title="HTTP2.0"></a>HTTP2.0</h3><ul><li>对 http 头进行一定的压缩</li><li>分帧</li><li>多路复用等</li></ul><p><strong>QUIC 协议通过基于 UDP 自定义的类似 TCP 的连接、重试、多路复用、流量控制技术，进一步提升性能。</strong></p><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><ul><li>加密和解密的密钥相同</li><li>交互多的场景下多用对称加密</li></ul><h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><ul><li>机密和解密的密钥不同</li><li>客户端给服务器发送的时候，用服务器的公钥加密。而服务器给客户端发送消息的时候，使用客户端的公钥</li></ul><h3 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h3><ul><li>公钥和私钥主要用于传输对称加密的秘钥</li><li>双方大数据量的通信都是通过对称加密进行的</li></ul><h2 id="流媒体协议"><a href="#流媒体协议" class="headerlink" title="流媒体协议"></a>流媒体协议</h2><ul><li><p>视频压缩</p></li><li><p>视频编码</p><ul><li>H.264/MPEG-4 AVC</li><li>编码成二进制  格式</li></ul></li></ul><h2 id="DNS-协议"><a href="#DNS-协议" class="headerlink" title="DNS 协议"></a>DNS 协议</h2><ul><li><p>解析流程</p><ul><li>本地 DNS—根域名服务器—-顶级域名服务器—-权威域名服务器—-本地 DNS</li></ul></li><li><p>负载均衡</p><ul><li>域名解析的时候返回不同的 IP 地址，实现负载均衡</li></ul></li></ul><h2 id="HTTPDNS"><a href="#HTTPDNS" class="headerlink" title="HTTPDNS"></a>HTTPDNS</h2><ul><li><p>传统的 DNS 有很多问题，例如解析慢、更新不及时。因为缓存、转发、NAT 问题导致客户端误会自己所在的位置和运营商，从而影响流量的调度。</p></li><li><p>HTTPDNS 通过客户端 SDK 和服务端，通过 HTTP 直接调用解析 DNS 的方式，绕过了传统 DNS 的这些缺点，实现了智能的调度。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 通信协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> 协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Svg</title>
      <link href="/2022/02/03/Svg/"/>
      <url>/2022/02/03/Svg/</url>
      
        <content type="html"><![CDATA[<h2 id="pattern"><a href="#pattern" class="headerlink" title="pattern"></a>pattern</h2><h3 id="一个图案填充标签，可以在-pattern-中定义好图案，然后通过-id-引用来对某个图形进行填充"><a href="#一个图案填充标签，可以在-pattern-中定义好图案，然后通过-id-引用来对某个图形进行填充" class="headerlink" title="一个图案填充标签，可以在 pattern 中定义好图案，然后通过 id 引用来对某个图形进行填充"></a>一个图案填充标签，可以在 pattern 中定义好图案，然后通过 id 引用来对某个图形进行填充</h3><h3 id="使用-rect-来填充这个-pattern"><a href="#使用-rect-来填充这个-pattern" class="headerlink" title="使用 rect 来填充这个 pattern"></a>使用 rect 来填充这个 pattern</h3><h2 id="defs"><a href="#defs" class="headerlink" title="defs"></a>defs</h2><h3 id="定义一些可供重用的元素，组等"><a href="#定义一些可供重用的元素，组等" class="headerlink" title="定义一些可供重用的元素，组等"></a>定义一些可供重用的元素，组等</h3><h2 id="use"><a href="#use" class="headerlink" title="use"></a>use</h2><h3 id="用来使用-被定义的元素"><a href="#用来使用-被定义的元素" class="headerlink" title="用来使用 被定义的元素"></a>用来使用 被定义的元素</h3><h2 id="symbol"><a href="#symbol" class="headerlink" title="symbol"></a>symbol</h2><h3 id="定义一组可重用的元素"><a href="#定义一组可重用的元素" class="headerlink" title="定义一组可重用的元素"></a>定义一组可重用的元素</h3><h3 id="可以定义自己的视窗"><a href="#可以定义自己的视窗" class="headerlink" title="可以定义自己的视窗"></a>可以定义自己的视窗</h3><h2 id="textPath"><a href="#textPath" class="headerlink" title="textPath"></a>textPath</h2><h3 id="可以根据传入的-path-值来放置-text-文字"><a href="#可以根据传入的-path-值来放置-text-文字" class="headerlink" title="可以根据传入的 path 值来放置 text 文字"></a>可以根据传入的 path 值来放置 text 文字</h3>]]></content>
      
      
      <categories>
          
          <category> 可视化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> svg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通信协议</title>
      <link href="/2022/01/29/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/"/>
      <url>/2022/01/29/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><ul><li>DNS</li><li>HTTP、HTTPS</li></ul><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><ul><li>UDP</li><li>TCP</li></ul><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><ul><li>IP 协议</li></ul><h3 id="MAC-层"><a href="#MAC-层" class="headerlink" title="MAC 层"></a>MAC 层</h3><ul><li>网关</li><li>MAC 地址</li></ul><h3 id="DHCP-动态主机配置协议"><a href="#DHCP-动态主机配置协议" class="headerlink" title="DHCP 动态主机配置协议"></a>DHCP 动态主机配置协议</h3><ul><li>子网中动态配置 IP 地址</li></ul><h3 id="PXE-预启动执行环境"><a href="#PXE-预启动执行环境" class="headerlink" title="PXE 预启动执行环境"></a>PXE 预启动执行环境</h3>]]></content>
      
      
      <categories>
          
          <category> 通信协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> 协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>传输层</title>
      <link href="/2022/01/27/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
      <url>/2022/01/27/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/%E4%BC%A0%E8%BE%93%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h2 id="TCP-和-UDP-区别"><a href="#TCP-和-UDP-区别" class="headerlink" title="TCP 和 UDP 区别"></a>TCP 和 UDP 区别</h2><ul><li><p>TCP 面向连接，UDP 无连接</p></li><li><p>TCP 提供可靠交付，按顺序到达</p><ul><li>UDP 不保证不丢失</li></ul></li><li><p>TCP 面向字节流</p><ul><li>UDP 是基于 IP 包的，一个一个发，一个一个收</li></ul></li><li><p>TCP 有拥塞控制，意识到丢包或者网络不好了，会调整自己的行为</p></li></ul><h2 id="UDP-协议"><a href="#UDP-协议" class="headerlink" title="UDP 协议"></a>UDP 协议</h2><h3 id="包含"><a href="#包含" class="headerlink" title="包含"></a>包含</h3><ul><li>源端口，目标端口</li><li>UDP 长度 校验和</li></ul><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>沟通简单</li><li>安全性差</li><li>没有拥塞控制</li><li>可广播</li></ul><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><ul><li><p>对网络情况不敏感的场景</p><ul><li>内网</li></ul></li><li><p>可以广播的场景</p></li><li><p>具体</p><ul><li>QUIC 协议 网页或者 APP 访问</li><li>直播的视频传输协议</li><li>实时对战游戏</li><li>物联网</li></ul></li></ul><h2 id="TCP-协议"><a href="#TCP-协议" class="headerlink" title="TCP 协议"></a>TCP 协议</h2><h3 id="包含-1"><a href="#包含-1" class="headerlink" title="包含"></a>包含</h3><ul><li><p>源端口，目标端口</p></li><li><p>序号，确认序号</p></li><li><p>状态位</p></li><li><p>窗口大小</p><ul><li>做流量控制</li><li>拥塞控制</li></ul></li></ul><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><ul><li>请求—应答—-应答的应答</li></ul><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><ul><li>A—B</li><li>B—-A</li><li>B—A</li><li>A—B</li></ul><h3 id="TCP-状态机"><a href="#TCP-状态机" class="headerlink" title="TCP 状态机"></a>TCP 状态机</h3><h3 id="超时重试机制"><a href="#超时重试机制" class="headerlink" title="超时重试机制"></a>超时重试机制</h3><ul><li><p>超时间隔加倍</p><ul><li>每当遇到一次超时重传的时候，就会将下一次超时时间间隔设为先前值的两倍</li><li>两次超时，说明网络环境差</li></ul></li></ul><h3 id="流量控制问题"><a href="#流量控制问题" class="headerlink" title="流量控制问题"></a>流量控制问题</h3><h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><ul><li>TCP BBR 算法</li></ul><h2 id="Socket-套接字"><a href="#Socket-套接字" class="headerlink" title="Socket 套接字"></a>Socket 套接字</h2><ul><li>就是在应用层和传输层之间的一个抽象层，它把 TCP/IP 层复杂的操作抽象为几个简单的接口供应用层调用已实现进程在网络中通信</li></ul>]]></content>
      
      
      <categories>
          
          <category> 通信协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> 协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可视化</title>
      <link href="/2021/12/08/%E5%89%8D%E7%AB%AF%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
      <url>/2021/12/08/%E5%89%8D%E7%AB%AF%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%8F%AF%E8%A7%86%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="视觉"><a href="#视觉" class="headerlink" title="视觉"></a>视觉</h2><ul><li><p>理论基础</p></li><li><p>图形库和工具</p></li></ul><h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><ul><li><p>数据分析</p></li><li><p>数据处理</p></li><li><p>可视化设计</p></li></ul><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><ul><li><p>Canvas SVG webGL 性能优化</p></li><li><p>性能基准和性能检测的一般方法</p></li><li><p>海量数据处理新能优化</p></li></ul><h2 id="可视化工具"><a href="#可视化工具" class="headerlink" title="可视化工具"></a>可视化工具</h2><h3 id="图表库"><a href="#图表库" class="headerlink" title="图表库"></a>图表库</h3><ul><li>ECharts</li><li>chartlist</li><li>chart.js</li></ul><h4 id="地理库"><a href="#地理库" class="headerlink" title="地理库"></a>地理库</h4><ul><li>Mapbox</li><li>Leaflet</li><li>Deck.gl</li><li>CesiumJS</li></ul><h4 id="渲染库"><a href="#渲染库" class="headerlink" title="渲染库"></a>渲染库</h4><ul><li>ThreeJs</li></ul><h4 id="数据驱动框架"><a href="#数据驱动框架" class="headerlink" title="数据驱动框架"></a>数据驱动框架</h4><ul><li>D3.js</li><li>更专注于处理数据的组织形式</li></ul><h2 id="可视化实现"><a href="#可视化实现" class="headerlink" title="可视化实现"></a>可视化实现</h2><ol><li><p>HTML+CSS</p></li><li><p>SVG</p></li><li><p>Canvas2D</p></li><li><p>WebGL</p></li></ol><ul><li>GPU 能力</li><li>3D</li></ul><h2 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h2><ol><li><p>获取 context(‘2d’)</p></li><li><p>API</p></li></ol><ul><li><p>绘图状态</p></li><li><p>绘制命令</p><ul><li><p>context.translate</p><ul><li>画布平移转换</li></ul></li><li><p>context.save</p><ul><li>暂存状态</li></ul></li><li><p>context.restore</p><ul><li>恢复状态</li></ul></li></ul></li></ul><ol start="3"><li>过程</li></ol><ul><li>应当先处理数据，将数据内容与绘图指令建立映射关系，遍历数据，通过映射关系将数据内容的参数传给绘图指令</li></ul><h2 id="SVG"><a href="#SVG" class="headerlink" title="SVG"></a>SVG</h2><ol><li>创建 svg 元素</li></ol><ul><li>document.createElementNS()</li></ul><ol start="2"><li>更改元素属性</li></ol><ul><li>element.setAttribute()</li></ul><ol start="3"><li>优点</li></ol><ul><li>可以让图形的用户交互非常简单</li></ul><h2 id="WebGL"><a href="#WebGL" class="headerlink" title="WebGL"></a>WebGL</h2><ol><li><p>使用 WebGL 绘图，必须要和内存，GPU 打交道，控制图形输出的每一个细节</p></li><li><p>图形系统</p></li></ol><ul><li><p>光栅</p><ul><li>构成图像的像素阵列</li></ul></li><li><p>帧缓存</p><ul><li>像素信息被存放于帧缓存中</li></ul></li></ul><ol start="3"><li>绘制过程</li></ol><ul><li><p>创建 WebGL 上下文</p><ul><li>canvas.getContext(‘webgl’)</li></ul></li><li><p>创建 WebGL 程序</p><ul><li><p>GLSL 编程语言</p></li><li><p>两个着色器</p><ul><li><p>顶点着色器</p><ul><li>处理顶点的 GPU 代码，改变顶点的信息</li><li>计算出需要着色的像素点</li></ul></li><li><p>片元着色器</p><ul><li><p>处理光栅化后的像素信息</p></li><li><p>片元着色器对像素点着色的过程是并行的</p><ul><li>无论有多少个像素点，片元着色器都可以同时处理</li></ul></li></ul></li></ul></li></ul></li><li><p>将数据存入缓冲区</p><ul><li><p>首先定义顶点</p><ul><li>Float32Array 类型化数据</li></ul></li><li><p>将定义好的数据写入 WebGL 的缓冲区</p><ul><li>createBuffer</li><li>bindBuffer</li><li>bufferData</li></ul></li></ul></li><li><p>将缓冲区数据读取到 GPU</p></li><li><p>GPU 执行 WebGL 程序，输出结果</p><ul><li><p>gl.drawArrays()</p></li><li><p>gl_FragColor</p><ul><li>改变当前像素点颜色</li></ul></li></ul></li></ul><ol start="4"><li>顶点和图元</li></ol><ul><li><p>顶点</p><ul><li>几何图形的顶点</li></ul></li><li><p>图元</p><ul><li>WebGL 可直接处理的图形单元</li><li>由绘图模式决定</li><li>点，线，三角形等</li></ul></li></ul><ol start="5"><li><p>无论图形中有多少个像素点，着色器程序在 GPU 中会被同时执行多少次</p></li><li><p>顶点着色器</p></li></ol><ul><li><p>作用</p><ul><li><p>通过 gl_position 设置顶点</p></li><li><p>通过定义 varying 变量，向片元着色器传递数据</p><ul><li>通过给顶点映射不同的颜色，实现片元着色器渐变</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 可视化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 可视化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器</title>
      <link href="/2021/06/17/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
      <url>/2021/06/17/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF/%E6%B5%8F%E8%A7%88%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="构建过程"><a href="#构建过程" class="headerlink" title="构建过程"></a>构建过程</h2><ul><li><p>首先使用 HTTP 协议或者 HTTPS 协议，向服务器请求页面</p></li><li><p>请求回来的 HTML 代码经过解析，构建成 DOM 树</p></li><li><p>计算 DOM 树上的 CSS 属性</p></li><li><p>根据 CSS 属性对元素进行渲染，得到内存中的位图</p></li><li><p>可选步骤是对位图进行合并，极大提高后续绘制的速度</p></li><li><p>合成之后 绘制到界面上</p></li><li><p>注意</p><ul><li>不需要等到上一步骤完全结束，就开始处理上一步的输出</li></ul></li></ul><h2 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h2><h3 id="request"><a href="#request" class="headerlink" title="request"></a>request</h3><ul><li><p>request line</p><ul><li><p>method</p><ul><li><p>GET</p><ul><li>POST</li></ul></li><li><p>HEAD</p><ul><li>只返回请求头</li></ul></li><li><p>CONNECT</p><ul><li>多用于 HTTPS 和 WebSocket</li></ul></li><li><p>PUT</p><ul><li>DELETE</li></ul></li></ul></li><li><p>path</p></li><li><p>version</p></li></ul></li><li><p>head</p></li><li><p>body</p></li></ul><h3 id="response"><a href="#response" class="headerlink" title="response"></a>response</h3><ul><li><p>response line</p><ul><li><p>version</p></li><li><p>status code</p><ul><li><p>3**</p><ul><li><p>表示请求的目标有变化</p></li><li><p>301</p><ul><li>当前资源永久性转移</li></ul></li><li><p>302</p><ul><li>资源临时性转移</li></ul></li><li><p>304</p><ul><li>客户端本地的缓存版本，而且服务端  没有更新</li></ul></li></ul></li></ul></li><li><p>status text</p></li></ul></li><li><p>head</p></li><li><p>body</p></li></ul><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><ul><li><p>使用加密通道来传输 HTTP 的内容</p></li><li><p>首先与服务端建立一条 TLS 加密通道</p></li></ul><h2 id="HTTP2"><a href="#HTTP2" class="headerlink" title="HTTP2"></a>HTTP2</h2><ol><li>支持服务端推送</li></ol><ul><li>在客户端发送第一个请求到服务端时，提前把一部分内容推送给客户端，放入缓存当中</li></ul><ol start="2"><li>支持 TCP 连接复用</li></ol><ul><li>使用同一个 TCP 连接来传输多个 HTTP 请求，避免三次握手开销</li></ul><h2 id="DOM-树的构建过程"><a href="#DOM-树的构建过程" class="headerlink" title="DOM 树的构建过程"></a>DOM 树的构建过程</h2><h2 id="渲染-合成-绘制"><a href="#渲染-合成-绘制" class="headerlink" title="渲染 合成 绘制"></a>渲染 合成 绘制</h2>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重学前端</title>
      <link href="/2021/06/17/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF/"/>
      <url>/2021/06/17/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h2><h3 id="运行时"><a href="#运行时" class="headerlink" title="运行时"></a>运行时</h3><ul><li><p>数据结构</p><ul><li><p>类型</p><ul><li>对象</li></ul></li><li><p>实例</p><ul><li>应用和机制</li></ul></li></ul></li><li><p>执行过程</p><ul><li>事件循环</li><li>微任务的执行</li><li>函数的执行</li><li>语句级的执行</li></ul></li></ul><h3 id="文法"><a href="#文法" class="headerlink" title="文法"></a>文法</h3><ul><li>词法</li><li>语法</li></ul><h3 id="语义"><a href="#语义" class="headerlink" title="语义"></a>语义</h3><h2 id="HTML-和-CSS"><a href="#HTML-和-CSS" class="headerlink" title="HTML 和 CSS"></a>HTML 和 CSS</h2><h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><ul><li><p>元素</p><ul><li>文档元信息</li><li>语义相关内容</li><li>链接</li><li>替换型元素</li><li>表单</li><li>表格</li><li>总集</li></ul></li><li><p>语言</p><ul><li>实体</li><li>命名空间</li></ul></li><li><p>补充标准</p></li></ul><h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><ul><li><p>语言</p><ul><li>@rule</li><li>选择器</li><li>单位</li></ul></li><li><p>功能</p><ul><li><p>布局</p><ul><li>正常流</li><li>弹性布局</li></ul></li><li><p>绘制</p><ul><li>颜色和形状</li><li>文字相关</li></ul></li><li><p>交互</p><ul><li>动画</li><li>其他  交互</li></ul></li></ul></li></ul><h2 id="浏览器的实现原理和-API"><a href="#浏览器的实现原理和-API" class="headerlink" title="浏览器的实现原理和 API"></a>浏览器的实现原理和 API</h2><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><ul><li>解析</li><li>构建 DOM 树</li><li>计算 CSS</li><li> 渲染 合成 绘制</li></ul><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><ul><li>DOM</li><li>CSSOM</li><li>事件</li><li>API 总集合</li></ul><h2 id="前端工程实践"><a href="#前端工程实践" class="headerlink" title="前端工程实践"></a>前端工程实践</h2><ul><li><p>性能</p></li><li><p>工具链</p></li><li><p>持续集成</p></li><li><p>搭建系统</p></li><li><p>架构和基础库</p></li></ul><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><ol><li>页面加载性能</li></ol><ul><li><p>与用户留存有关</p></li><li><p>指标：秒开率</p><ul><li>一秒之内打开的用户占用户总量的百分比</li></ul></li></ul><ol start="2"><li><p>动画与操作性能</p></li><li><p>内存 电量消耗</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS</title>
      <link href="/2021/06/16/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF/JS/"/>
      <url>/2021/06/16/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF/JS/</url>
      
        <content type="html"><![CDATA[<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><ol><li><p>Undefined,Null,Boolean,String,Number,Symbol,Object</p></li><li><p>undefined 和 null</p></li></ol><ul><li><p>undefined</p><ul><li>表示未定义</li><li>一个变量，而非关键字</li></ul></li><li><p>null</p><ul><li>表示定义了但没赋值</li><li>关键字</li></ul></li></ul><ol start="3"><li>Number</li></ol><ul><li><p>浮点数的类型，无法使用==来比较</p><ul><li>console.log( 0.1 + 0.2 == 0.3); //false</li><li>可以检查最小精度来判断是否相等</li></ul></li></ul><ol start="4"><li>类型转换</li></ol><ul><li><p>StringToNumber</p><ul><li><p>parseInt()</p></li><li><p>parseFloat()</p></li><li><p>Number(‘1234’)</p><ul><li><p>不会忽略非数字字符</p><ul><li>返回 NaN</li></ul></li></ul></li></ul></li></ul><ol start="5"><li>装箱转换</li></ol><ul><li><p>将基本类型转换为对应的对象</p><ul><li>new Number()</li></ul></li><li><p>装箱机制会频繁产生临时对象</p></li><li><p>应该尽量避免对基本类型做装箱转换</p></li></ul><ol start="6"><li>拆箱转换</li></ol><ul><li><p>把对象变为基本类型，再从基本类型转换为对应的 String 或者 Number</p></li><li><p>ToPrimitive 函数</p></li><li><p>会尝试调用 valueOf 和 toString 来获得拆箱后的基本类型</p><ul><li>如果 valueOf 和 toString 都不存在，或者没有返回基本类型，则会产生类型错误 TypeError。</li></ul></li></ul><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><ol><li>JS 对象的特征</li></ol><ul><li>唯一标识性</li><li>对象有状态</li><li>具有行为</li></ul><p><strong>在 JavaScript 中，将状态和行为统一抽象为 属性</strong></p><ol start="2"><li>JS 对象的两类属性</li></ol><ul><li><p>数据属性</p><ul><li><p>value</p></li><li><p>writable</p><ul><li>决定是否被赋值</li></ul></li><li><p>enumerable</p><ul><li>决定  是否枚举该属性</li></ul></li><li><p>configurable</p><ul><li>决定该属性是否被删除或改变特征值</li></ul></li><li><p>Object.getOwnPropertyDescripter 来查看属性  特征值</p></li><li><p>可以使用 Object.defineProperty 来改变特征值</p></li></ul></li><li><p>访问器属性</p><ul><li>getter</li><li>setter</li><li>enumerable</li><li>configurable</li><li>访问器属性跟数据属性不同，每次访问属性都会执行 getter 或者 setter 函数</li></ul></li></ul><ol start="3"><li>函数对象和构造器对象</li></ol><ul><li><p>函数对象</p><ul><li>具有 call 私有字段</li></ul></li><li><p>构造器对象</p><ul><li>具有 construct 的对象</li></ul></li></ul><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p><strong>“基于原型”的编程看起来更为提倡程序员去关注一系列对象实例的行为，而后才去关心如何将这些对象，划分到最近的使用方式相似的原型对象，而不是将它们分成类</strong></p><h3 id="访问操作原型的方法"><a href="#访问操作原型的方法" class="headerlink" title="访问操作原型的方法"></a>访问操作原型的方法</h3><ul><li><p>Object.create</p><ul><li>根据指定原型创建对象</li></ul></li><li><p>Object.getPrototypeOf</p><ul><li>获得一个对象的原型</li></ul></li><li><p>Object.setPrototypeOf</p><ul><li>设置一个对象的原型</li></ul></li></ul><h2 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h2><h3 id="宏任务"><a href="#宏任务" class="headerlink" title="宏任务"></a>宏任务</h3><ul><li>宿主发起的</li></ul><h3 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h3><ul><li>JS 引擎发起的任务</li><li>微任务始终优先宏任务</li></ul><h3 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h3><ul><li>运行时基础是 Promise</li><li>async 函数必定返回 Promise</li></ul><h3 id="generator-iterator-并非异步代码"><a href="#generator-iterator-并非异步代码" class="headerlink" title="generator/iterator 并非异步代码"></a>generator/iterator 并非异步代码</h3><ul><li>只是在缺少 async/await 的时候，模拟 async/await</li></ul><h2 id="函数执行过程"><a href="#函数执行过程" class="headerlink" title="函数执行过程"></a>函数执行过程</h2><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><ul><li>闭包其实只是一个绑定了执行环境的函数</li><li>与普通函数的区别是 自带了执行环境</li></ul><h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><ul><li><p>var 的声明与赋值</p><ul><li>作用域是 函数</li></ul></li><li><p>let</p><ul><li>块级作用域</li></ul></li><li><p>Realm</p><ul><li>9.0 的标准</li><li>包含一组完整的内置对象，而且是复制关系</li><li>通过 iframe 等方式创建多 window 环境</li></ul></li><li><p>立即执行 的 函数表达式</p><ul><li>通过创建一个函数，并且立即执行，来构造一个新的域，从而控制 var 的范围</li></ul></li><li><p>with 关键字</p><ul><li>相当于构造了一个独立的执行环境</li><li>能够创建一个和外部环境同一个名字的变量</li></ul></li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h3><ul><li><p>执行上下文</p></li><li><p>普通函数的 this</p><ul><li>this 返回的并非函数本身，而是 当前函数的引用</li><li>调用函数的引用，决定了函数执行时的 this 值</li></ul></li><li><p>箭头函数的 this</p><ul><li>不论用什么引用来调用它，都不影响它的 this 值</li></ul></li><li><p>this 的模式</p><ul><li><p>thisMode 私有属性</p></li><li><p>lexical</p><ul><li>表示从上下文中找 this，这对应了箭头函数</li></ul></li><li><p>global</p><ul><li>当 this 为 undefined 时，取全局对象，对应了普通函数</li></ul></li><li><p>strict</p><ul><li>当严格模式时使用，this 严格按照调用时传入的值，可能为 null 或者 undefined</li></ul></li></ul></li></ul><h3 id="Bind-方法"><a href="#Bind-方法" class="headerlink" title="Bind 方法"></a>Bind 方法</h3><ul><li><p>允许我们在函数或者方法被调用时绑定 this 到指定对象上</p></li><li><p>明确指定方法中的 this 指向,并返回这个函数，方便后续调用</p></li><li><p>实现函数借用</p><ul><li><p>将一个对象上的函数 赋值 到另一个 对象上</p><ul><li>其中 另一个对象上 有 this 的引用</li></ul></li><li><p>借用函数的最佳实践应该是 使用 Apply 或者 Call 方法</p></li></ul></li><li><p>允许我们柯里化一个函数</p></li></ul><h3 id="Apply-和-Call-方法"><a href="#Apply-和-Call-方法" class="headerlink" title="Apply 和 Call 方法"></a>Apply 和 Call 方法</h3><ul><li><p>设置目标函数 this 的指向</p><ul><li><p>call</p><ul><li>第一个参数明确 this 指向，第二个参数传递给 目标函数</li></ul></li><li><p>apply 和 call 的用法几乎相同, 唯一的差别在于当函数需要传递多个变量时, apply 可以接受一个数组作为参数输入, call 则是接受一系列的单独变量</p></li></ul></li><li><p>使用 apply 或者 call 实现函数借用</p></li><li><p>立即调用这个函数而不是延迟调用</p></li><li><p>箭头函数下 apply 和 call 失效</p></li></ul><h3 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h3><ul><li>只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数</li><li>实例</li><li>lodash.curry(function)</li><li>柯里化 是一种转换，将 f(a,b,c) 转换为可以被以 f(a)(b)(c) 的形式进行调用。JavaScript 实现通常都保持该函数可以被正常调用，并且如果参数数量不足，则返回偏函数</li></ul><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p><strong>引用数据类型的拷贝</strong></p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li><p>Json.stringfy()</p><ul><li>数据量大的时候性能问题</li><li>遇到循环引用的对象会出错</li><li>一些类型无法拷贝</li></ul></li><li><p>Object.assign()</p><ul><li>只是在对象属性为基本数据类型时 深拷贝，对于引用数据类型 是浅拷贝</li></ul></li><li><p>递归的方式</p><ul><li>手写</li><li>循环引用的时候 栈溢出</li></ul></li><li><p>添加 map 做缓存的递归方法</p><ul><li>手写</li></ul></li></ul><h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><h3 id="var"><a href="#var" class="headerlink" title="var"></a>var</h3><ul><li>作用于脚本，模块和函数体</li></ul><h3 id="const-和-let"><a href="#const-和-let" class="headerlink" title="const 和 let"></a>const 和 let</h3><ul><li>如果当前作用域内有声明，就无法访问到外部的变量</li><li>如果当前作用域内有同名的变量，则无法访问外部同名的变量，</li></ul><h3 id="自执行函数"><a href="#自执行函数" class="headerlink" title="自执行函数"></a>自执行函数</h3><ul><li>构造新的作用域</li></ul><h3 id="function"><a href="#function" class="headerlink" title="function"></a>function</h3><ul><li><p>预处理在作用域中加入了变量，并且赋值</p></li><li><p>在作用域外，只增加了变量，没有赋值</p><ul><li>赋值行为发生在了执行阶段</li></ul></li><li><p>作用于脚本、模块和函数体级别</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML</title>
      <link href="/2021/06/14/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF/HTML/"/>
      <url>/2021/06/14/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF/HTML/</url>
      
        <content type="html"><![CDATA[<h2 id="语义类标签"><a href="#语义类标签" class="headerlink" title="语义类标签"></a>语义类标签</h2><h3 id="作为自然语言延伸的标签"><a href="#作为自然语言延伸的标签" class="headerlink" title="作为自然语言延伸的标签"></a>作为自然语言延伸的标签</h3><ul><li><p><code>&lt;em /&gt;</code></p></li><li><p>作为自然语言和纯文本的补充，用来表达一定的结构或者消除歧义</p></li></ul><h3 id="作为标题摘要的语义类标签"><a href="#作为标题摘要的语义类标签" class="headerlink" title="作为标题摘要的语义类标签"></a>作为标题摘要的语义类标签</h3><ul><li><p>有些时候，我们会有副标题，为了避免副标题产生额外的一个层级</p></li><li><hgroup><ul><li>避免副标题产生额外的层级</li></ul></hgroup></li></ul><h3 id="作为整体结构的语义类标签"><a href="#作为整体结构的语义类标签" class="headerlink" title="作为整体结构的语义类标签"></a>作为整体结构的语义类标签</h3><ul><li><p><code>&lt;header/&gt;</code></p><ul><li>通常出现在前部，表示导航或者介绍性的内容</li></ul></li><li><p><code>&lt;footer/&gt;</code></p></li><li><p><code>&lt;body/&gt;</code></p></li><li><p><code>&lt;nav/&gt;</code></p><ul><li>导航标签</li></ul></li><li><p><code>&lt;aside/&gt;</code></p><ul><li><p>表示跟文章主体不那么相关的部分，它可能包含导航、广告等工具性质的内容</p></li><li><p>例如 侧边栏</p><ul><li>侧边栏是 aside，aside 不一定是侧边栏</li></ul></li></ul></li></ul><h2 id="元信息类标签"><a href="#元信息类标签" class="headerlink" title="元信息类标签"></a>元信息类标签</h2><h3 id="head"><a href="#head" class="headerlink" title="head"></a>head</h3><ul><li>内容必须包含一个 title，并且最多只能包含一个 base</li></ul><h3 id="title"><a href="#title" class="headerlink" title="title"></a>title</h3><h3 id="base"><a href="#base" class="headerlink" title="base"></a>base</h3><ul><li>给页面所有的 URL 相对地址提供一个基础</li><li>它改变全局的链接地址，它是一个非常危险的标签，容易造成跟 JavaScript 的配合问题</li><li>建议你使用 JavaScript 来代替 base 标签</li></ul><h3 id="meta"><a href="#meta" class="headerlink" title="meta"></a>meta</h3><ul><li><p>通用的元信息表示标签</p></li><li><p>由 name 和 content 两个属性定义</p></li><li><p>name 为 charset</p><ul><li>描述了 HTML 文档自身的编码形式</li></ul></li><li><p>name 为 http-equiv</p><ul><li><p>表示执行一个命令</p></li><li><p>content-type</p><ul><li>相当于添加了 content-type 这个 http 头，并且指定了 http 编码方式</li></ul></li><li><p>content-language</p><ul><li>指定内容的语言</li></ul></li><li><p>default-style</p><ul><li>指定默认样式表</li></ul></li><li><p>refresh</p><ul><li>刷新</li></ul></li></ul></li><li><p>name 为 viewport</p><ul><li>name 为 viewport , content 为用逗号分隔的键值对</li><li>移动端适配</li></ul></li></ul><h2 id="链接类标签"><a href="#链接类标签" class="headerlink" title="链接类标签"></a>链接类标签</h2><h3 id="link"><a href="#link" class="headerlink" title="link"></a>link</h3><ul><li><p>超链接类的 link 标签</p><ul><li>被动型链接，在用户不操作时，不会主动下载</li><li>rel 属性不同 作用不同</li></ul></li><li><p>存在于 head 里</p></li><li><p>仅仅是元信息，不会显示在网页中</p></li><li><p>外部资源类标签</p><ul><li>会被主动下载</li></ul></li></ul><h3 id="a"><a href="#a" class="headerlink" title="a"></a>a</h3><ul><li>不会主动下载</li><li>解决了页面中插入文字型和整张图片超链接的需要</li></ul><h3 id="area-标签"><a href="#area-标签" class="headerlink" title="area 标签"></a>area 标签</h3><ul><li>区域型连接</li><li>必须跟 img 和 map 标签配合使用</li></ul><h2 id="DOM-API"><a href="#DOM-API" class="headerlink" title="DOM API"></a>DOM API</h2><h3 id="Element"><a href="#Element" class="headerlink" title="Element"></a>Element</h3><ul><li>HTML Element</li><li>SVG Element</li></ul><h3 id="Document"><a href="#Document" class="headerlink" title="Document"></a>Document</h3><h3 id="CharacterData"><a href="#CharacterData" class="headerlink" title="CharacterData"></a>CharacterData</h3><ul><li>Text</li><li>Comment</li><li>ProcessingInstruction</li></ul><h3 id="DocumentFragment"><a href="#DocumentFragment" class="headerlink" title="DocumentFragment"></a>DocumentFragment</h3><ul><li>文档片段</li><li>常常被用来高性能的批量添加节点</li></ul><h3 id="DocumentType"><a href="#DocumentType" class="headerlink" title="DocumentType"></a>DocumentType</h3><ul><li>文档类型</li></ul><h2 id="attribute-和-property-区别"><a href="#attribute-和-property-区别" class="headerlink" title="attribute 和 property 区别"></a>attribute 和 property 区别</h2><ol><li><p>attribute 是 HTML 标签上的特性，它的值只能够是字符串</p></li><li><p>property 是指对象的属性，HTML 的节点可以看做一个对象</p></li><li><p>attribute - &gt;property</p></li></ol><ul><li>数据单向同步</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS</title>
      <link href="/2021/06/12/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF/CSS/"/>
      <url>/2021/06/12/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF/CSS/</url>
      
        <content type="html"><![CDATA[<h2 id="规则"><a href="#规则" class="headerlink" title="@规则"></a>@规则</h2><h2 id="普通规则"><a href="#普通规则" class="headerlink" title="普通规则"></a>普通规则</h2><ol><li><p>选择器</p></li><li><p>声明区</p></li></ol><ul><li><p>属性</p></li><li><p>值</p><ul><li><p>双中线开头的属性被当做变量</p></li><li><p>值的函数</p><ul><li><p>calc()</p><ul><li>基本的表达式计算</li></ul></li><li><p>min()</p><ul><li>max()</li></ul></li><li><p>clamp()</p></li><li><p>toggle()</p><ul><li>在规则选中多于一个元素时生效，它会在几个值之间来回切换</li></ul></li><li><p>attr()</p><ul><li>允许 CSS 接受属性值的控制</li></ul></li></ul></li></ul></li></ul><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><ol><li><p>优先规则</p></li><li><p>伪元素</p></li></ol><ul><li><p>::first-line</p><ul><li>第一行的元素属性</li></ul></li><li><p>::first-letter</p></li><li><p>::before</p><ul><li>表示在元素之前插入一个虚拟元素</li></ul></li><li><p>::after</p><ul><li>表示在元素之后插入一个虚拟元素</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WebApi</title>
      <link href="/2021/06/01/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/WebApi/"/>
      <url>/2021/06/01/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/WebApi/</url>
      
        <content type="html"><![CDATA[<h2 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a>setTimeout</h2><ol><li><p>在 Chrome 中除了正常使用的消息队列之外，还有另外一个消息队列，这个队列中维护了需要延迟执行的任务列表，包括了定时器和 Chromium 内部一些需要延迟执行的任务</p></li><li><p>延迟队列的执行时机</p></li></ol><ul><li>当处理完消息队列中的一个任务之后，执行 ProcessDelayTask 函数。ProcessDelayTask 函数会根据发起时间和延迟时间计算出到期的任务，然后依次执行这些到期的任务</li></ul><ol start="3"><li><p>循环嵌套 timeout 的情况 最小调用间隔 4ms</p></li><li><p>未激活的页面，setTimeout 执行最小间隔 1000ms</p></li><li><p>setTimout 中的 this 将指向全局</p></li></ol><ul><li><p>严格模式下为 undefined</p></li><li><p>解决方案</p><ul><li>使用 bind(this)</li><li>放在匿名函数中执行</li></ul></li></ul><h2 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</h2><h3 id="异步回调"><a href="#异步回调" class="headerlink" title="异步回调"></a>异步回调</h3><ul><li>由浏览器的其他进程或者线程去执行，然后再将执行结果利用 IPC 的方式通知渲染进程，之后渲染进程再将对应的消息添加到消息队列中</li></ul><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li>跨域问题</li><li>混合内容问题</li></ul><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><h3 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h3><ul><li>消灭嵌套调用</li><li>合并多个任务的错误处理</li><li>本质 解决回调地狱</li></ul><h3 id="手写代码"><a href="#手写代码" class="headerlink" title="手写代码"></a>手写代码</h3><h3 id="Promise-和-微任务"><a href="#Promise-和-微任务" class="headerlink" title="Promise 和 微任务"></a>Promise 和 微任务</h3><ul><li>由于采用了回调函数延迟绑定</li><li>所以在执行 resolve 函数的时候，回调函数还没有绑定，那么只能推迟回调函数的执行</li><li>Promise 之所以要使用微任务是由 Promise 回调函数延迟绑定技术导致的</li></ul><h2 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h2><h3 id="生成器函数"><a href="#生成器函数" class="headerlink" title="生成器函数"></a>生成器函数</h3><ul><li>生成器函数是一个带星号函数，而且是可以暂停执行和恢复执行的</li><li>在生成器函数内部执行一段代码，如果遇到 yield 关键字，那么 JavaScript 引擎将返回关键字后面的内容给外部，并暂停该函数的执行。<br>外部函数可以通过 next 方法恢复函数的执行。</li></ul><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><ul><li><p>可以把协程看成是跑在线程上的任务</p><ul><li>一个线程上可以存在多个协程，但是在线程上同时只能执行一个协程，比如当前执行的是 A 协程，要启动 B 协程，那么 A 协程就需要将主线程的控制权交给 B 协程，这就体现在 A 协程暂停执行，B 协程恢复执行</li></ul></li><li><p>注意</p><ul><li><p>协程和父协程之间交互执行，不是并发</p><ul><li>是通过 yield 和 gen.next 来配合完成的</li></ul></li><li><p>当在 gen 协程中调用了 yield 方法时，JavaScript 引擎会保存 gen 协程当前的调用栈信息，并恢复父协程的调用栈信息</p></li></ul></li></ul><h3 id="async-await-技术背后的秘密就是-Promise-和生成器应用"><a href="#async-await-技术背后的秘密就是-Promise-和生成器应用" class="headerlink" title="async/await 技术背后的秘密就是 Promise 和生成器应用"></a>async/await 技术背后的秘密就是 Promise 和生成器应用</h3><h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><ul><li>通过异步执行</li><li>并返回 Promise</li></ul><h3 id="await"><a href="#await" class="headerlink" title="await"></a>await</h3><ul><li><p>执行过程</p><ul><li>默认创建一个 Promise 对象</li><li>暂停当前协程的执行，将主线程的控制权转交给父协程执行</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 浏览器工作原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> Api </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP</title>
      <link href="/2021/05/30/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/HTTP/"/>
      <url>/2021/05/30/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/HTTP/</url>
      
        <content type="html"><![CDATA[<h2 id="HTTP-版本"><a href="#HTTP-版本" class="headerlink" title="HTTP 版本"></a>HTTP 版本</h2><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><ul><li><p>基于 TCP 协议，三次握手</p></li><li><p>get 请求文件</p></li><li><p>请求头</p><ul><li><p>文件类型</p></li><li><p>期望压缩方式</p></li><li><p>期望文件编码</p></li><li><p>期望页面语言</p></li><li><p>客户端基础信息</p><ul><li>用户代理字段</li></ul></li></ul></li><li><p>响应头</p><ul><li>压缩类型，文件编码</li></ul></li><li><p>响应头</p></li><li><p>四次挥手断开连接</p></li></ul><h3 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP 1.1"></a>HTTP 1.1</h3><ul><li><p>增加了持久连接的方法</p><ul><li>一个 TCP 连接可以传输多个 HTTP 请求，只要浏览器或者服务器没有明确断开连接，TCP 会一直保持</li><li>对于同一个域名，默认允许同时建立 6 个 TCP 的持久连接</li></ul></li><li><p>带宽利用率不理想</p><ul><li><p>原因</p><ul><li><p>TCP 的慢启动</p><ul><li>刚开始 TCP 协议会采用一个非常慢的速度去发送数据，然后慢慢加快发送数据的速度，直到发送数据的速度达到一个理想状态，我们把这个过程称为慢启动</li></ul></li><li><p>同时开启多个 TCP 连接</p></li><li><p>队头阻塞问题</p><ul><li>公用一个 TCP 管道时，在一个管道中同一时刻只能处理一个请求，当前请求没有结束之前，其他请求处于阻塞状态</li></ul></li></ul></li></ul></li></ul><h3 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h3><ul><li><p>一个域名只使用一个 TCP 长连接</p></li><li><p>解决队头阻塞问题</p><ul><li><p>多路复用机制</p><ul><li>可以将请求分成一帧一帧的数据去传输</li><li>当收到一个优先级高的请求时，服务器可以暂停之前的请求来优先处理关键资源的请求</li></ul></li><li><p>通过引入 二进制分帧层 实现了多路复用技术</p><ul><li>浏览器请求数据通过二进制分帧层处理后，转换为一个个带有 ID 的帧，发送给服务器</li><li>服务器接收所有帧之后，合并为一条信息，发送回二进制分帧层</li><li>二进制分帧层接收数据之后，合并成完整的响应体</li></ul></li><li><p>如果在 TCP 传输过程中，由于单个数据包的丢失从而造成阻塞</p><ul><li>如果是 HTTP1.1,其他的 5 个连接依然可以继续传输数据</li><li>随着丢包率的增加，HTTP2 的传输效率会越来越差，传输效率可能比 HTTP1.1 要差</li></ul></li></ul></li><li><p>其他特性</p><ul><li><p>设置请求的优先级</p></li><li><p>服务器推送</p><ul><li>比如服务器会在收到 HTML 请求后，推送附带的 JS CSS 文件</li></ul></li><li><p>头部压缩</p><ul><li>请求头压缩</li></ul></li></ul></li></ul><h2 id="安全策略"><a href="#安全策略" class="headerlink" title="安全策略"></a>安全策略</h2><h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><ul><li><p>同源策略</p><ul><li><p>协议，域名，端口，三者相等</p></li><li><p>DOM 层面</p><ul><li>同源策略限制来自不同源的 JS 脚本对当前 DOM 对象读写</li></ul></li><li><p>数据层面</p></li><li><p>网络层面</p></li></ul></li><li><p>CSP</p><ul><li>为了解决 XSS 攻击，浏览器引入了内容安全策略</li><li>核心思想是 让服务器决定浏览器能够加载哪些资源，让服务器决定浏览器是否能够执行内联 JS 代码</li></ul></li><li><p>CORS</p><ul><li><p>跨域资源共享</p></li><li><p>跨文档消息机制</p><ul><li>window.postMessage</li></ul></li></ul></li></ul><h3 id="XSS-跨站脚本攻击"><a href="#XSS-跨站脚本攻击" class="headerlink" title="XSS 跨站脚本攻击"></a>XSS 跨站脚本攻击</h3><ul><li><p>方式</p><ul><li><p>存储型</p><ul><li>将恶意代码存储到存在漏洞的服务器</li></ul></li><li><p>反射型</p><ul><li>恶意 JavaScript 脚本属于用户发送给网站请求中的一部分，随后网站又把恶意 JavaScript 脚本返回给用户</li></ul></li><li><p>基于 DOM 的 XSS 攻击</p><ul><li>在 Web 资源传输过程中修改 Web 页面的数据</li></ul></li></ul></li><li><p>处理策略</p><ul><li><p>对输入的脚本进行过滤</p></li><li><p>对输入的脚本转码</p></li><li><p>充分利用 CSP</p><ul><li>限制加载其他域下的资源文件</li><li>禁止向第三方域提交数据</li></ul></li><li><p>使用 HttpOnly 来保护 Cookie 数据</p><ul><li>防止 Cookie 数据被 JS 读取出来</li></ul></li></ul></li></ul><h3 id="CSRF-攻击"><a href="#CSRF-攻击" class="headerlink" title="CSRF 攻击"></a>CSRF 攻击</h3><ul><li><p>跨站请求伪造</p><ul><li><p>在黑客的网站中，利用用户的登录状态发起的跨站请求</p><ul><li>利用服务器的漏洞和用户的登录状态实施攻击</li></ul></li></ul></li><li><p>防止攻击</p><ul><li>充分利用好 Cookie 的 SameSite 属性</li><li>验证请求的站点</li><li>携带 CSRF Token</li></ul></li></ul><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><h3 id="HTTPS-就是-TCP-先和安全层通信，然后安全层再和-TCP-通信"><a href="#HTTPS-就是-TCP-先和安全层通信，然后安全层再和-TCP-通信" class="headerlink" title="HTTPS 就是 TCP 先和安全层通信，然后安全层再和 TCP 通信"></a>HTTPS 就是 TCP 先和安全层通信，然后安全层再和 TCP 通信</h3><ul><li>SSL/TLS</li></ul><h3 id="安全层的职责"><a href="#安全层的职责" class="headerlink" title="安全层的职责"></a>安全层的职责</h3><ul><li>对发起 HTTP 请求的数据进行加密</li><li>解密操作</li></ul><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><ul><li>加密和解密都使用相同的密钥</li><li>传输密钥过程中可能被截取</li></ul><h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><ul><li><p>浏览器向服务器请求公钥和加密套件，之后浏览器使用公钥加密数据向服务器发送</p><ul><li>私钥加密只能公钥解密</li><li>公钥加密只能私钥解密</li></ul></li><li><p>问题</p><ul><li>效率太低</li><li>无法保证服务器发送给浏览器的数据安全</li></ul></li></ul><h3 id="折中方案"><a href="#折中方案" class="headerlink" title="折中方案"></a>折中方案</h3><ul><li>对称加密的密钥使用 非对称加密传输，数据传输阶段还是对称加密</li></ul><h3 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h3><ul><li><p>作用</p><ul><li>向浏览器证明服务器的身份</li><li>数字证书里包含了服务器的公钥</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 浏览器工作原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chrome浏览器</title>
      <link href="/2021/05/28/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/Chrome%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
      <url>/2021/05/28/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/Chrome%E6%B5%8F%E8%A7%88%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="chrome-浏览器-四个进程"><a href="#chrome-浏览器-四个进程" class="headerlink" title="chrome 浏览器 四个进程"></a>chrome 浏览器 四个进程</h3><ul><li>浏览器进程</li><li>渲染进程</li><li>GPU 进程</li><li>网络进程</li><li>插件进程</li></ul><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="连接过程"><a href="#连接过程" class="headerlink" title="连接过程"></a>连接过程</h3><ul><li>三次握手四次挥手</li></ul><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="请求流程"><a href="#请求流程" class="headerlink" title="请求流程"></a>请求流程</h3><ul><li><p>构建请求</p></li><li><p>查找缓存</p></li><li><p>准备 ip 地址和端口</p><ul><li>HTTP 内容通过 TCP 传输数据实现</li></ul></li><li><p>等待 TCP 队列</p><ul><li>同一个域名同时最多只能建立 6 个 TCP 链接</li></ul></li><li><p>建立 TCP 连接</p></li><li><p>发送 HTTP 请求</p></li></ul><h3 id="服务端处理-HTTP-请求"><a href="#服务端处理-HTTP-请求" class="headerlink" title="服务端处理 HTTP 请求"></a>服务端处理 HTTP 请求</h3><ul><li><p>返回请求</p></li><li><p>断开连接</p><ul><li>如果在头信息中加入 Connection:keep-alive</li><li>则会保持 TCP 连接</li></ul></li><li><p>重定向</p></li></ul><h3 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h3><ul><li><p>DNS 缓存</p></li><li><p>页面资源缓存</p><ul><li><p>浏览器通过响应头中的 Cache-Control 字段来设置是否缓存该资源</p></li><li><p>Cache-Control:Max-age=2000</p><ul><li>2000 秒后过期</li></ul></li><li><p>过期之后重新请求数据</p><ul><li>如果没有更改 返回 304 没有更新</li></ul></li></ul></li><li><p>使用 Cookie 保持登录状态</p><ul><li>服务端将用户信息写到响应头的 Set-Cookie 字段里</li><li>浏览器接收到响应头后，将 Cookie 字段存在本地</li><li>再次访问时将信息放到 Cookie 字段 发送给服务器</li><li>服务器返回登录的状态的信息</li></ul></li></ul><h2 id="导航流程"><a href="#导航流程" class="headerlink" title="导航流程"></a>导航流程</h2><h3 id="大致"><a href="#大致" class="headerlink" title="大致"></a>大致</h3><ul><li><p>用户从浏览器进程中输入请求信息</p></li><li><p>URL 请求</p><ul><li><p>查找缓存</p></li><li><p>DNS 解析</p></li><li><p>建立 TCP 连接</p></li><li><p>向服务器发送构建好的请求信息</p></li><li><p>处理响应数据</p><ul><li><p>301，302 重定向</p></li><li><p>响应数据类型处理</p><ul><li><p>Content-Type</p><ul><li>告诉浏览器返回的响应体的类型</li><li>html</li><li>octet-stream</li></ul></li></ul></li></ul></li></ul></li><li><p>准备渲染进程</p><ul><li><p>一般情况下，每个页面分配一个渲染进程</p></li><li><p>如果从 A 页面打开 B 页面，且 A 和 B 都属于同一站点的话，那么新页面会复用父页面的渲染进程</p><ul><li>相同的协议和根域名</li></ul></li></ul></li><li><p>渲染阶段</p></li></ul><h2 id="渲染流程"><a href="#渲染流程" class="headerlink" title="渲染流程"></a>渲染流程</h2><h3 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h3><ul><li>构建 DOM 树</li><li>样式计算</li><li>布局</li><li>分层</li><li>绘制</li><li>分块</li><li>光栅化</li><li>合成</li></ul><h3 id="样式计算"><a href="#样式计算" class="headerlink" title="样式计算"></a>样式计算</h3><ul><li><p>转换</p><ul><li><p>来源</p><ul><li>link 引用的 css 文件</li><li>style 标记内的 css</li><li>元素 style 属性内的 css</li></ul></li><li><p>转换为 styleSheets</p></li></ul></li><li><p>对属性值进行标准化</p><ul><li>如 blue -&gt; rgb(0,0,255)</li></ul></li><li><p>确定每个元素的样式</p><ul><li><p>样式继承</p><ul><li>每个 DOM 节点都包含有父节点的样式</li></ul></li><li><p>样式层叠</p><ul><li>对多个来源的样式的 优先级算法</li></ul></li></ul></li></ul><h3 id="布局阶段"><a href="#布局阶段" class="headerlink" title="布局阶段"></a>布局阶段</h3><ul><li>创建布局树</li><li>布局计算</li></ul><h3 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h3><ul><li>为特定节点生成专用的图层<ul><li>LayerTree</li></ul></li><li>单独的图层条件<ul><li>具有层叠上下文</li><li>需要被剪裁</li></ul></li></ul><h3 id="图层绘制"><a href="#图层绘制" class="headerlink" title="图层绘制"></a>图层绘制</h3><ul><li>绘制列表只是用来记录绘制顺序和绘制指令的列表</li></ul><h3 id="栅格化"><a href="#栅格化" class="headerlink" title="栅格化"></a>栅格化</h3><ul><li>将图块转换为位图</li></ul><h3 id="合成和显示"><a href="#合成和显示" class="headerlink" title="合成和显示"></a>合成和显示</h3><h2 id="单个文件请求时间线"><a href="#单个文件请求时间线" class="headerlink" title="单个文件请求时间线"></a>单个文件请求时间线</h2><h3 id="Queuing-排队等待"><a href="#Queuing-排队等待" class="headerlink" title="Queuing 排队等待"></a>Queuing 排队等待</h3><ul><li><p>原因</p><ul><li>资源优先级低，比如图片，视频，音频等</li><li>浏览器为每个域名最多维护 6 个 TCP 链接</li><li>等待磁盘分配空间</li></ul></li><li><p>解决</p><ul><li><p>使用一个站点资源放到多个域名下</p></li><li><p>域名分片</p></li></ul></li></ul><h3 id="发起连接"><a href="#发起连接" class="headerlink" title="发起连接"></a>发起连接</h3><h3 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h3><h3 id="TTFB"><a href="#TTFB" class="headerlink" title="TTFB"></a>TTFB</h3><ul><li>第一字节时间</li><li>反映服务端响应速度的重要指标</li></ul><h2 id="DOM-树的生成"><a href="#DOM-树的生成" class="headerlink" title="DOM 树的生成"></a>DOM 树的生成</h2><ol><li><p>DOM 是表述 HTML 的内部数据结构，将 web 页面和 JS 脚本连接起来</p></li><li><p>HTML 字节流转换为 DOM</p></li></ol><ul><li>通过分词器将字节流转换为 Token</li><li>再把 token 解析成 DOM 节点</li></ul><ol start="3"><li>JS 影响 DOM 生成</li></ol><ul><li><p>解析器遇到 JS 脚本，会暂停 DOM 解析</p><ul><li>因为 JS 脚本可能会修改 DOM 结构</li></ul></li><li><p>如果遇到需要下载的 JS 文件</p><ul><li><p>阻塞 DOM 解析</p></li><li><p>Chrome 预解析</p></li><li><p>如果文件中没有改变 DOM 代码</p><ul><li>async</li><li>script 标签内的 async 标记</li><li>defer</li></ul></li></ul></li></ul><ol start="4"><li>我们知道了 JavaScript 会阻塞 DOM 生成，而 CSS 文件又会阻塞 JavaScript 的执行</li></ol><h2 id="分层和合成"><a href="#分层和合成" class="headerlink" title="分层和合成"></a>分层和合成</h2><ol><li><p>提升渲染效率</p></li><li><p>分层是在生成布局树之后，渲染引擎会根据布局树的特点生成 layer tree</p></li><li><p>分块会优先绘制靠近视口的图块</p></li></ol><ul><li>在首次合成图块的时候使用一个低分辨率的图片，当正常比例的网页内容绘制完成之后，再替换掉当前显示的低分辨率内容</li></ul><ol start="4"><li><p>合成操作是在合成线程上完成的，这也就意味着在执行合成操作时，是不会影响到主线程执行的</p></li><li><p>CSS 动画比 JS 动画更加高效</p></li></ol><ul><li>CSS 动画运行在合成线程，没有涉及主线程，大大提升了渲染效率</li></ul><h2 id="系统的优化界面"><a href="#系统的优化界面" class="headerlink" title="系统的优化界面"></a>系统的优化界面</h2><h3 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h3><ul><li><p>能阻塞网页首次渲染的资源称为关键资源</p></li><li><p>影响首次加载的核心因素</p><ul><li><p>关键资源个数</p></li><li><p>关键资源大小</p></li><li><p>请求关键资源需要多少个 RTT</p><ul><li><p>RTT</p><ul><li>表示从发送端发送数据开始，到发送端收到来自接收端的确认所经历的时间</li><li>通常一个 HTTP 数据包在 14kb 左右，0.1M 的页面需要 8 个 RTT</li></ul></li></ul></li></ul></li><li><p>总的优化规则是 减少关键资源个数，降低关键资源大小，降低关键资源的 RTT 次数</p></li></ul><h3 id="交互阶段"><a href="#交互阶段" class="headerlink" title="交互阶段"></a>交互阶段</h3><ul><li><p>单个帧的生成速度更快</p></li><li><p>优化</p><ul><li>减少 JS 脚本执行时间</li><li>尽量使用 css 动画</li><li>避免强制同步布局</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 浏览器工作原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器代码执行</title>
      <link href="/2021/05/26/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/"/>
      <url>/2021/05/26/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="执行机制"><a href="#执行机制" class="headerlink" title="执行机制"></a>执行机制</h2><ol><li><p>先编译再执行</p></li><li><p>先做变量提升</p></li><li><p>编译阶段 变量的值会被设置为 undefined</p></li><li><p>如果在编译阶段，存在两个相同的函数, 后面的函数覆盖掉前面的函数</p></li></ol><h2 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h2><ol><li><p>管理函数调用关系的数据结构</p></li><li><p>函数执行过程</p></li></ol><ul><li>从全局执行上下文中，取出函数代码</li><li>对函数代码进行编译，并创建该函数的执行上下文和可执行代码</li><li>执行代码</li></ul><ol start="3"><li>调用栈</li></ol><ul><li>在执行上下文创建好后，JS 引擎会将执行上下文压入栈中</li><li>函数执行完之后，将该函数的执行上下文出栈</li></ul><h2 id="作用域链和闭包"><a href="#作用域链和闭包" class="headerlink" title="作用域链和闭包"></a>作用域链和闭包</h2><ol><li>词法作用域是指作用域是由函数声明的代码位置决定的</li></ol><ul><li>词法作用域是代码阶段就决定好的，和函数是怎么调用的没有关系。</li></ul><ol start="2"><li>闭包</li></ol><ul><li>内部函数总是可以访问其外部函数中声明的变量</li></ul><h2 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h2><ol><li>全局执行中的 this</li></ol><ul><li>指向 window 对象</li></ul><ol start="2"><li>函数执行上下文中的 this</li></ol><ul><li>默认打印出来的是 window 对象</li><li>通过 call,bind,apply 更改 this 的指向</li><li>通过一个对象调用内部方法，该方法中的 this 指向对象本身</li><li>通过 new 创建的对象，指向的就是新创建的对象本身</li></ul><ol start="3"><li>通过箭头函数创建的对象的 this 指向父对象</li></ol><h2 id="堆空间和栈空间"><a href="#堆空间和栈空间" class="headerlink" title="堆空间和栈空间"></a>堆空间和栈空间</h2><ol><li>原始类型的数据保存在 栈 中，引用类型的值存放在 堆 中</li></ol><ul><li>对象类型是存放在堆空间的，在栈空间中只是保留了对象的引用地址，当 JavaScript 需要访问该数据的时候，是通过栈中的引用地址来访问的</li></ul><ol start="2"><li>栈空间</li></ol><ul><li>用来维护程序执行期间上下文的状态</li></ul><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ol><li>原始数据类型</li></ol><ul><li>Boolean</li><li>Null</li><li>Undefined</li><li>String</li><li>Number</li><li>Bigint</li><li>symbol</li></ul><ol start="2"><li>引用数据类型</li></ol><ul><li>Object</li></ul><h2 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h2><ol><li>栈中的数据</li></ol><ul><li>通过下移记录当前执行状态的指针（称为 ESP），来销毁该函数保存在栈中的执行上下文</li></ul><ol start="2"><li>堆中的数据</li></ol><ul><li><p>垃圾回收机制</p><ul><li>标记清除算法</li></ul></li></ul><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><ol><li>Chrome 里面的线程是通过消息队列来传递处理消息</li></ol><ul><li>先进先出</li></ul><ol start="2"><li>宏任务和微任务</li></ol><ul><li>每个宏任务都包含一个微任务队列</li><li>宏任务执行完之后，就会执行相应微任务</li></ul><h2 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h2><ol><li><p>微任务是一个需要异步执行的函数</p></li><li><p>微任务</p></li></ol><ul><li><p>执行时机</p><ul><li>主函数执行结束之后、当前宏任务结束之前</li></ul></li></ul><ol start="3"><li>宏任务</li></ol><ul><li>消息队列中的任务</li></ul>]]></content>
      
      
      <categories>
          
          <category> 浏览器工作原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dart</title>
      <link href="/2020/11/30/Dart/Dart/"/>
      <url>/2020/11/30/Dart/Dart/</url>
      
        <content type="html"><![CDATA[<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><ol><li>final</li></ol><ul><li>一开始不赋值，只能赋值一次</li></ul><ol start="2"><li>const</li></ol><ul><li>不能赋值为方法</li></ul><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ol><li>var</li></ol><ul><li>赋值后 变量的类型无法改变</li></ul><ol start="2"><li>object 与 dynamic</li></ol><ul><li><p>赋值后变量类型可以改变</p></li><li><p>不同</p><ul><li><p>dynamic 声明的变量可以使用提供的所有方法</p></li><li><p>object 声明的变量只能使用 object 包含的方法</p></li><li><p>比如 object a = “1234”</p><ul><li>a.length 报错</li></ul></li></ul></li></ul><h2 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h2><p><strong>Dart 在单线程中是以消息循环机制来运行的</strong></p><ol><li>microtask queue</li></ol><ul><li>通常来源于 Dart 内部，并且微任务非常少</li><li>我们可以通过 Future.microtask(…)方法向微任务队列插入一个任务。</li></ul><ol start="2"><li>event queue</li></ol><ul><li>所有的外部事件任务都在事件队列中，如 IO、计时器、点击、以及绘制事件等</li></ul><ol start="3"><li>微任务队列的执行优先级高于事件队列</li></ol><p><strong>入口函数 main() 执行完后，消息循环机制便启动了。首先会按照先进先出的顺序逐个执行微任务队列中的任务，事件任务执行完毕后程序便会退出，但是，在事件任务执行的过程中也可以插入新的微任务和事件任务，在这种情况下，整个线程的执行过程便是一直在循环，不会退出</strong></p><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><ol><li>b??=23</li></ol><ul><li>如果 b 为空的话 赋值为 23</li></ul><ol start="2"><li>var b = a??10</li></ol><ul><li>如果 a 为空，赋值 10，不为空，赋值 a</li></ul><ol start="3"><li>var b = a++</li></ol><ul><li>++在后面，先赋值在自增</li><li>结果 b=a ; a = a+1</li></ul><h2 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h2><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><ul><li><p>indexOf</p></li><li><p>fillRange</p><ul><li>修改指定 index 的数据</li></ul></li><li><p>join</p><ul><li>List 转化为字符串类型</li></ul></li><li><p>where</p><ul><li>返回符合条件的数组元素</li></ul></li><li><p>any</p><ul><li>只要集合里面有一个满足条件就返回 True,否则为 False</li></ul></li><li><p>every</p><ul><li>集合里面每一个都满足条件就返回 True</li></ul></li></ul><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><ul><li><p>无序且不重复</p></li><li><p>toList</p><ul><li>转换为数组</li></ul></li></ul><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h3><ul><li>print([int age])</li></ul><h3 id="自执行方法"><a href="#自执行方法" class="headerlink" title="自执行方法"></a>自执行方法</h3><ul><li>((){})()</li></ul><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><ul><li><p>函数嵌套函数，并且返回这个函数</p></li><li><p>常驻内存，但是不污染全局环境</p></li><li><p>举例</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> a <span class="token operator">=</span><span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>a<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token function">print</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="私有属性"><a href="#私有属性" class="headerlink" title="私有属性"></a>私有属性</h3><ul><li>属性名字加 _</li></ul><h3 id="get-set-方法"><a href="#get-set-方法" class="headerlink" title="get set 方法"></a>get set 方法</h3><ul><li>通过访问属性的方式去调用</li></ul><h3 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h3><ul><li>使用 static 关键字来指定</li><li>访问静态成员 不需要实例化类</li><li>静态方法不能访问非静态成员，非静态方法可以访问静态成员</li></ul><h3 id="级联操作符"><a href="#级联操作符" class="headerlink" title="级联操作符"></a>级联操作符</h3><ul><li><p>..</p></li><li><p>示例</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">a<span class="token punctuation">.</span><span class="token punctuation">.</span>name<span class="token operator">=</span> <span class="token char">'aaa'</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><ul><li>抽象类不能被实例化 只能被继承</li><li>抽象方法 不用 abstract , 只是没有方法体</li><li>抽象类里面可以有非抽象方法</li><li>子类继承抽象类 必须实现里面的抽象方法</li><li>子类实现抽象类 必须实现里面的所有属性和方法</li></ul><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ul><li>implements 关键字</li></ul><h3 id="Mixins"><a href="#Mixins" class="headerlink" title="Mixins"></a>Mixins</h3><ul><li>可以实现类似多继承的功能</li><li>不是继承和接口</li><li>Mixins 只能继承 object，不能继承其他类</li><li>被继承的类不能有构造方法</li><li>如果多个类里面有相同名字的方法，则后写的继承类的方法 重写前面的方法</li><li>with 关键字</li></ul><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul><li>子类自动获取父类的成员变量和方法实现</li></ul><h3 id="接口实现"><a href="#接口实现" class="headerlink" title="接口实现"></a>接口实现</h3><ul><li>子类获取接口的成员变量符号和方法符号，必须重新实现成员变量</li></ul><h3 id="with-关键字"><a href="#with-关键字" class="headerlink" title="with 关键字"></a>with 关键字</h3><ul><li>一个类里可以以非继承的方式使用其他类中的变量与方法</li></ul><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><ul><li><p>类型校验</p></li><li><p>规范数据类型</p></li><li><p>T 表示</p></li></ul><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ol><li><p>?. 运算符：假设 Point 类有 printInfo() 方法，p 是 Point 的一个可能为 null 的实例。那么，p 调用成员方法的安全代码，可以简化为 p?.printInfo() ，表示 p 为 null 的时候跳过，避免抛出异常</p></li><li><p>??= 运算符：如果 a 为 null，则给 a 赋值 value，否则跳过。这种用默认值兜底的赋值语句在 Dart 中我们可以用 a ??= value 表示。</p></li><li><p>?? 运算符：如果 a 不为 null，返回 a 的值，否则返回 b。在 Java 或者 C++ 中，我们需要通过三元表达式 (a != null)? a : b 来实现这种情况。而在 Dart 中，这类代码可以简化为 a ?? b。</p></li></ol><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="同步异常"><a href="#同步异常" class="headerlink" title="同步异常"></a>同步异常</h3><ul><li>try/catch</li></ul><h3 id="异步异常"><a href="#异步异常" class="headerlink" title="异步异常"></a>异步异常</h3><ul><li><p>runZoned</p><ul><li>onError</li></ul></li></ul><h2 id="factory-关键字"><a href="#factory-关键字" class="headerlink" title="factory 关键字"></a>factory 关键字</h2><p><strong>控制在使用构造函数时，并不总是创建一个新的该类的对象，比如它可能会从缓存中返回一个已有的实例，或者是返回子类的实例</strong></p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>避免创建过多的重复实例</li><li>调用子类的构造方法（工厂模式）</li><li>单例模式</li></ul><h2 id="编译模式"><a href="#编译模式" class="headerlink" title="编译模式"></a>编译模式</h2><h3 id="Script"><a href="#Script" class="headerlink" title="Script"></a>Script</h3><ul><li>jit 模式</li></ul><h3 id="Script-Snapshot"><a href="#Script-Snapshot" class="headerlink" title="Script Snapshot"></a>Script Snapshot</h3><ul><li>jit 模式</li></ul><h3 id="Application-Snapshot"><a href="#Application-Snapshot" class="headerlink" title="Application Snapshot"></a>Application Snapshot</h3><ul><li>jit 模式</li><li>这种模式来源于 dart vm 直接载入源码后 dump 出数据。dart vm 通过这种数据启动会更快。不过这种模式是区分架构的，在 X64 下生成的无法给 IA_32 用</li></ul><h3 id="AOT"><a href="#AOT" class="headerlink" title="AOT"></a>AOT</h3>]]></content>
      
      
      <categories>
          
          <category> Dart </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dart </tag>
            
            <tag> 语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter 优化</title>
      <link href="/2020/09/18/Flutter/Flutter%20%E4%BC%98%E5%8C%96%20/"/>
      <url>/2020/09/18/Flutter/Flutter%20%E4%BC%98%E5%8C%96%20/</url>
      
        <content type="html"><![CDATA[<h2 id="减少页面渲染次数"><a href="#减少页面渲染次数" class="headerlink" title="减少页面渲染次数"></a>减少页面渲染次数</h2><h2 id="使用-RepaintBoundary"><a href="#使用-RepaintBoundary" class="headerlink" title="使用 RepaintBoundary"></a>使用 RepaintBoundary</h2><ul><li>对应子树的 paint 不会导致外部的 repaint</li></ul><h2 id="GPU-优化"><a href="#GPU-优化" class="headerlink" title="GPU 优化"></a>GPU 优化</h2><ul><li><p>减少 saveOverlay</p><ul><li>会在 GPU 中分配一块新的绘图缓冲区（离屏渲染），切换绘图目标，</li><li>主要在离屏的地方会调用</li></ul></li><li><p>减少 clipPath</p><ul><li>会影响接下来每一个绘图指令。尤其这个 Path 比较复杂的时候都需要和这个复杂的 Path 做相交操作，而且把 Path 之外的部分剔除掉</li></ul></li></ul><h2 id="加载策略"><a href="#加载策略" class="headerlink" title="加载策略"></a>加载策略</h2><ul><li><p>按需加载</p></li><li><p>错峰加载</p></li></ul><h2 id="耗时计算"><a href="#耗时计算" class="headerlink" title="耗时计算"></a>耗时计算</h2><ul><li><p>Isolate</p><ul><li>不要乱用</li></ul></li></ul><h2 id="耗电优化"><a href="#耗电优化" class="headerlink" title="耗电优化"></a>耗电优化</h2><ul><li><p>cpu 计算耗电</p></li><li><p>网络耗电</p><ul><li>移动数据比 wifi 更费电</li></ul></li><li><p>避免后台长时间获取 WakeLock、WIFI 和蓝牙的扫描</p></li><li><p>定位相关</p></li><li><p>使用低精度的定位</p></li><li><p>使用后关闭</p></li></ul><h3 id="界面相关"><a href="#界面相关" class="headerlink" title="界面相关"></a>界面相关</h3><ul><li>离开界面后停止相关活动，例如关闭动画。</li><li>耗电操作判断前后台，如果是后台则不执行相关操作</li></ul>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨平台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter框架原理</title>
      <link href="/2020/09/16/Flutter/Flutter%E6%A1%86%E6%9E%B6%E5%8E%9F%E7%90%86/"/>
      <url>/2020/09/16/Flutter/Flutter%E6%A1%86%E6%9E%B6%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="CachedNetworkImage"><a href="#CachedNetworkImage" class="headerlink" title="CachedNetworkImage"></a>CachedNetworkImage</h2><h3 id="缓存相关"><a href="#缓存相关" class="headerlink" title="缓存相关"></a>缓存相关</h3><ul><li><p>cacheManager</p><ul><li>如果我们自己没有设置 cacheManager</li><li>自动设置一个 DefaultCacheManager</li></ul></li><li><p>本地缓存首先调用内存缓存</p><ul><li>如果没有数据，则从本地 sqlite 查询</li><li>sqlite 缓存的是原图片 url 和本地图片 path 的对应关系</li></ul></li><li><p>网络获取</p></li></ul><h2 id="dio"><a href="#dio" class="headerlink" title="dio"></a>dio</h2><p><strong>无论何种请求，最终一定是调用 request 方法</strong></p><h2 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h2><h3 id="ImageProvider"><a href="#ImageProvider" class="headerlink" title="ImageProvider"></a>ImageProvider</h3><ul><li>是一个抽象类，定义了图片数据获取和加载的相关接口</li><li>加载图片数据并进行缓存、解码</li><li>NetworkImage 类和 AssetImage 类，它们都是 ImageProvider 的子类</li></ul><p><strong>主要通过 ImageProvider 获取到图片资源将 ImageStream 给到 ImageState</strong></p><p><strong>如果两张图片的 url 或 scale 只要有一个不同，便会重新下载并分别缓存</strong></p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨平台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter组件</title>
      <link href="/2020/09/16/Flutter/Flutter%E7%BB%84%E4%BB%B6/"/>
      <url>/2020/09/16/Flutter/Flutter%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="RichText"><a href="#RichText" class="headerlink" title="RichText"></a>RichText</h2><ul><li><p>行内多样式文本</p></li><li><p>子 Widget</p><ul><li>TextSpan</li></ul></li></ul><h2 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h2><h3 id="属性-decoration"><a href="#属性-decoration" class="headerlink" title="属性 decoration"></a>属性 decoration</h3><ul><li>BoxDecoration</li><li>增加边框</li><li>增加圆角</li><li>增加阴影</li><li>增加渐变</li></ul><h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><ol><li><p>层叠布局</p></li><li><p>子 widget</p></li></ol><ul><li><p>Positioned</p><ul><li>left,right,top,bottom 属性</li><li>定位组件</li></ul></li></ul><h2 id="对齐与相对位置"><a href="#对齐与相对位置" class="headerlink" title="对齐与相对位置"></a>对齐与相对位置</h2><h3 id="Align"><a href="#Align" class="headerlink" title="Align"></a>Align</h3><ul><li><p>Alignment</p><ul><li>指定子组件相对位置，原始位置在组件中心点</li></ul></li><li><p>FractionalOffset</p><ul><li>指定相对位置，原始位置在组件的左上角</li></ul></li><li><p>只能有一个元素，不可堆叠</p></li></ul><h2 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h2><h3 id="Transform"><a href="#Transform" class="headerlink" title="Transform"></a>Transform</h3><ul><li><p>在子组件绘制时，通过矩阵，对其进行变换</p></li><li><p>注意</p><ul><li>Transform 的变换是发生在 绘制阶段，而不是布局阶段</li><li>所以 组件占用的位置空间已经确定，只是绘制时进行放大等变换</li></ul></li></ul><h3 id="RotatedBox"><a href="#RotatedBox" class="headerlink" title="RotatedBox"></a>RotatedBox</h3><ul><li>对子组件进行旋转等 操作</li><li>不同的是 变换发生在布局阶段，而不是绘制阶段</li></ul><h2 id="SizedBox"><a href="#SizedBox" class="headerlink" title="SizedBox"></a>SizedBox</h2><ul><li>固定尺寸布局</li></ul><h2 id="AspectRatio"><a href="#AspectRatio" class="headerlink" title="AspectRatio"></a>AspectRatio</h2><ul><li>设置  宽高比例的布局</li></ul><h2 id="CustomScrollView"><a href="#CustomScrollView" class="headerlink" title="CustomScrollView"></a>CustomScrollView</h2><ul><li><p>可以控制布局内的组件同步滚动</p></li><li><p>属性 sliver</p><ul><li>Widget 组</li><li>sliverAppBar</li><li>sliverList</li><li>sliverPadding</li><li>sliverGrid</li></ul></li></ul><h2 id="Form"><a href="#Form" class="headerlink" title="Form"></a>Form</h2><h3 id="表单组件"><a href="#表单组件" class="headerlink" title="表单组件"></a>表单组件</h3><h3 id="子-widget"><a href="#子-widget" class="headerlink" title="子 widget"></a>子 widget</h3><ul><li><p>TextFormFiled</p><ul><li><p>decoration</p><ul><li>InputDectoration</li></ul></li><li><p>obscureText</p><ul><li>密码格式</li></ul></li><li><p>validator</p><ul><li>验证值</li></ul></li><li><p>autovalidate</p><ul><li>自动验证</li></ul></li></ul></li></ul><h2 id="SnackBar"><a href="#SnackBar" class="headerlink" title="SnackBar"></a>SnackBar</h2><ul><li>Scaffold.of(context).showSnackBar</li></ul><h2 id="对话框"><a href="#对话框" class="headerlink" title="对话框"></a>对话框</h2><ul><li><p>SimpleDialog</p></li><li><p>AlertDialog</p></li><li><p>BottomSheet</p></li><li><p>底部滑动窗口</p></li><li><p>ExpansionPanel</p></li><li><p>下拉窗口</p></li></ul><h2 id="小标签"><a href="#小标签" class="headerlink" title="小标签"></a>小标签</h2><h3 id="Chip"><a href="#Chip" class="headerlink" title="Chip"></a>Chip</h3><ul><li><p>ActionChip</p></li><li><p>FilterChip</p><ul><li>点击后选定</li></ul></li><li><p>ChoiceChip</p><ul><li>单选标签</li></ul></li></ul><h3 id="Wrap"><a href="#Wrap" class="headerlink" title="Wrap"></a>Wrap</h3><ul><li>换行显示小组件</li></ul><h3 id="Divider"><a href="#Divider" class="headerlink" title="Divider"></a>Divider</h3><ul><li>分隔符</li></ul><h2 id="步骤组件"><a href="#步骤组件" class="headerlink" title="步骤组件"></a>步骤组件</h2><ul><li>Stepper</li></ul><h2 id="WillPopScope"><a href="#WillPopScope" class="headerlink" title="WillPopScope"></a>WillPopScope</h2><ul><li>返回键拦截组件</li></ul><h2 id="InheritedWidget"><a href="#InheritedWidget" class="headerlink" title="InheritedWidget"></a>InheritedWidget</h2><ul><li><p>数据在子组件和父组件之间共享</p></li><li><p>父组件数据改变 子组件的 didChangeDependencies 的方法会被调用</p></li></ul><h2 id="FutureBuilder"><a href="#FutureBuilder" class="headerlink" title="FutureBuilder"></a>FutureBuilder</h2><ul><li><p>处理异步数据框架</p></li><li><p>返回的数据自动更新到子组件中</p></li><li><p>future</p></li><li><p>builder</p></li></ul><h2 id="手势监听"><a href="#手势监听" class="headerlink" title="手势监听"></a>手势监听</h2><h3 id="GestureDetector"><a href="#GestureDetector" class="headerlink" title="GestureDetector"></a>GestureDetector</h3><ul><li><p>onPanDown</p></li><li><p>onPanUpdate</p><ul><li>手指滑动</li></ul></li><li><p>onScaleUpdate</p><ul><li>双指缩放事件</li></ul></li><li><p>onVerticalDragUpdate</p><ul><li>只监听垂直方向的拖动</li></ul></li></ul><h3 id="GestureRecognizer"><a href="#GestureRecognizer" class="headerlink" title="GestureRecognizer"></a>GestureRecognizer</h3><ul><li>GestureDetector 内部是使用一个或多个 GestureRecognizer 来识别各种手势的，而 GestureRecognizer 的作用就是通过 Listener 来将原始指针事件转换为语义手势</li></ul><h2 id="NotificationListener"><a href="#NotificationListener" class="headerlink" title="NotificationListener"></a>NotificationListener</h2><ol><li>onNotification</li></ol><ul><li>监听 child 的通知回调</li><li>当返回值为 true 时，阻止冒泡，其父级 Widget 将再也收不到该通知</li></ul><ol start="2"><li><p>child</p></li><li><p>原理</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨平台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter工程架构</title>
      <link href="/2020/09/14/Flutter/Flutter%E5%B7%A5%E7%A8%8B%E6%9E%B6%E6%9E%84/"/>
      <url>/2020/09/14/Flutter/Flutter%E5%B7%A5%E7%A8%8B%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h2><h3 id="单一性原则"><a href="#单一性原则" class="headerlink" title="单一性原则"></a>单一性原则</h3><ul><li>每个组件专注做一件事</li></ul><h3 id="抽象化原则"><a href="#抽象化原则" class="headerlink" title="抽象化原则"></a>抽象化原则</h3><ul><li>对外暴露的接口很少发生变化，要做到这一点，需要我们提升对功能的抽象总结能力，在组件封装时做好功能抽象和接口设计，将所有可能发生变化的因子都在组件内部做好适配，不要暴露给它的调用方</li></ul><h3 id="稳定性原则"><a href="#稳定性原则" class="headerlink" title="稳定性原则"></a>稳定性原则</h3><ul><li>不要让稳定的组件依赖不稳定的组件</li></ul><h3 id="自完备性原则"><a href="#自完备性原则" class="headerlink" title="自完备性原则"></a>自完备性原则</h3><ul><li>组件需要尽可能地做到自给自足，尽量减少对其他底层组件的依赖，达到代码可复用的目的</li></ul><h3 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h3><ul><li>剥离基础功能、抽象业务模块和最小化服务能力。</li></ul><h2 id="平台化"><a href="#平台化" class="headerlink" title="平台化"></a>平台化</h2><p><strong>平台化是组件化的升级，即在组件化的基础上，对它们提供的功能进行分类，统一分层划分，增加依赖治理的概念</strong></p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li>具备 UI 属性的独立业务模块</li><li>不具备 UI 属性的基础业务功能</li><li>不具备业务属性的 UI 控件</li><li>不具备业务属性的基础功能</li></ul><h3 id="单向依赖原则"><a href="#单向依赖原则" class="headerlink" title="单向依赖原则"></a>单向依赖原则</h3><ul><li>组件依赖的顺序应该按照应用架构的层数从上到下依赖，不要出现下层模块依赖上层模块这样循环依赖的现象</li></ul><p><strong>平台化架构是目前应用最广的软件架构设计，其核心在于如何将离散的组件依照单向依赖的原则进行分层</strong></p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨平台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter核心原理</title>
      <link href="/2020/09/14/Flutter/Flutter%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/"/>
      <url>/2020/09/14/Flutter/Flutter%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="FlutterUI"><a href="#FlutterUI" class="headerlink" title="FlutterUI"></a>FlutterUI</h2><p><strong>底层通过 OpenGl 这种跨平台绘制库实现一套代码跨多端，性能接近原生</strong></p><h2 id="Element-与-BuildContext"><a href="#Element-与-BuildContext" class="headerlink" title="Element 与 BuildContext"></a>Element 与 BuildContext</h2><p><strong>根据 Widget 生成 Element，然后创建相应的 RenderObject 并关联到 Element.renderObject 属性上，最后再通过 RenderObject 来完成布局排列和绘制</strong></p><h3 id="Element"><a href="#Element" class="headerlink" title="Element"></a>Element</h3><ul><li><p>Element 树根据 Widget 树生成，而 RenderObject 树又依赖于 Element 树</p></li><li><p>生命周期</p><ul><li><p>widget.createElement</p><ul><li>创建实例</li></ul></li><li><p>element.mount</p><ul><li>用 element.attachRenderObject 方法将 element.renderObject 添加到渲染树中插槽指定的位置</li></ul></li><li><p>状态更新</p><ul><li>重新构建 Element 树之前调用 widget.canUpdate 判断是否需要更新</li><li>widget.canUpdate 主要判断新旧 widget 的 runtimeType 和 key 是否同时相等</li></ul></li><li><p>移除 Element</p><ul><li>deactivateChild</li><li>unmount</li></ul></li></ul></li></ul><h3 id="BuildContext"><a href="#BuildContext" class="headerlink" title="BuildContext"></a>BuildContext</h3><ul><li>BuildContext 就是 widget 对应的 Element</li><li>我们可以通过 context 在 StatelessWidget 和 StatefulWidget 的 build 方法中直接访问 Element 对象</li></ul><h2 id="RenderObject-和-RenderBox"><a href="#RenderObject-和-RenderBox" class="headerlink" title="RenderObject 和 RenderBox"></a>RenderObject 和 RenderBox</h2><h3 id="RenderObject"><a href="#RenderObject" class="headerlink" title="RenderObject"></a>RenderObject</h3><ul><li>主要职责 Layout 和 绘制</li></ul><h3 id="RenderBox"><a href="#RenderBox" class="headerlink" title="RenderBox"></a>RenderBox</h3><ul><li><p>继承自 RenderBox，提供了坐标系统</p></li><li><p>布局过程</p><ul><li><p>Constraints</p><ul><li>父节点对子节点大小的限制</li></ul></li><li><p>relayoutBoundary</p></li><li><p>performResize 和 performLayout</p><ul><li>只有 sizedByParent 为 true 时，performResize() 才会被调用，而 performLayout() 是每次布局都会被调用的</li></ul></li><li><p>ParentData</p><ul><li>不仅仅可以用来存储偏移信息，通常所有和子节点特定的数据都可以存储到子节点的 ParentData 中</li></ul></li></ul></li><li><p>绘制过程</p><ul><li>RenderObject 可以通过 paint 方法来完成具体绘制逻辑</li><li>RepaintBoundary</li></ul></li></ul><h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><ul><li>创建 StreamBuilder</li><li>获取 StreamSink 作为事件入口</li><li>获取 Stream 对象用于监听</li><li>通过监听得到 StreamSubscription 管理事件订阅</li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul><li>基于事件流驱动设计代码，然后监听订阅事件，并针对事件变换处理响应。</li></ul><h2 id="与原生通信"><a href="#与原生通信" class="headerlink" title="与原生通信"></a>与原生通信</h2><h3 id="MethodChannel"><a href="#MethodChannel" class="headerlink" title="MethodChannel"></a>MethodChannel</h3><ul><li><p>返回类型不一致</p><ul><li>由于涉及到跨系统数据交互，Flutter 会使用 StandardMessageCodec 对通道中传输的信息进行类似 JSON 的二进制序列化，以标准化数据传输行为</li><li>这样在我们发送或者接收数据时，这些数据就会根据各自系统预定的规则自动进行序列化和反序列化</li></ul></li><li><p>方法通道是非线程安全的</p><ul><li>这意味着原生代码与 Flutter 之间所有接口调用必须发生在主线程</li><li>而原生代码在处理方法调用请求时，如果涉及到异步或非主线程切换，需要确保回调过程是在原生系统的 UI 线程（也就是 Android 和 iOS 的主线程）中执行的</li></ul></li></ul><h3 id="EventChannel"><a href="#EventChannel" class="headerlink" title="EventChannel"></a>EventChannel</h3><ul><li>原生平台主动调用 flutter 端事件通道</li></ul><h3 id="平台视图"><a href="#平台视图" class="headerlink" title="平台视图"></a>平台视图</h3><ul><li><p>过程</p><ul><li>flutter 通过向原生视图的封装类传入视图标志，发起原生视图的创建请求</li><li>原生代码将对应原生视图的创建交给 PlatformViewFactory 实现</li><li>最后，在原生代码侧将视图标识符与平台视图工厂进行关联注册，让 Flutter 发起的视图创建请求可以直接找到对应的视图创建工厂。</li></ul></li><li><p>实现</p><ul><li>AndroidView</li><li>UikitView</li></ul></li></ul><h2 id="线程管理"><a href="#线程管理" class="headerlink" title="线程管理"></a>线程管理</h2><h3 id="四个线程"><a href="#四个线程" class="headerlink" title="四个线程"></a>四个线程</h3><ul><li>UI TaskRunner</li><li>Platform TaskRunner</li><li>GPU TaskRunner</li><li>IO TaskRunner</li></ul><h2 id="自绘组件"><a href="#自绘组件" class="headerlink" title="自绘组件"></a>自绘组件</h2><h3 id="CustomPaint"><a href="#CustomPaint" class="headerlink" title="CustomPaint"></a>CustomPaint</h3><ul><li><p>Canvas</p><ul><li><p>画布</p><ul><li>drawLine</li><li>drawRect</li><li>drawPaint</li></ul></li></ul></li><li><p>Paint</p><ul><li><p>画笔</p><ul><li>颜色</li><li>样式</li><li>粗细</li></ul></li></ul></li><li><p>CustomPainter</p><ul><li>绘制逻辑</li><li>继承</li></ul></li></ul><h2 id="RenderObject-和-RenderBox-1"><a href="#RenderObject-和-RenderBox-1" class="headerlink" title="RenderObject 和 RenderBox"></a>RenderObject 和 RenderBox</h2><p><strong>RenderObject 类本身实现了一套基础的 layout 和绘制协议，但是并没有定义子节点模型，坐标系统等</strong></p><h3 id="RenderBox-1"><a href="#RenderBox-1" class="headerlink" title="RenderBox"></a>RenderBox</h3><ul><li><p>布局过程</p><ul><li><p>Constraints</p><ul><li>限制子节点的最大和最小宽高，子节点必须遵守父节点给定的限制条件</li></ul></li></ul></li></ul><h2 id="Flutter-从启动到显示"><a href="#Flutter-从启动到显示" class="headerlink" title="Flutter 从启动到显示"></a>Flutter 从启动到显示</h2><ul><li><p>启动</p></li><li><p>渲染</p></li><li><p>绘制</p></li></ul><h2 id="编译模式"><a href="#编译模式" class="headerlink" title="编译模式"></a>编译模式</h2><ol><li><p>Script</p></li><li><p>Script Snapshot</p></li><li><p>Kernel Snapshot</p></li></ol><ul><li><p>Dart 的 bytecode 模式，在某种程度上类似 JVM。在 Flutter 项目中也被叫做 Core Snapshot，它是和设备架构无关的</p></li><li><p>debug 模式下的编译模式</p></li><li><p>生成产物</p><ul><li>isolate_snapshot_data: 加速 isolate 启动的数据，和业务无关</li><li>vm_snapshot_data: 加速 Dart VM 启动的数据，和业务无关</li><li>kernel_blob.bin: 业务代码产物</li></ul></li></ul><ol start="4"><li>Core JIT</li></ol><ul><li>aot 模式</li><li>编译后的二进制格式</li></ul><ol start="5"><li>AOT Assembly</li></ol><ul><li>aot</li></ul>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨平台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter动画</title>
      <link href="/2020/09/13/Flutter/Flutter%E5%8A%A8%E7%94%BB/"/>
      <url>/2020/09/13/Flutter/Flutter%E5%8A%A8%E7%94%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="AnimationController"><a href="#AnimationController" class="headerlink" title="AnimationController"></a>AnimationController</h2><ul><li><p>duration</p></li><li><p>controller.forward()</p><ul><li>动画开启</li></ul></li><li><p>controller.reset()</p></li><li><p>controller.reverse()</p></li></ul><h2 id="Tween"><a href="#Tween" class="headerlink" title="Tween"></a>Tween</h2><ul><li><p>补间动画</p></li><li><p>Tween 继承自 Animatable<t> 而不是 Animation</t></p></li><li><p>子主题 3</p></li></ul><h2 id="Animation"><a href="#Animation" class="headerlink" title="Animation"></a>Animation</h2><ul><li><p>保存动画的差值和状态</p></li><li><p>监听</p></li><li><p>addListener</p></li><li><p>addStatusListener</p><ul><li>动画状态监听</li></ul></li></ul><h2 id="Curve"><a href="#Curve" class="headerlink" title="Curve"></a>Curve</h2><h2 id="CurvedAnimation"><a href="#CurvedAnimation" class="headerlink" title="CurvedAnimation"></a>CurvedAnimation</h2><ul><li>非线性曲线</li></ul><h2 id="Ticker"><a href="#Ticker" class="headerlink" title="Ticker"></a>Ticker</h2><ul><li><p>Flutter 应用在启动时都会绑定一个 SchedulerBinding，通过 SchedulerBinding 可以给每一次屏幕刷新添加回调，而 Ticker 就是通过 SchedulerBinding 来添加屏幕刷新回调，这样一来，每次屏幕刷新都会调用 TickerCallback</p></li><li><p>使用 Ticker(而不是 Timer)来驱动动画会防止屏幕外动画（动画的 UI 不在当前屏幕时，如锁屏时）消耗不必要的资源</p></li></ul><h2 id="AnimatedWidget"><a href="#AnimatedWidget" class="headerlink" title="AnimatedWidget"></a>AnimatedWidget</h2><ul><li><p>封装了调用 setState()的细节，并允许我们将 widget 分离出来</p></li><li><p>动画组件继承 AnimatedWidget</p></li><li><p>会自动调用 addListener 的 setState 方法</p></li></ul><h2 id="AnimatedBuilder"><a href="#AnimatedBuilder" class="headerlink" title="AnimatedBuilder"></a>AnimatedBuilder</h2><ul><li><p>进一步封装动画组件</p></li><li><p>将渲染逻辑分离出来</p></li><li><p>好处</p><ul><li>不用显式的去添加帧监听器，然后再调用 setState()</li><li>动画构建的范围缩小了，只会导致子组件重新 setState</li><li>通过 AnimatedBuilder 可以封装常见的过渡效果来复用动画</li></ul></li></ul><h2 id="AnimatedSwitcher"><a href="#AnimatedSwitcher" class="headerlink" title="AnimatedSwitcher"></a>AnimatedSwitcher</h2><ul><li>对新旧动画的切换效果</li></ul>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨平台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter基础</title>
      <link href="/2020/09/12/Flutter/Flutter%E5%9F%BA%E7%A1%80/"/>
      <url>/2020/09/12/Flutter/Flutter%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="Widget"><a href="#Widget" class="headerlink" title="Widget"></a>Widget</h2><ul><li><p>Row,Column</p><ul><li>弹性布局</li></ul></li><li><p>Stack</p><ul><li>允许子元素堆叠</li></ul></li></ul><h2 id="Flutter-架构"><a href="#Flutter-架构" class="headerlink" title="Flutter 架构"></a>Flutter 架构</h2><h2 id="手势"><a href="#手势" class="headerlink" title="手势"></a>手势</h2><ul><li>GestureDetector</li></ul><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><ul><li><p>StatelessWidget</p></li><li><p>build</p></li><li><p>StatefulWidget</p><ul><li>createState</li><li>initState</li><li>reassemble</li><li>didChangeDependencies</li><li>build</li><li>deactivate</li><li>dispose</li><li>didUpdateWidget</li></ul></li></ul><h2 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h2><h3 id="widget-自己管理"><a href="#widget-自己管理" class="headerlink" title="widget 自己管理"></a>widget 自己管理</h3><h3 id="父-widget-管理"><a href="#父-widget-管理" class="headerlink" title="父 widget 管理"></a>父 widget 管理</h3><ul><li>管理状态并告诉子 widget 合适更新</li><li>将状态通过参数等方式传递给子 widget</li><li>子 widget 通过回调等方式更新父组件状态</li></ul><h3 id="混搭管理"><a href="#混搭管理" class="headerlink" title="混搭管理"></a>混搭管理</h3><h2 id="ListView"><a href="#ListView" class="headerlink" title="ListView"></a>ListView</h2><h3 id="懒加载机制"><a href="#懒加载机制" class="headerlink" title="懒加载机制"></a>懒加载机制</h3><ul><li><p>只绘制视窗内的 item</p></li><li><p>预加载视窗下的提前一个 widget</p></li><li><p>滑动过后的 item dispose 掉，之后再重新创建</p><ul><li>调用 initState 方法</li></ul></li></ul><h2 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h2><h3 id="直接执行-build-方法"><a href="#直接执行-build-方法" class="headerlink" title="直接执行 build 方法"></a>直接执行 build 方法</h3><h2 id="Decoration"><a href="#Decoration" class="headerlink" title="Decoration"></a>Decoration</h2><h3 id="BoxDecoration"><a href="#BoxDecoration" class="headerlink" title="BoxDecoration"></a>BoxDecoration</h3><ul><li>边框，圆角，阴影，形状，渐变，背景图</li></ul><h3 id="ShapeDecoration"><a href="#ShapeDecoration" class="headerlink" title="ShapeDecoration"></a>ShapeDecoration</h3><h3 id="FlutterLogoDecoration"><a href="#FlutterLogoDecoration" class="headerlink" title="FlutterLogoDecoration"></a>FlutterLogoDecoration</h3><h3 id="UnderlineTabindicator"><a href="#UnderlineTabindicator" class="headerlink" title="UnderlineTabindicator"></a>UnderlineTabindicator</h3><ul><li>下划线</li></ul><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li>使用 decoration 不能使用外部的样式</li></ul><h2 id="Dart-工厂模式"><a href="#Dart-工厂模式" class="headerlink" title="Dart 工厂模式"></a>Dart 工厂模式</h2><h2 id="手势竞争和处理"><a href="#手势竞争和处理" class="headerlink" title="手势竞争和处理"></a>手势竞争和处理</h2><ul><li><p>Flutter 中的手势识别引入了一个 Arena 的概念</p></li><li><p>当发生滑动事件时，他们都要在“竞技场”去竞争本次事件的处理权，而最终只有一个“竞争者”会胜出(win)</p></li><li><p>首次移动时的位移在水平和垂直方向上的分量大的一个获胜</p></li><li><p>在遇到复杂的冲突场景时，都可以通过 Listener 直接识别原始指针事件来解决冲突</p></li></ul><h2 id="Notification"><a href="#Notification" class="headerlink" title="Notification"></a>Notification</h2><ul><li><p>在 widget 树中，每一个节点都可以分发通知，通知会沿着当前节点向上传递，所有父节点都可以通过 NotificationListener 来监听通知</p></li><li><p>通知冒泡可以中止，但用户触摸事件不行</p></li></ul><h2 id="自定义路由动画"><a href="#自定义路由动画" class="headerlink" title="自定义路由动画"></a>自定义路由动画</h2><ul><li>PageRouteBuilder</li></ul><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><ul><li><p>布局调试</p></li><li><p>debugPaintEnable = true</p></li><li><p>flutter Inspector</p></li></ul><h2 id="分析模式"><a href="#分析模式" class="headerlink" title="分析模式"></a>分析模式</h2><ul><li><p>分析渲染问题</p></li><li><p>dart devtools</p></li></ul><h2 id="自动化测试用例"><a href="#自动化测试用例" class="headerlink" title="自动化测试用例"></a>自动化测试用例</h2><ul><li><p>单元测试</p></li><li><p>UI 测试</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨平台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FlutterAPI</title>
      <link href="/2020/09/11/Flutter/FlutterAPI/"/>
      <url>/2020/09/11/Flutter/FlutterAPI/</url>
      
        <content type="html"><![CDATA[<h2 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h2><h3 id="InheritedWidget"><a href="#InheritedWidget" class="headerlink" title="InheritedWidget"></a>InheritedWidget</h3><ul><li>可以将父类数据直接传递给孙子类</li><li>而不是子类传递子类</li></ul><h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><ol><li><p>基于事件流驱动设计代码，然后监听订阅事件，并针对事件变换处理响应</p></li><li><p>提供一个异步的数据序列</p></li><li><p>_streams.listen(onData,onError,onDone)</p></li><li><p>StreamSubscription</p></li></ol><ul><li>暂停，恢复，取消监听</li><li>取消监听之后 不能恢复</li></ul><ol start="5"><li>StreamController</li></ol><ul><li><p>动态添加订阅</p></li><li><p>StreamController.brodcast()</p><ul><li>多次添加订阅信息</li></ul></li></ul><ol start="6"><li>StreamSink</li></ol><ul><li>向 stream 添加数据</li></ul><ol start="7"><li>StreamBuilder</li></ol><ul><li>获取到异步的数据后，自动更新组件</li></ul><h2 id="RxDart"><a href="#RxDart" class="headerlink" title="RxDart"></a>RxDart</h2><ul><li><p>Observable</p></li><li><p>PublishObservable</p></li><li><p>BehaviorSubject</p></li><li><p>ReplaySubject</p></li></ul><h2 id="Bloc"><a href="#Bloc" class="headerlink" title="Bloc"></a>Bloc</h2><h2 id="Animation"><a href="#Animation" class="headerlink" title="Animation"></a>Animation</h2><ul><li>AnimationController</li></ul><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><ul><li>单元测试</li></ul><h2 id="与-Native-通信"><a href="#与-Native-通信" class="headerlink" title="与 Native 通信"></a>与 Native 通信</h2><ul><li><p>PlatformChannel</p></li><li><p>MethodChannel</p><ul><li>用于方法传递</li></ul></li><li><p>EventChannel</p><ul><li>用于传递事件</li></ul></li><li><p>BasicMessageChannel</p><ul><li>传递数据</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨平台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter Provider</title>
      <link href="/2020/09/10/Flutter/Flutter%20Provider/"/>
      <url>/2020/09/10/Flutter/Flutter%20Provider/</url>
      
        <content type="html"><![CDATA[<h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p><strong>关注由于值的变化进行  跨组件的状态更新</strong></p><h2 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider</h2><ol><li><p>ChangeNotifierProvider</p></li><li><p>ProxyProvider</p></li></ol><ul><li>当两个 view model 之间存在依赖关系的时候使用这个类型的 provider。</li></ul><ol start="3"><li>ChangeNotifierProxyProvider</li></ol><ul><li>会发送更新到 ChangeNotifierProvider</li></ul><ol start="4"><li>StreamProvider</li></ol><ul><li>对 StreamBulder 的一层封装</li></ul><ol start="5"><li>FutureProvider</li></ol><ul><li>对 FutureBuilder 的一层封装</li></ul><h2 id="触发"><a href="#触发" class="headerlink" title="触发"></a>触发</h2><ul><li>Provider.of<t>()</t></li></ul><h2 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h2><ul><li><p>consumer</p></li><li><p>selector</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨平台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础架构</title>
      <link href="/2020/01/30/Android/%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/"/>
      <url>/2020/01/30/Android/%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><h3 id="model"><a href="#model" class="headerlink" title="model"></a>model</h3><ul><li>代表数据模型，管理数据状态</li></ul><h3 id="view"><a href="#view" class="headerlink" title="view"></a>view</h3><ul><li>视图，即呈现给用户的 UI</li></ul><h3 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h3><ul><li>负责处理用户与 app 之间的交互</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>View 与 Model 之间存在依赖关系，Controller 很重很复杂</li><li>view 层和 model 层是相互可知的，这意味着两层之间存在耦合</li></ul><p><strong>在 Android 中 Activity 即是 View 又是 Controller，所以会很复杂</strong></p><ul><li>xml 文件就对应于 MVC 的 view 层</li><li>网络请求相当于 Model 层</li><li>Activity 相当于 Controller</li></ul><h2 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h2><h3 id="model-1"><a href="#model-1" class="headerlink" title="model"></a>model</h3><ul><li>同上</li></ul><h3 id="view-1"><a href="#view-1" class="headerlink" title="view"></a>view</h3><ul><li>同上</li></ul><h3 id="presenter"><a href="#presenter" class="headerlink" title="presenter"></a>presenter</h3><ul><li><p>Presenter 通过 View 接收用户的输入，然后在 Model 的帮助下处理用户的数据并将结果传递回 View</p><ul><li>Presenter 通过接口与 View 进行通信</li></ul></li></ul><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><ul><li>presenter 层充当了桥梁的作用，用于操作 view 层发出的事件传递到 presenter 层中，presenter 层去操作 model 层，并且将数据返回给 view 层</li></ul><p><strong>虽然是 MVC 模式的演变，但 Presenter 依旧很‘重’很复杂。</strong></p><h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><h3 id="model-2"><a href="#model-2" class="headerlink" title="model"></a>model</h3><ul><li>同上</li></ul><h3 id="view-2"><a href="#view-2" class="headerlink" title="view"></a>view</h3><ul><li>同上</li></ul><h3 id="viewModel"><a href="#viewModel" class="headerlink" title="viewModel"></a>viewModel</h3><ul><li>View 引用持有 ViewModel，但 ViewModel 得不到任何关于 View 的信息</li><li>View 与 ViewModel 之间存在着一对多的关系，一个 View 可以持有多个 ViewModel</li></ul><p><strong>view 层和 viewmodel 层是相互绑定的关系，这意味着当你更新 viewmodel 层的数据的时候，view 层会相应的变动 ui</strong></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android基础</title>
      <link href="/2020/01/27/Android/Android%E5%9F%BA%E7%A1%80/"/>
      <url>/2020/01/27/Android/Android%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h2><h3 id="Linux-内核"><a href="#Linux-内核" class="headerlink" title="Linux 内核"></a>Linux 内核</h3><h3 id="系统运行库"><a href="#系统运行库" class="headerlink" title="系统运行库"></a>系统运行库</h3><ul><li><p>c/c++库</p><ul><li>sqlite</li><li>opengl</li></ul></li><li><p>运行时库</p><ul><li>虚拟机</li><li>ART</li></ul></li></ul><h3 id="应用框架层"><a href="#应用框架层" class="headerlink" title="应用框架层"></a>应用框架层</h3><ul><li>framework 层</li></ul><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><h2 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h2><h3 id="launchMode"><a href="#launchMode" class="headerlink" title="launchMode"></a>launchMode</h3><ul><li><p>standard</p><ul><li>无论栈中是否有实例，都会去重新创建</li></ul></li><li><p>singleTop</p><ul><li>如果栈顶已经是这个实例，不会重新创建</li></ul></li><li><p>singleTask</p><ul><li>每次启动该实例，都会检查是否存在</li><li>如果存在，直接使用该实例，并把这个活动之上的所有活动出栈</li></ul></li><li><p>singleInstance</p><ul><li>启动这个实例的时候，启动一个栈来专门存放该实例</li></ul></li></ul><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><ul><li>onCreate</li><li>onStart</li><li>onPause</li><li>onResume</li><li>onStop</li><li>onDestory</li></ul><h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><ol><li>基本布局</li></ol><ul><li>LinearLayout</li><li>RelativeLayout</li><li>FrameLayout</li><li>PercentLayout</li></ul><ol start="2"><li>自定义布局</li></ol><h2 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h2><ul><li>replaceFragment</li></ul><ol><li>生命周期</li></ol><ul><li><p>onAttach</p><ul><li>当 fragment 和 activity 关联的时候调用</li></ul></li><li><p>onCreateView</p><ul><li>加载布局的时候调用</li></ul></li><li><p>onActivityCreated</p></li><li><p>onDestroyView</p></li><li><p>onDetach</p><ul><li>和 Activity 解除关联的时候</li></ul></li><li><p>完整生命周期</p></li></ul><h2 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h2><ol><li>标准广播</li></ol><ul><li>异步执行的</li><li>广播接收器会在同一时刻接收到这条信息</li></ul><ol start="2"><li>有序广播</li></ol><ul><li>同步执行的广播</li></ul><ol start="3"><li>本地广播</li></ol><h2 id="ContentProvider"><a href="#ContentProvider" class="headerlink" title="ContentProvider"></a>ContentProvider</h2><ul><li>跨进程共享数据</li></ul><h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><ol><li>生命周期</li></ol><ul><li>onCreate</li><li>onStartCommand</li><li>onBind</li><li>onDestroy</li></ul><ol start="2"><li>前台服务</li></ol><ul><li>当系统内存不足时，有可能回收正在后台运行的服务</li><li>前台服务会有一个正在运行的图表在系统的状态栏显示</li></ul><ol start="3"><li>Service 运行在主线程，耗时操作需要启动一个子线程</li></ol><h2 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h2><ul><li>Message,Handler,MessageQueue,Looper</li></ul><ol><li>Message</li></ol><ul><li>在线程之间传递消息，内部携带少量数据</li></ul><ol start="2"><li>Handler</li></ol><ul><li>发送和处理信息</li></ul><ol start="3"><li>MessageQueue</li></ol><ul><li>主要用户存放所有通过 Handler 发送的消息</li></ul><ol start="4"><li>Looper</li></ol><ul><li>当发现 MessageQueue 中存在一条消息，会将它取出，并传递到 handleMessage 方法中</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="Serializable-和-Parcelable"><a href="#Serializable-和-Parcelable" class="headerlink" title="Serializable 和 Parcelable"></a>Serializable 和 Parcelable</h3><ul><li><p>Serializable</p><ul><li>java 序列化</li></ul></li><li><p>Parcelable</p><ul><li>Android 独有的序列化</li><li>进行了优化 但是实现较为复杂</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React架构</title>
      <link href="/2019/09/12/React/React%E6%9E%B6%E6%9E%84/"/>
      <url>/2019/09/12/React/React%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><h3 id="易开发"><a href="#易开发" class="headerlink" title="易开发"></a>易开发</h3><ul><li>开发工具</li><li>生态圈</li><li>社区活跃</li></ul><h3 id="易于扩展"><a href="#易于扩展" class="headerlink" title="易于扩展"></a>易于扩展</h3><h3 id="易于维护"><a href="#易于维护" class="headerlink" title="易于维护"></a>易于维护</h3><ul><li>文档是否健全</li></ul><h3 id="易于测试"><a href="#易于测试" class="headerlink" title="易于测试"></a>易于测试</h3><ul><li>功能分层是否清晰</li><li>副作用少</li><li>尽量使用纯函数</li></ul><h3 id="易于构建"><a href="#易于构建" class="headerlink" title="易于构建"></a>易于构建</h3><ul><li>使用通用技术和架构</li><li>构建工具</li></ul><h2 id="拆分复杂度"><a href="#拆分复杂度" class="headerlink" title="拆分复杂度"></a>拆分复杂度</h2><h3 id="按-feature-组织代码，降低耦合度"><a href="#按-feature-组织代码，降低耦合度" class="headerlink" title="按 feature 组织代码，降低耦合度"></a>按 feature 组织代码，降低耦合度</h3><ul><li>将业务逻辑拆分成高内聚松耦合的模块</li></ul><h3 id="文件夹结构"><a href="#文件夹结构" class="headerlink" title="文件夹结构"></a>文件夹结构</h3><ul><li>按照功能组织源文件</li><li>组件和样式在同一级</li><li>把 action 和 reducer 放到同一级</li></ul><h3 id="组织-Router-路由配置"><a href="#组织-Router-路由配置" class="headerlink" title="组织 Router 路由配置"></a>组织 Router 路由配置</h3><ul><li><p>每个 feature 中单独定义自己的路由</p><ul><li>每个 feature 都有一个 route.js</li></ul></li><li><p>使用 JSON 定义顶层路由</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React生态圈</title>
      <link href="/2019/09/12/React/React%E7%94%9F%E6%80%81%E5%9C%88/"/>
      <url>/2019/09/12/React/React%E7%94%9F%E6%80%81%E5%9C%88/</url>
      
        <content type="html"><![CDATA[<h2 id="React-Router"><a href="#React-Router" class="headerlink" title="React Router"></a>React Router</h2><p><strong>在一个组件容器中，根据 url 去判断，要展示什么组件</strong></p><ul><li>单页面应用中</li></ul><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li><p>声明式路由定义</p><ul><li><route></route></li></ul></li><li><p>动态路由</p></li></ul><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><ul><li><p>URL 路径</p></li><li><p>hash 路由</p><ul><li>低版本浏览器兼容</li></ul></li><li><p>内存路由</p><ul><li><p>MemoryRouter</p><ul><li>url 链接没有变化</li><li>路由存在内存中</li></ul></li></ul></li></ul><h3 id="基于路由配置进行资源组织"><a href="#基于路由配置进行资源组织" class="headerlink" title="基于路由配置进行资源组织"></a>基于路由配置进行资源组织</h3><ul><li>实现业务逻辑的解耦</li><li>易于扩展，重构，维护</li><li>路由层面实现 Lazy Load</li></ul><h3 id="核心-API"><a href="#核心-API" class="headerlink" title="核心 API"></a>核心 API</h3><ul><li><link><ul><li>不会触发浏览器刷新</li></ul></li><li><p>NavLink</p><ul><li>类似 Link 而且会添加当前选中状态</li></ul></li><li><p>Prompt</p><ul><li>满足条件时提示用户是否离开当前页面</li></ul></li><li><p>Redirect</p><ul><li>重定向到指定界面</li></ul></li><li><p>Route</p><ul><li><p>路径匹配时显示对应组件</p></li><li><p>可以多匹配不同的路由</p><ul><li>同时显示</li></ul></li></ul></li><li><p>Switch</p><ul><li>只显示第一个匹配的路由</li></ul></li></ul><h3 id="通过-URL-传递参数"><a href="#通过-URL-传递参数" class="headerlink" title="通过 URL 传递参数"></a>通过 URL 传递参数</h3><ul><li><p>参数获取</p><ul><li>match.params.id</li></ul></li><li><p>通过 url 获取参数</p></li></ul><h3 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h3><h2 id="UI-组件库"><a href="#UI-组件库" class="headerlink" title="UI 组件库"></a>UI 组件库</h2><ul><li><p>AntD</p></li><li><p>Material-UI</p></li></ul><h2 id="Next-js"><a href="#Next-js" class="headerlink" title="Next.js"></a>Next.js</h2><h3 id="同构应用"><a href="#同构应用" class="headerlink" title="同构应用"></a>同构应用</h3><ul><li>初次发送请求</li><li>返回渲染后的 App 界面</li><li>客户端本地操作</li></ul><h3 id="使用-Link"><a href="#使用-Link" class="headerlink" title="使用 Link"></a>使用 Link</h3><ul><li><p>同步路由</p></li><li><p>不会刷新界面</p></li><li><p>prefetch</p><ul><li>预加载</li></ul></li><li><p>replace</p><ul><li>使用新的 URL 链接</li></ul></li><li><p>lazyLoad</p><ul><li>next/dynamic</li></ul></li></ul><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><h3 id="虚拟-DOM-可以在-NodeJs-环境运行和测试"><a href="#虚拟-DOM-可以在-NodeJs-环境运行和测试" class="headerlink" title="虚拟 DOM 可以在 NodeJs 环境运行和测试"></a>虚拟 DOM 可以在 NodeJs 环境运行和测试</h3><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><ul><li><p>jest</p></li><li><p>jsdom</p><ul><li>模拟浏览器的 NodeJs 环境</li></ul></li><li><p>Enzyme</p><ul><li><p>Shallow Rendering</p><ul><li>shallow</li></ul></li><li><p>Full Render</p><ul><li>count</li></ul></li></ul></li><li><p>nock</p><ul><li>模拟 HTTP 请求</li><li>模拟返回数据 和 返回类型</li></ul></li><li><p>Sinon</p><ul><li>函数的跟踪</li></ul></li></ul><h2 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h2><ol><li>ESLint</li></ol><ul><li><p>.eslintrc 进行规则配置</p></li><li><p>extend 属性</p><ul><li>依赖本地的 .eslintrc</li></ul></li></ul><ol start="2"><li>Prettier</li></ol><ul><li>代码风格格式化</li></ul><ol start="3"><li><p>React Dev Tool</p></li><li><p>Redux Dev Tool</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React性能优化</title>
      <link href="/2019/09/10/React/React%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
      <url>/2019/09/10/React/React%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="时刻注意性能问题"><a href="#时刻注意性能问题" class="headerlink" title="时刻注意性能问题"></a>时刻注意性能问题</h2><h3 id="常见性能问题场景"><a href="#常见性能问题场景" class="headerlink" title="常见性能问题场景"></a>常见性能问题场景</h3><ul><li>键盘输入</li><li>组件移动或页面滚动</li></ul><h3 id="代码的潜在性能问题"><a href="#代码的潜在性能问题" class="headerlink" title="代码的潜在性能问题"></a>代码的潜在性能问题</h3><ul><li>组件的粒度</li></ul><h3 id="代码可重构"><a href="#代码可重构" class="headerlink" title="代码可重构"></a>代码可重构</h3><ul><li>耦合性低</li></ul><h3 id="使用工具定位性能问题"><a href="#使用工具定位性能问题" class="headerlink" title="使用工具定位性能问题"></a>使用工具定位性能问题</h3><ul><li>devtool</li></ul><h2 id="网络性能优化"><a href="#网络性能优化" class="headerlink" title="网络性能优化"></a>网络性能优化</h2><ul><li><p>webpack 的 import API</p></li><li><p>react-loadable 组件进行按需加载</p></li></ul><h2 id="Reselect-避免重复计算"><a href="#Reselect-避免重复计算" class="headerlink" title="Reselect 避免重复计算"></a>Reselect 避免重复计算</h2><ul><li><p>对 store 中的数据进行计算缓存</p></li><li><p>当数据发生变化时才会去执行计算过程，否则使用缓存的结果</p></li></ul><h2 id="异步渲染"><a href="#异步渲染" class="headerlink" title="异步渲染"></a>异步渲染</h2><h3 id="时间分片"><a href="#时间分片" class="headerlink" title="时间分片"></a>时间分片</h3><ul><li><p>DOM 操作的优先级低于浏览器原生行为</p></li><li><p>如键盘和鼠标输入，保证操作的流畅</p></li><li><p>Chrome 的 API</p><ul><li>requestIdleCallback</li><li>浏览器不忙的状态</li></ul></li><li><p>React 的 API</p><ul><li>deferredUpdates</li></ul></li></ul><h3 id="渲染挂起"><a href="#渲染挂起" class="headerlink" title="渲染挂起"></a>渲染挂起</h3><ul><li>虚拟 DOM 节点可以等待某个异步操作的完成，指定 timeout 之后才完成真正渲染</li></ul><h2 id="Chrome-DevTool"><a href="#Chrome-DevTool" class="headerlink" title="Chrome DevTool"></a>Chrome DevTool</h2><h3 id="React-DevTool"><a href="#React-DevTool" class="headerlink" title="React DevTool"></a>React DevTool</h3><ul><li>HighLight Update</li></ul><h3 id="Chrome-DevTool-1"><a href="#Chrome-DevTool-1" class="headerlink" title="Chrome DevTool"></a>Chrome DevTool</h3><ul><li>CPU 降速</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
